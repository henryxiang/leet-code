{
  "questionId": "1014",
  "questionFrontendId": "973",
  "boundTopicId": null,
  "title": "K Closest Points to Origin",
  "titleSlug": "k-closest-points-to-origin",
  "categoryTitle": "Algorithms",
  "content": "<p>We have a list of <code>points</code>&nbsp;on the plane.&nbsp; Find the <code>K</code> closest points to the origin <code>(0, 0)</code>.</p>\r\n\r\n<p>(Here, the distance between two points on a plane is the Euclidean distance.)</p>\r\n\r\n<p>You may return the answer in any order.&nbsp; The&nbsp;answer is guaranteed to be unique (except for the order that it is in.)</p>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<div>\r\n<p><strong>Example 1:</strong></p>\r\n\r\n<pre>\r\n<strong>Input: </strong>points = <span id=\"example-input-1-1\">[[1,3],[-2,2]]</span>, K = <span id=\"example-input-1-2\">1</span>\r\n<strong>Output: </strong><span id=\"example-output-1\">[[-2,2]]</span>\r\n<strong>Explanation: </strong>\r\nThe distance between (1, 3) and the origin is sqrt(10).\r\nThe distance between (-2, 2) and the origin is sqrt(8).\r\nSince sqrt(8) &lt; sqrt(10), (-2, 2) is closer to the origin.\r\nWe only want the closest K = 1 points from the origin, so the answer is just [[-2,2]].\r\n</pre>\r\n\r\n<div>\r\n<p><strong>Example 2:</strong></p>\r\n\r\n<pre>\r\n<strong>Input: </strong>points = <span id=\"example-input-2-1\">[[3,3],[5,-1],[-2,4]]</span>, K = <span id=\"example-input-2-2\">2</span>\r\n<strong>Output: </strong><span id=\"example-output-2\">[[3,3],[-2,4]]</span>\r\n(The answer [[-2,4],[3,3]] would also be accepted.)\r\n</pre>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p><strong>Note:</strong></p>\r\n\r\n<ol>\r\n\t<li><code>1 &lt;= K &lt;= points.length &lt;= 10000</code></li>\r\n\t<li><code>-10000 &lt; points[i][0] &lt; 10000</code></li>\r\n\t<li><code>-10000 &lt; points[i][1] &lt; 10000</code></li>\r\n</ol>\r\n</div>\r\n</div>",
  "isPaidOnly": false,
  "difficulty": "Medium",
  "likes": 925,
  "dislikes": 82,
  "isLiked": null,
  "similarQuestions": "[{\"title\": \"Kth Largest Element in an Array\", \"titleSlug\": \"kth-largest-element-in-an-array\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Top K Frequent Elements\", \"titleSlug\": \"top-k-frequent-elements\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Top K Frequent Words\", \"titleSlug\": \"top-k-frequent-words\", \"difficulty\": \"Medium\", \"translatedTitle\": null}]",
  "contributors": [],
  "topicTags": [
    {
      "name": "Divide and Conquer",
      "slug": "divide-and-conquer"
    },
    {
      "name": "Heap",
      "slug": "heap"
    },
    {
      "name": "Sort",
      "slug": "sort"
    }
  ],
  "companyTagStats": "{\"1\": [{\"taggedByAdmin\": true, \"name\": \"Facebook\", \"slug\": \"facebook\", \"timesEncountered\": 57}, {\"taggedByAdmin\": false, \"name\": \"Amazon\", \"slug\": \"amazon\", \"timesEncountered\": 49}, {\"taggedByAdmin\": false, \"name\": \"Asana\", \"slug\": \"asana\", \"timesEncountered\": 5}, {\"taggedByAdmin\": false, \"name\": \"Expedia\", \"slug\": \"expedia\", \"timesEncountered\": 4}, {\"taggedByAdmin\": false, \"name\": \"Google\", \"slug\": \"google\", \"timesEncountered\": 2}, {\"taggedByAdmin\": false, \"name\": \"Apple\", \"slug\": \"apple\", \"timesEncountered\": 2}, {\"taggedByAdmin\": false, \"name\": \"Microsoft\", \"slug\": \"microsoft\", \"timesEncountered\": 2}, {\"taggedByAdmin\": false, \"name\": \"Uber\", \"slug\": \"uber\", \"timesEncountered\": 2}], \"2\": [{\"taggedByAdmin\": false, \"name\": \"LinkedIn\", \"slug\": \"linkedin\", \"timesEncountered\": 2}, {\"taggedByAdmin\": false, \"name\": \"Yahoo\", \"slug\": \"yahoo\", \"timesEncountered\": 2}, {\"taggedByAdmin\": false, \"name\": \"eBay\", \"slug\": \"ebay\", \"timesEncountered\": 2}], \"3\": []}",
  "codeSnippets": [
    {
      "lang": "C++",
      "code": "class Solution {\npublic:\n    vector<vector<int>> kClosest(vector<vector<int>>& points, int K) {\n        \n    }\n};"
    },
    {
      "lang": "Java",
      "code": "class Solution {\n    public int[][] kClosest(int[][] points, int K) {\n        \n    }\n}"
    },
    {
      "lang": "Python",
      "code": "class Solution(object):\n    def kClosest(self, points, K):\n        \"\"\"\n        :type points: List[List[int]]\n        :type K: int\n        :rtype: List[List[int]]\n        \"\"\"\n        "
    },
    {
      "lang": "Python3",
      "code": "class Solution:\n    def kClosest(self, points: List[List[int]], K: int) -> List[List[int]]:\n        "
    },
    {
      "lang": "C",
      "code": "\n\n/**\n * Return an array of arrays of size *returnSize.\n * The sizes of the arrays are returned as *returnColumnSizes array.\n * Note: Both returned array and *columnSizes array must be malloced, assume caller calls free().\n */\nint** kClosest(int** points, int pointsSize, int* pointsColSize, int K, int* returnSize, int** returnColumnSizes){\n\n}\n\n"
    },
    {
      "lang": "C#",
      "code": "public class Solution {\n    public int[][] KClosest(int[][] points, int K) {\n        \n    }\n}"
    },
    {
      "lang": "JavaScript",
      "code": "/**\n * @param {number[][]} points\n * @param {number} K\n * @return {number[][]}\n */\nvar kClosest = function(points, K) {\n    \n};"
    },
    {
      "lang": "Ruby",
      "code": "# @param {Integer[][]} points\n# @param {Integer} k\n# @return {Integer[][]}\ndef k_closest(points, k)\n    \nend"
    },
    {
      "lang": "Swift",
      "code": "class Solution {\n    func kClosest(_ points: [[Int]], _ K: Int) -> [[Int]] {\n        \n    }\n}"
    },
    {
      "lang": "Go",
      "code": "func kClosest(points [][]int, K int) [][]int {\n    \n}"
    },
    {
      "lang": "Scala",
      "code": "object Solution {\n    def kClosest(points: Array[Array[Int]], K: Int): Array[Array[Int]] = {\n        \n    }\n}"
    },
    {
      "lang": "Kotlin",
      "code": "class Solution {\n    fun kClosest(points: Array<IntArray>, K: Int): Array<IntArray> {\n        \n    }\n}"
    },
    {
      "lang": "Rust",
      "code": "impl Solution {\n    pub fn k_closest(points: Vec<Vec<i32>>, k: i32) -> Vec<Vec<i32>> {\n        \n    }\n}"
    },
    {
      "lang": "PHP",
      "code": "class Solution {\n\n    /**\n     * @param Integer[][] $points\n     * @param Integer $K\n     * @return Integer[][]\n     */\n    function kClosest($points, $K) {\n        \n    }\n}"
    }
  ],
  "stats": "{\"totalAccepted\": \"158K\", \"totalSubmission\": \"256.7K\", \"totalAcceptedRaw\": 157976, \"totalSubmissionRaw\": 256732, \"acRate\": \"61.5%\"}",
  "hints": [],
  "solution": {
    "id": "667",
    "canSeeDetail": true,
    "url": "/articles/k-closest-points-to-origin/",
    "content": "[TOC]\n\n## Solution\n---\n#### Approach 1: Sort\n\n**Intuition**\n\nSort the points by distance, then take the closest K points.\n\n**Algorithm**\n\nThere are two variants.\n\nIn Java, we find the K-th distance by creating an array of distances and then sorting them.  After, we select all the points with distance less than or equal to this K-th distance.\n\nIn Python, we sort by a custom key function - namely, the distance to the origin.  Afterwards, we return the first K elements of the list.\n\n<iframe src=\"https://leetcode.com/playground/qsCBvg6X/shared\" frameBorder=\"0\" width=\"100%\" height=\"429\" name=\"qsCBvg6X\"></iframe>\n\n**Complexity Analysis**\n\n* Time Complexity:  $$O(N \\log N)$$, where $$N$$ is the length of `points`.\n\n* Space Complexity:  $$O(N)$$.\n<br />\n<br />\n\n\n---\n#### Approach 2: Divide and Conquer\n\n**Intuition**\n\nWe want an algorithm faster than $$N \\log N$$.  Clearly, the only way to do this is to use the fact that the K elements returned can be in any order -- otherwise we would be sorting which is at least $$N \\log N$$.\n\nSay we choose some random element `x = A[i]` and split the array into two buckets: one bucket of all the elements less than `x`, and another bucket of all the elements greater than or equal to `x`.  This is known as \"quickselecting by a pivot `x`\".\n\nThe idea is that if we quickselect by some pivot, on average in linear time we'll reduce the problem to a problem of half the size.\n\n**Algorithm**\n\nLet's do the `work(i, j, K)` of partially sorting the subarray `(points[i], points[i+1], ..., points[j])` so that the smallest `K` elements of this subarray occur in the first `K` positions `(i, i+1, ..., i+K-1)`.\n\nFirst, we quickselect by a random pivot element from the subarray.  To do this in place, we have two pointers `i` and `j`, and move these pointers to the elements that are in the wrong bucket -- then, we swap these elements.\n\nAfter, we have two buckets `[oi, i]` and `[i+1, oj]`, where `(oi, oj)` are the original `(i, j)` values when calling `work(i, j, K)`.  Say the first bucket has `10` items and the second bucket has `15` items.  If we were trying to partially sort say, `K = 5` items, then we only need to partially sort the first bucket: `work(oi, i, 5)`.  Otherwise, if we were trying to partially sort say, `K = 17` items, then the first `10` items are already partially sorted, and we only need to partially sort the next 7 items: `work(i+1, oj, 7)`.\n\n<iframe src=\"https://leetcode.com/playground/9yZ96Kwf/shared\" frameBorder=\"0\" width=\"100%\" height=\"500\" name=\"9yZ96Kwf\"></iframe>\n\n**Complexity Analysis**\n\n* Time Complexity:  $$O(N)$$ in *average case* complexity, where $$N$$ is the length of `points`.\n\n* Space Complexity:  $$O(N)$$.\n<br />\n<br />\n\n\n---\nAnalysis written by: [@awice](https://leetcode.com/awice).",
    "contentTypeId": "107",
    "rating": {
      "id": "653",
      "count": 104,
      "average": 2.846,
      "userRating": null
    }
  },
  "status": null,
  "sampleTestCase": "[[1,3],[-2,2]]\n1",
  "metaData": "{\r\n  \"name\": \"kClosest\",\r\n  \"params\": [\r\n    {\r\n      \"name\": \"points\",\r\n      \"type\": \"integer[][]\"\r\n    },\r\n    {\r\n      \"name\": \"K\",\r\n      \"type\": \"integer\"\r\n    }\r\n  ],\r\n  \"return\": {\r\n    \"type\": \"integer[][]\"\r\n  }\r\n}\r\n",
  "judgerAvailable": true,
  "judgeType": "large",
  "mysqlSchemas": [],
  "enableRunCode": true,
  "enableTestMode": false,
  "libraryUrl": null
}
