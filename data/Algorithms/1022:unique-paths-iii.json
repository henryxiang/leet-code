{
  "questionId": "1022",
  "questionFrontendId": "980",
  "boundTopicId": null,
  "title": "Unique Paths III",
  "titleSlug": "unique-paths-iii",
  "categoryTitle": "Algorithms",
  "content": "<p>On a 2-dimensional&nbsp;<code>grid</code>, there are 4 types of squares:</p>\r\n\r\n<ul>\r\n\t<li><code>1</code> represents the starting square.&nbsp; There is exactly one starting square.</li>\r\n\t<li><code>2</code> represents the ending square.&nbsp; There is exactly one ending square.</li>\r\n\t<li><code>0</code> represents empty squares we can walk over.</li>\r\n\t<li><code>-1</code> represents obstacles that we cannot walk over.</li>\r\n</ul>\r\n\r\n<p>Return the number of 4-directional walks&nbsp;from the starting square to the ending square, that <strong>walk over every non-obstacle square&nbsp;exactly once</strong>.</p>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<div>\r\n<p><strong>Example 1:</strong></p>\r\n\r\n<pre>\r\n<strong>Input: </strong><span id=\"example-input-1-1\">[[1,0,0,0],[0,0,0,0],[0,0,2,-1]]</span>\r\n<strong>Output: </strong><span id=\"example-output-1\">2</span>\r\n<strong>Explanation: </strong>We have the following two paths: \r\n1. (0,0),(0,1),(0,2),(0,3),(1,3),(1,2),(1,1),(1,0),(2,0),(2,1),(2,2)\r\n2. (0,0),(1,0),(2,0),(2,1),(1,1),(0,1),(0,2),(0,3),(1,3),(1,2),(2,2)</pre>\r\n\r\n<div>\r\n<p><strong>Example 2:</strong></p>\r\n\r\n<pre>\r\n<strong>Input: </strong><span id=\"example-input-2-1\">[[1,0,0,0],[0,0,0,0],[0,0,0,2]]</span>\r\n<strong>Output: </strong><span id=\"example-output-2\">4</span>\r\n<strong>Explanation: </strong>We have the following four paths: \r\n1. (0,0),(0,1),(0,2),(0,3),(1,3),(1,2),(1,1),(1,0),(2,0),(2,1),(2,2),(2,3)\r\n2. (0,0),(0,1),(1,1),(1,0),(2,0),(2,1),(2,2),(1,2),(0,2),(0,3),(1,3),(2,3)\r\n3. (0,0),(1,0),(2,0),(2,1),(2,2),(1,2),(1,1),(0,1),(0,2),(0,3),(1,3),(2,3)\r\n4. (0,0),(1,0),(2,0),(2,1),(1,1),(0,1),(0,2),(0,3),(1,3),(1,2),(2,2),(2,3)</pre>\r\n\r\n<div>\r\n<p><strong>Example 3:</strong></p>\r\n\r\n<pre>\r\n<strong>Input: </strong><span id=\"example-input-3-1\">[[0,1],[2,0]]</span>\r\n<strong>Output: </strong><span id=\"example-output-3\">0</span>\r\n<strong>Explanation: </strong>\r\nThere is no path that walks over every empty square exactly once.\r\nNote that the starting and ending square can be anywhere in the grid.\r\n</pre>\r\n</div>\r\n</div>\r\n</div>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p><strong>Note:</strong></p>\r\n\r\n<ol>\r\n\t<li><code>1 &lt;= grid.length * grid[0].length &lt;= 20</code></li>\r\n</ol>",
  "isPaidOnly": false,
  "difficulty": "Hard",
  "likes": 348,
  "dislikes": 44,
  "isLiked": null,
  "similarQuestions": "[{\"title\": \"Sudoku Solver\", \"titleSlug\": \"sudoku-solver\", \"difficulty\": \"Hard\", \"translatedTitle\": null}, {\"title\": \"Unique Paths II\", \"titleSlug\": \"unique-paths-ii\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Word Search II\", \"titleSlug\": \"word-search-ii\", \"difficulty\": \"Hard\", \"translatedTitle\": null}]",
  "contributors": [
    {
      "username": "brahhh",
      "profileUrl": "/brahhh/",
      "avatarUrl": "https://assets.leetcode.com/users/brahhh/avatar_1544742939.png"
    }
  ],
  "topicTags": [
    {
      "name": "Backtracking",
      "slug": "backtracking"
    },
    {
      "name": "Depth-first Search",
      "slug": "depth-first-search"
    }
  ],
  "companyTagStats": "{\"3\": [{\"taggedByAdmin\": true, \"name\": \"LimeBike\", \"slug\": \"limebike\", \"timesEncountered\": 0}], \"1\": [{\"taggedByAdmin\": false, \"name\": \"Amazon\", \"slug\": \"amazon\", \"timesEncountered\": 8}], \"2\": [{\"taggedByAdmin\": false, \"name\": \"Google\", \"slug\": \"google\", \"timesEncountered\": 2}]}",
  "codeSnippets": [
    {
      "lang": "C++",
      "code": "class Solution {\npublic:\n    int uniquePathsIII(vector<vector<int>>& grid) {\n        \n    }\n};"
    },
    {
      "lang": "Java",
      "code": "class Solution {\n    public int uniquePathsIII(int[][] grid) {\n        \n    }\n}"
    },
    {
      "lang": "Python",
      "code": "class Solution(object):\n    def uniquePathsIII(self, grid):\n        \"\"\"\n        :type grid: List[List[int]]\n        :rtype: int\n        \"\"\"\n        "
    },
    {
      "lang": "Python3",
      "code": "class Solution:\n    def uniquePathsIII(self, grid: List[List[int]]) -> int:\n        "
    },
    {
      "lang": "C",
      "code": "\n\nint uniquePathsIII(int** grid, int gridSize, int* gridColSize){\n\n}\n\n"
    },
    {
      "lang": "C#",
      "code": "public class Solution {\n    public int UniquePathsIII(int[][] grid) {\n        \n    }\n}"
    },
    {
      "lang": "JavaScript",
      "code": "/**\n * @param {number[][]} grid\n * @return {number}\n */\nvar uniquePathsIII = function(grid) {\n    \n};"
    },
    {
      "lang": "Ruby",
      "code": "# @param {Integer[][]} grid\n# @return {Integer}\ndef unique_paths_iii(grid)\n    \nend"
    },
    {
      "lang": "Swift",
      "code": "class Solution {\n    func uniquePathsIII(_ grid: [[Int]]) -> Int {\n        \n    }\n}"
    },
    {
      "lang": "Go",
      "code": "func uniquePathsIII(grid [][]int) int {\n    \n}"
    },
    {
      "lang": "Scala",
      "code": "object Solution {\n    def uniquePathsIII(grid: Array[Array[Int]]): Int = {\n        \n    }\n}"
    },
    {
      "lang": "Kotlin",
      "code": "class Solution {\n    fun uniquePathsIII(grid: Array<IntArray>): Int {\n        \n    }\n}"
    },
    {
      "lang": "Rust",
      "code": "impl Solution {\n    pub fn unique_paths_iii(grid: Vec<Vec<i32>>) -> i32 {\n        \n    }\n}"
    },
    {
      "lang": "PHP",
      "code": "class Solution {\n\n    /**\n     * @param Integer[][] $grid\n     * @return Integer\n     */\n    function uniquePathsIII($grid) {\n        \n    }\n}"
    }
  ],
  "stats": "{\"totalAccepted\": \"20.7K\", \"totalSubmission\": \"28.8K\", \"totalAcceptedRaw\": 20715, \"totalSubmissionRaw\": 28849, \"acRate\": \"71.8%\"}",
  "hints": [],
  "solution": {
    "id": "670",
    "canSeeDetail": true,
    "url": "/articles/unique-paths-iii/",
    "content": "[TOC]\n\n## Solution\n---\n#### Approach 1: Backtracking DFS\n\n**Intuition and Algorithm**\n\nLet's try walking to each `0`, leaving an obstacle behind from where we walked.  After, we can remove the obstacle.\n\nGiven the input limits, this can work because bad paths tend to get stuck quickly and run out of free squares.\n\n<iframe src=\"https://leetcode.com/playground/bfNeazhV/shared\" frameBorder=\"0\" width=\"100%\" height=\"500\" name=\"bfNeazhV\"></iframe>\n\n**Complexity Analysis**\n\n* Time Complexity:  $$O(4^{R*C})$$, where $$R, C$$ are the number of rows and columns in the grid.  (We can find tighter bounds, but such a bound is beyond the scope of this article.)\n\n* Space Complexity:  $$O(R*C)$$.\n<br />\n<br />\n\n\n---\n#### Approach 2: Dynamic Programming\n\n**Intuition and Algorithm**\n\nLet `dp(r, c, todo)` be the number of paths starting from where we are (`r, c`), and given that `todo` is the set of empty squares we've yet to walk on.\n\nWe can use a similar approach to *Approach 1*, except we will memoize these states `(r, c, todo)` so as not to repeat work.\n\n<iframe src=\"https://leetcode.com/playground/KxYhLJfP/shared\" frameBorder=\"0\" width=\"100%\" height=\"500\" name=\"KxYhLJfP\"></iframe>\n\n**Complexity Analysis**\n\n* Time Complexity:  $$O(R * C * 2^{R*C})$$, where $$R, C$$ are the number of rows and columns in the grid.\n\n* Space Complexity:  $$O(R * C)$$.\n<br />\n<br />\n\n\n---\nAnalysis written by: [@awice](https://leetcode.com/awice).",
    "contentTypeId": "107",
    "rating": {
      "id": "656",
      "count": 44,
      "average": 2.454,
      "userRating": null
    }
  },
  "status": null,
  "sampleTestCase": "[[1,0,0,0],[0,0,0,0],[0,0,2,-1]]",
  "metaData": "{\r\n  \"name\": \"uniquePathsIII\",\r\n  \"params\": [\r\n    {\r\n      \"name\": \"grid\",\r\n      \"type\": \"integer[][]\"\r\n    }\r\n  ],\r\n  \"return\": {\r\n    \"type\": \"integer\"\r\n  }\r\n}\r\n",
  "judgerAvailable": true,
  "judgeType": "large",
  "mysqlSchemas": [],
  "enableRunCode": true,
  "enableTestMode": false,
  "libraryUrl": null
}
