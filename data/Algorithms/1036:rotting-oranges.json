{
  "questionId": "1036",
  "questionFrontendId": "994",
  "boundTopicId": null,
  "title": "Rotting Oranges",
  "titleSlug": "rotting-oranges",
  "categoryTitle": "Algorithms",
  "content": "<p>In a given grid, each cell can have one of three&nbsp;values:</p>\r\n\r\n<ul>\r\n\t<li>the value <code>0</code> representing an empty cell;</li>\r\n\t<li>the value <code>1</code> representing a fresh orange;</li>\r\n\t<li>the value <code>2</code> representing a rotten orange.</li>\r\n</ul>\r\n\r\n<p>Every minute, any fresh orange that is adjacent (4-directionally) to a rotten orange becomes rotten.</p>\r\n\r\n<p>Return the minimum number of minutes that must elapse until no cell has a fresh orange.&nbsp; If this is impossible, return <code>-1</code> instead.</p>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<div>\r\n<p><strong>Example 1:</strong></p>\r\n\r\n<p><strong><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2019/02/16/oranges.png\" style=\"width: 712px; height: 150px;\" /></strong></p>\r\n\r\n<pre>\r\n<strong>Input: </strong><span id=\"example-input-1-1\">[[2,1,1],[1,1,0],[0,1,1]]</span>\r\n<strong>Output: </strong><span id=\"example-output-1\">4</span>\r\n</pre>\r\n\r\n<div>\r\n<p><strong>Example 2:</strong></p>\r\n\r\n<pre>\r\n<strong>Input: </strong><span id=\"example-input-2-1\">[[2,1,1],[0,1,1],[1,0,1]]</span>\r\n<strong>Output: </strong><span id=\"example-output-2\">-1</span>\r\n<strong>Explanation: </strong> The orange in the bottom left corner (row 2, column 0) is never rotten, because rotting only happens 4-directionally.\r\n</pre>\r\n\r\n<div>\r\n<p><strong>Example 3:</strong></p>\r\n\r\n<pre>\r\n<strong>Input: </strong><span id=\"example-input-3-1\">[[0,2]]</span>\r\n<strong>Output: </strong><span id=\"example-output-3\">0</span>\r\n<strong>Explanation: </strong> Since there are already no fresh oranges at minute 0, the answer is just 0.\r\n</pre>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p><strong>Note:</strong></p>\r\n\r\n<ol>\r\n\t<li><code>1 &lt;= grid.length &lt;= 10</code></li>\r\n\t<li><code>1 &lt;= grid[0].length &lt;= 10</code></li>\r\n\t<li><code>grid[i][j]</code> is only <code>0</code>, <code>1</code>, or <code>2</code>.</li>\r\n</ol>\r\n</div>\r\n</div>\r\n</div>",
  "isPaidOnly": false,
  "difficulty": "Easy",
  "likes": 604,
  "dislikes": 61,
  "isLiked": null,
  "similarQuestions": "[{\"title\": \"Walls and Gates\", \"titleSlug\": \"walls-and-gates\", \"difficulty\": \"Medium\", \"translatedTitle\": null}]",
  "contributors": [
    {
      "username": "DevendraBahirat",
      "profileUrl": "/devendrabahirat/",
      "avatarUrl": "https://www.gravatar.com/avatar/99d9a9bf67fac83cf4f4ffd2a4bbc3a1.png?s=200"
    }
  ],
  "topicTags": [
    {
      "name": "Breadth-first Search",
      "slug": "breadth-first-search"
    }
  ],
  "companyTagStats": "{\"1\": [{\"taggedByAdmin\": true, \"name\": \"Amazon\", \"slug\": \"amazon\", \"timesEncountered\": 42}], \"2\": [], \"3\": []}",
  "codeSnippets": [
    {
      "lang": "C++",
      "code": "class Solution {\npublic:\n    int orangesRotting(vector<vector<int>>& grid) {\n        \n    }\n};"
    },
    {
      "lang": "Java",
      "code": "class Solution {\n    public int orangesRotting(int[][] grid) {\n        \n    }\n}"
    },
    {
      "lang": "Python",
      "code": "class Solution(object):\n    def orangesRotting(self, grid):\n        \"\"\"\n        :type grid: List[List[int]]\n        :rtype: int\n        \"\"\"\n        "
    },
    {
      "lang": "Python3",
      "code": "class Solution:\n    def orangesRotting(self, grid: List[List[int]]) -> int:\n        "
    },
    {
      "lang": "C",
      "code": "\n\nint orangesRotting(int** grid, int gridSize, int* gridColSize){\n\n}\n\n"
    },
    {
      "lang": "C#",
      "code": "public class Solution {\n    public int OrangesRotting(int[][] grid) {\n        \n    }\n}"
    },
    {
      "lang": "JavaScript",
      "code": "/**\n * @param {number[][]} grid\n * @return {number}\n */\nvar orangesRotting = function(grid) {\n    \n};"
    },
    {
      "lang": "Ruby",
      "code": "# @param {Integer[][]} grid\n# @return {Integer}\ndef oranges_rotting(grid)\n    \nend"
    },
    {
      "lang": "Swift",
      "code": "class Solution {\n    func orangesRotting(_ grid: [[Int]]) -> Int {\n        \n    }\n}"
    },
    {
      "lang": "Go",
      "code": "func orangesRotting(grid [][]int) int {\n    \n}"
    },
    {
      "lang": "Scala",
      "code": "object Solution {\n    def orangesRotting(grid: Array[Array[Int]]): Int = {\n        \n    }\n}"
    },
    {
      "lang": "Kotlin",
      "code": "class Solution {\n    fun orangesRotting(grid: Array<IntArray>): Int {\n        \n    }\n}"
    },
    {
      "lang": "Rust",
      "code": "impl Solution {\n    pub fn oranges_rotting(grid: Vec<Vec<i32>>) -> i32 {\n        \n    }\n}"
    },
    {
      "lang": "PHP",
      "code": "class Solution {\n\n    /**\n     * @param Integer[][] $grid\n     * @return Integer\n     */\n    function orangesRotting($grid) {\n        \n    }\n}"
    }
  ],
  "stats": "{\"totalAccepted\": \"33.3K\", \"totalSubmission\": \"71.5K\", \"totalAcceptedRaw\": 33304, \"totalSubmissionRaw\": 71486, \"acRate\": \"46.6%\"}",
  "hints": [],
  "solution": {
    "id": "696",
    "canSeeDetail": true,
    "url": "/articles/rotting-oranges/",
    "content": "[TOC]\n\n## Solution\n---\n#### Approach 1: Breadth-First Search\n\n**Intuition**\n\nEvery turn, the rotting spreads from each rotting orange to other adjacent oranges.  Initially, the rotten oranges have 'depth' 0 [as in the spanning tree of a graph], and every time they rot a neighbor, the neighbors have 1 more depth.  We want to know the largest possible depth.\n\n**Algorithm**\n\nWe can use a breadth-first search to model this process.  Because we always explore nodes (oranges) with the smallest depth first, we're guaranteed that each orange that becomes rotten does so with the lowest possible depth number.\n\nWe should also check that at the end, there are no fresh oranges left.\n\n<iframe src=\"https://leetcode.com/playground/8S5VkeTc/shared\" frameBorder=\"0\" width=\"100%\" height=\"500\" name=\"8S5VkeTc\"></iframe>\n\n**Complexity Analysis**\n\n* Time Complexity:  $$O(N)$$, where $$N$$ is the number of cells in the grid.\n\n* Space Complexity:  $$O(N)$$.\n<br />\n<br />\n\n\n---\nAnalysis written by: [@awice](https://leetcode.com/awice).",
    "contentTypeId": "107",
    "rating": {
      "id": "681",
      "count": 33,
      "average": 4.03,
      "userRating": null
    }
  },
  "status": null,
  "sampleTestCase": "[[2,1,1],[1,1,0],[0,1,1]]",
  "metaData": "{\r\n  \"name\": \"orangesRotting\",\r\n  \"params\": [\r\n    {\r\n      \"name\": \"grid\",\r\n      \"type\": \"integer[][]\"\r\n    }\r\n  ],\r\n  \"return\": {\r\n    \"type\": \"integer\"\r\n  }\r\n}\r\n",
  "judgerAvailable": true,
  "judgeType": "large",
  "mysqlSchemas": [],
  "enableRunCode": true,
  "enableTestMode": false,
  "libraryUrl": null
}
