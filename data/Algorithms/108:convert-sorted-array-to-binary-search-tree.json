{
  "questionId": "108",
  "questionFrontendId": "108",
  "boundTopicId": null,
  "title": "Convert Sorted Array to Binary Search Tree",
  "titleSlug": "convert-sorted-array-to-binary-search-tree",
  "categoryTitle": "Algorithms",
  "content": "<p>Given an array where elements are sorted in ascending order, convert it to a height balanced BST.</p>\r\n\r\n<p>For this problem, a height-balanced binary tree is defined as a binary tree in which the depth of the two subtrees of <em>every</em> node never differ by more than 1.</p>\r\n\r\n<p><strong>Example:</strong></p>\r\n\r\n<pre>\r\nGiven the sorted array: [-10,-3,0,5,9],\r\n\r\nOne possible answer is: [0,-3,9,-10,null,5], which represents the following height balanced BST:\r\n\r\n      0\r\n     / \\\r\n   -3   9\r\n   /   /\r\n -10  5\r\n</pre>\r\n",
  "isPaidOnly": false,
  "difficulty": "Easy",
  "likes": 1641,
  "dislikes": 163,
  "isLiked": null,
  "similarQuestions": "[{\"title\": \"Convert Sorted List to Binary Search Tree\", \"titleSlug\": \"convert-sorted-list-to-binary-search-tree\", \"difficulty\": \"Medium\", \"translatedTitle\": null}]",
  "contributors": [],
  "topicTags": [
    {
      "name": "Tree",
      "slug": "tree"
    },
    {
      "name": "Depth-first Search",
      "slug": "depth-first-search"
    }
  ],
  "companyTagStats": "{\"2\": [{\"taggedByAdmin\": false, \"name\": \"Microsoft\", \"slug\": \"microsoft\", \"timesEncountered\": 4}, {\"taggedByAdmin\": false, \"name\": \"Google\", \"slug\": \"google\", \"timesEncountered\": 3}, {\"taggedByAdmin\": false, \"name\": \"Bloomberg\", \"slug\": \"bloomberg\", \"timesEncountered\": 2}, {\"taggedByAdmin\": false, \"name\": \"Yahoo\", \"slug\": \"yahoo\", \"timesEncountered\": 2}], \"1\": [{\"taggedByAdmin\": false, \"name\": \"Amazon\", \"slug\": \"amazon\", \"timesEncountered\": 3}], \"3\": [{\"taggedByAdmin\": false, \"name\": \"Facebook\", \"slug\": \"facebook\", \"timesEncountered\": 2}, {\"taggedByAdmin\": true, \"name\": \"Airbnb\", \"slug\": \"airbnb\", \"timesEncountered\": 0}]}",
  "codeSnippets": [
    {
      "lang": "C++",
      "code": "/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\n * };\n */\nclass Solution {\npublic:\n    TreeNode* sortedArrayToBST(vector<int>& nums) {\n        \n    }\n};"
    },
    {
      "lang": "Java",
      "code": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode(int x) { val = x; }\n * }\n */\nclass Solution {\n    public TreeNode sortedArrayToBST(int[] nums) {\n        \n    }\n}"
    },
    {
      "lang": "Python",
      "code": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, x):\n#         self.val = x\n#         self.left = None\n#         self.right = None\n\nclass Solution(object):\n    def sortedArrayToBST(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: TreeNode\n        \"\"\"\n        "
    },
    {
      "lang": "Python3",
      "code": "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, x):\n#         self.val = x\n#         self.left = None\n#         self.right = None\n\nclass Solution:\n    def sortedArrayToBST(self, nums: List[int]) -> TreeNode:\n        "
    },
    {
      "lang": "C",
      "code": "/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     struct TreeNode *left;\n *     struct TreeNode *right;\n * };\n */\n\n\nstruct TreeNode* sortedArrayToBST(int* nums, int numsSize){\n\n}\n\n"
    },
    {
      "lang": "C#",
      "code": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     public int val;\n *     public TreeNode left;\n *     public TreeNode right;\n *     public TreeNode(int x) { val = x; }\n * }\n */\npublic class Solution {\n    public TreeNode SortedArrayToBST(int[] nums) {\n        \n    }\n}"
    },
    {
      "lang": "JavaScript",
      "code": "/**\n * Definition for a binary tree node.\n * function TreeNode(val) {\n *     this.val = val;\n *     this.left = this.right = null;\n * }\n */\n/**\n * @param {number[]} nums\n * @return {TreeNode}\n */\nvar sortedArrayToBST = function(nums) {\n    \n};"
    },
    {
      "lang": "Ruby",
      "code": "# Definition for a binary tree node.\n# class TreeNode\n#     attr_accessor :val, :left, :right\n#     def initialize(val)\n#         @val = val\n#         @left, @right = nil, nil\n#     end\n# end\n\n# @param {Integer[]} nums\n# @return {TreeNode}\ndef sorted_array_to_bst(nums)\n    \nend"
    },
    {
      "lang": "Swift",
      "code": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     public var val: Int\n *     public var left: TreeNode?\n *     public var right: TreeNode?\n *     public init(_ val: Int) {\n *         self.val = val\n *         self.left = nil\n *         self.right = nil\n *     }\n * }\n */\nclass Solution {\n    func sortedArrayToBST(_ nums: [Int]) -> TreeNode? {\n        \n    }\n}"
    },
    {
      "lang": "Go",
      "code": "/**\n * Definition for a binary tree node.\n * type TreeNode struct {\n *     Val int\n *     Left *TreeNode\n *     Right *TreeNode\n * }\n */\nfunc sortedArrayToBST(nums []int) *TreeNode {\n    \n}"
    },
    {
      "lang": "Scala",
      "code": "/**\n * Definition for a binary tree node.\n * class TreeNode(var _value: Int) {\n *   var value: Int = _value\n *   var left: TreeNode = null\n *   var right: TreeNode = null\n * }\n */\nobject Solution {\n    def sortedArrayToBST(nums: Array[Int]): TreeNode = {\n        \n    }\n}"
    },
    {
      "lang": "Kotlin",
      "code": "/**\n * Example:\n * var ti = TreeNode(5)\n * var v = ti.`val`\n * Definition for a binary tree node.\n * class TreeNode(var `val`: Int) {\n *     var left: TreeNode? = null\n *     var right: TreeNode? = null\n * }\n */\nclass Solution {\n    fun sortedArrayToBST(nums: IntArray): TreeNode? {\n        \n    }\n}"
    },
    {
      "lang": "Rust",
      "code": "// Definition for a binary tree node.\n// #[derive(Debug, PartialEq, Eq)]\n// pub struct TreeNode {\n//   pub val: i32,\n//   pub left: Option<Rc<RefCell<TreeNode>>>,\n//   pub right: Option<Rc<RefCell<TreeNode>>>,\n// }\n// \n// impl TreeNode {\n//   #[inline]\n//   pub fn new(val: i32) -> Self {\n//     TreeNode {\n//       val,\n//       left: None,\n//       right: None\n//     }\n//   }\n// }\nuse std::rc::Rc;\nuse std::cell::RefCell;\nimpl Solution {\n    pub fn sorted_array_to_bst(nums: Vec<i32>) -> Option<Rc<RefCell<TreeNode>>> {\n        \n    }\n}"
    },
    {
      "lang": "PHP",
      "code": "/**\n * Definition for a binary tree node.\n * class TreeNode {\n *     public $val = null;\n *     public $left = null;\n *     public $right = null;\n *     function __construct($value) { $this->val = $value; }\n * }\n */\nclass Solution {\n\n    /**\n     * @param Integer[] $nums\n     * @return TreeNode\n     */\n    function sortedArrayToBST($nums) {\n        \n    }\n}"
    }
  ],
  "stats": "{\"totalAccepted\": \"326K\", \"totalSubmission\": \"602.9K\", \"totalAcceptedRaw\": 325976, \"totalSubmissionRaw\": 602899, \"acRate\": \"54.1%\"}",
  "hints": [],
  "solution": {
    "id": "815",
    "canSeeDetail": true,
    "url": "/articles/convert-sorted-array-to-bst/",
    "content": "[TOC]\r\n\r\n## Solution\r\n\r\n--- \r\n\r\n#### How to Traverse the Tree. DFS: Preorder, Inorder, Postorder; BFS.\r\n\r\nThere are two general strategies to traverse a tree:\r\n     \r\n- *Depth First Search* (`DFS`)\r\n\r\n    In this strategy, we adopt the `depth` as the priority, so that one\r\n    would start from a root and reach all the way down to certain leaf,\r\n    and then back to root to reach another branch.\r\n\r\n    The DFS strategy can further be distinguished as\r\n    `preorder`, `inorder`, and `postorder` depending on the relative order\r\n    among the root node, left node and right node.\r\n    \r\n- *Breadth First Search* (`BFS`)\r\n\r\n    We scan through the tree level by level, following the order of height,\r\n    from top to bottom. The nodes on higher level would be visited before\r\n    the ones with lower levels.\r\n    \r\nOn the following figure the nodes are enumerated in the order you visit them,\r\nplease follow `1-2-3-4-5` to compare different strategies.\r\n\r\n![postorder](../Figures/108/bfs_dfs.png)\r\n<br /> \r\n<br />\r\n\r\n\r\n---\r\n#### Construct BST from Inorder Traversal: Why the Solution is _Not_ Unique \r\n\r\nIt's known that [inorder traversal of BST is an array sorted in\r\nthe ascending order](https://leetcode.com/articles/delete-node-in-a-bst/).\r\n\r\nHaving sorted array as an input, we could rewrite the problem as\r\n_Construct Binary Search Tree from Inorder Traversal_.\r\n\r\n> Does this problem have a unique solution, i.e. could inorder traversal \r\nbe used as a unique identifier to encore/decode BST? The answer is _no_. \r\n\r\nHere is the funny thing about BST. \r\nInorder traversal is _not_ a unique identifier of BST.\r\nAt the same time both preorder and postorder traversals \r\n_are_ unique identifiers of BST. [From these traversals \r\none could restore the inorder one](https://leetcode.com/articles/construct-bst-from-preorder-traversal/): \r\n`inorder = sorted(postorder) = sorted(preorder)`, \r\nand [inorder + postorder or inorder + preorder \r\nare both unique identifiers of whatever binary tree](https://leetcode.com/articles/construct-binary-tree-from-inorder-and-postorder-t/).\r\n\r\nSo, the problem \"sorted array -> BST\" has multiple solutions.\r\n\r\n![postorder](../Figures/108/bst2.png)\r\n\r\nHere we have an additional condition: _the tree should be height-balanced_, i.e.\r\nthe depths of the two subtrees of every node never differ by more than 1. \r\n\r\n> Does it make the solution to be unique? Still no.\r\n\r\n![postorder](../Figures/108/height.png)\r\n\r\nBasically, the height-balanced restriction means that at each step one has to \r\npick up the number in the middle as a root. \r\nThat works fine with arrays containing odd number of elements but \r\nthere is no predefined choice for arrays with even number of elements.\r\n\r\n![postorder](../Figures/108/pick.png)\r\n\r\nOne could choose left middle element, or right middle one, and both choices will\r\nlead to _different_ height-balanced BSTs. Let's see that in practice: \r\nin Approach 1 we will always pick up left middle element, \r\nin Approach 2 - right middle one. \r\nThat will generate _different_ BSTs but both solutions will be accepted.\r\n<br /> \r\n<br />\r\n\r\n\r\n---\r\n#### Approach 1: Inorder Traversal: Always Choose Left Middle Node as a Root\r\n\r\n**Algorithm**\r\n\r\n![postorder](../Figures/108/left.png)\r\n\r\n- Implement helper function `helper(left, right)`, \r\nwhich constructs BST from nums elements between indexes `left` and `right`:\r\n\r\n    - If left > right, then there is no elements available for that subtree.\r\n    Return None.\r\n    \r\n    - Pick left middle element: `p = (left + right) // 2`.\r\n    \r\n    - Initiate the root: `root = TreeNode(nums[p])`. \r\n    \r\n    - Compute recursively left and right subtrees:\r\n    `root.left = helper(left, p - 1)`, `root.right = helper(p + 1, right)`.\r\n    \r\n- Return `helper(0, len(nums) - 1)`.  \r\n\r\n**Implementation**\r\n\r\n<iframe src=\"https://leetcode.com/playground/KDzigPDd/shared\" frameBorder=\"0\" width=\"100%\" height=\"412\" name=\"KDzigPDd\"></iframe>\r\n\r\n**Complexity Analysis**\r\n\r\n* Time complexity: $$\\mathcal{O}(N)$$ since we visit each node exactly once.\r\n\r\n* Space complexity: $$\\mathcal{O}(N)$$. \r\n$$\\mathcal{O}(N)$$ to keep the output, and $$\\mathcal{O}(\\log N)$$ for the recursion\r\nstack. \r\n<br /> \r\n<br />\r\n\r\n\r\n---\r\n#### Approach 2: Inorder Traversal: Always Choose Right Middle Node as a Root\r\n\r\n**Algorithm**\r\n\r\n![postorder](../Figures/108/right.png)\r\n\r\n- Implement helper function `helper(left, right)`, \r\nwhich constructs BST from nums elements between indexes `left` and `right`:\r\n\r\n    - If left > right, then there is no elements available for that subtree.\r\n    Return None.\r\n    \r\n    - Pick right middle element: \r\n        \r\n        - `p = (left + right) // 2`.\r\n    \r\n        - If `left + right` is odd, add 1 to p-index.\r\n    \r\n    - Initiate the root: `root = TreeNode(nums[p])`. \r\n    \r\n    - Compute recursively left and right subtrees:\r\n    `root.left = helper(left, p - 1)`, `root.right = helper(p + 1, right)`.\r\n    \r\n- Return `helper(0, len(nums) - 1)`. \r\n\r\n**Implementation**\r\n\r\n<iframe src=\"https://leetcode.com/playground/4iXwruvN/shared\" frameBorder=\"0\" width=\"100%\" height=\"429\" name=\"4iXwruvN\"></iframe>\r\n\r\n**Complexity Analysis**\r\n\r\n* Time complexity: $$\\mathcal{O}(N)$$ since we visit each node exactly once.\r\n\r\n* Space complexity: $$\\mathcal{O}(N)$$. \r\n$$\\mathcal{O}(N)$$ to keep the output, and $$\\mathcal{O}(\\log N)$$ for the recursion\r\nstack. \r\n<br /> \r\n<br />\r\n\r\n\r\n---\r\n#### Approach 3: Inorder Traversal: Choose Random Middle Node as a Root\r\n\r\nThis one is for fun. Instead of predefined choice we will pick \r\nrandomly left or right middle node at each step. Each run will result in \r\ndifferent solution and they all will be accepted. \r\n\r\n![postorder](../Figures/108/random.png)\r\n\r\n**Algorithm**\r\n\r\n- Implement helper function `helper(left, right)`, \r\nwhich constructs BST from nums elements between indexes `left` and `right`:\r\n\r\n    - If left > right, then there is no elements available for that subtree.\r\n    Return None.\r\n    \r\n    - Pick random middle element: \r\n        \r\n        - `p = (left + right) // 2`.\r\n    \r\n        - If `left + right` is odd, add randomly 0 or 1 to p-index.\r\n    \r\n    - Initiate the root: `root = TreeNode(nums[p])`. \r\n    \r\n    - Compute recursively left and right subtrees:\r\n    `root.left = helper(left, p - 1)`, `root.right = helper(p + 1, right)`.\r\n    \r\n- Return `helper(0, len(nums) - 1)`. \r\n\r\n**Implementation**\r\n\r\n<iframe src=\"https://leetcode.com/playground/sKR7fp7k/shared\" frameBorder=\"0\" width=\"100%\" height=\"446\" name=\"sKR7fp7k\"></iframe>\r\n\r\n**Complexity Analysis**\r\n\r\n* Time complexity: $$\\mathcal{O}(N)$$ since we visit each node exactly once.\r\n\r\n* Space complexity: $$\\mathcal{O}(N)$$. \r\n$$\\mathcal{O}(N)$$ to keep the output, and $$\\mathcal{O}(\\log N)$$ for the recursion\r\nstack. \r\n\r\n\r\nAnalysis written by @[liaison](https://leetcode.com/liaison/)\r\nand @[andvary](https://leetcode.com/andvary/)",
    "contentTypeId": "107",
    "rating": {
      "id": "782",
      "count": 16,
      "average": 4.812,
      "userRating": null
    }
  },
  "status": null,
  "sampleTestCase": "[-10,-3,0,5,9]",
  "metaData": "{\r\n  \"name\": \"sortedArrayToBST\",\r\n  \"params\": [\r\n    {\r\n      \"name\": \"nums\",\r\n      \"type\": \"integer[]\"\r\n    }\r\n  ],\r\n  \"return\": {\r\n    \"type\": \"TreeNode\",\r\n    \"dealloc\": true\r\n  }\r\n}",
  "judgerAvailable": true,
  "judgeType": "large",
  "mysqlSchemas": [],
  "enableRunCode": true,
  "enableTestMode": false,
  "libraryUrl": null
}
