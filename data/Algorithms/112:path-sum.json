{
  "questionId": "112",
  "questionFrontendId": "112",
  "boundTopicId": null,
  "title": "Path Sum",
  "titleSlug": "path-sum",
  "categoryTitle": "Algorithms",
  "content": "<p>Given a binary tree and a sum, determine if the tree has a root-to-leaf path such that adding up all the values along the path equals the given sum.</p>\r\n\r\n<p><strong>Note:</strong>&nbsp;A leaf is a node with no children.</p>\r\n\r\n<p><strong>Example:</strong></p>\r\n\r\n<p>Given the below binary tree and <code>sum = 22</code>,</p>\r\n\r\n<pre>\r\n      <strong>5</strong>\r\n     <strong>/</strong> \\\r\n    <strong>4</strong>   8\r\n   <strong>/</strong>   / \\\r\n  <strong>11</strong>  13  4\r\n /  <strong>\\</strong>      \\\r\n7    <strong>2</strong>      1\r\n</pre>\r\n\r\n<p>return true, as there exist a root-to-leaf path <code>5-&gt;4-&gt;11-&gt;2</code> which sum is 22.</p>\r\n",
  "isPaidOnly": false,
  "difficulty": "Easy",
  "likes": 1299,
  "dislikes": 402,
  "isLiked": null,
  "similarQuestions": "[{\"title\": \"Path Sum II\", \"titleSlug\": \"path-sum-ii\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Binary Tree Maximum Path Sum\", \"titleSlug\": \"binary-tree-maximum-path-sum\", \"difficulty\": \"Hard\", \"translatedTitle\": null}, {\"title\": \"Sum Root to Leaf Numbers\", \"titleSlug\": \"sum-root-to-leaf-numbers\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Path Sum III\", \"titleSlug\": \"path-sum-iii\", \"difficulty\": \"Easy\", \"translatedTitle\": null}, {\"title\": \"Path Sum IV\", \"titleSlug\": \"path-sum-iv\", \"difficulty\": \"Medium\", \"translatedTitle\": null}]",
  "contributors": [],
  "topicTags": [
    {
      "name": "Tree",
      "slug": "tree"
    },
    {
      "name": "Depth-first Search",
      "slug": "depth-first-search"
    }
  ],
  "companyTagStats": "{\"1\": [{\"taggedByAdmin\": false, \"name\": \"Facebook\", \"slug\": \"facebook\", \"timesEncountered\": 5}, {\"taggedByAdmin\": false, \"name\": \"Amazon\", \"slug\": \"amazon\", \"timesEncountered\": 4}], \"2\": [{\"taggedByAdmin\": true, \"name\": \"Microsoft\", \"slug\": \"microsoft\", \"timesEncountered\": 2}, {\"taggedByAdmin\": false, \"name\": \"Apple\", \"slug\": \"apple\", \"timesEncountered\": 2}, {\"taggedByAdmin\": false, \"name\": \"Adobe\", \"slug\": \"adobe\", \"timesEncountered\": 2}], \"3\": [{\"taggedByAdmin\": false, \"name\": \"Zillow\", \"slug\": \"zillow\", \"timesEncountered\": 4}, {\"taggedByAdmin\": false, \"name\": \"Yahoo\", \"slug\": \"yahoo\", \"timesEncountered\": 2}]}",
  "codeSnippets": [
    {
      "lang": "C++",
      "code": "/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\n * };\n */\nclass Solution {\npublic:\n    bool hasPathSum(TreeNode* root, int sum) {\n        \n    }\n};"
    },
    {
      "lang": "Java",
      "code": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode(int x) { val = x; }\n * }\n */\nclass Solution {\n    public boolean hasPathSum(TreeNode root, int sum) {\n        \n    }\n}"
    },
    {
      "lang": "Python",
      "code": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, x):\n#         self.val = x\n#         self.left = None\n#         self.right = None\n\nclass Solution(object):\n    def hasPathSum(self, root, sum):\n        \"\"\"\n        :type root: TreeNode\n        :type sum: int\n        :rtype: bool\n        \"\"\"\n        "
    },
    {
      "lang": "Python3",
      "code": "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, x):\n#         self.val = x\n#         self.left = None\n#         self.right = None\n\nclass Solution:\n    def hasPathSum(self, root: TreeNode, sum: int) -> bool:\n        "
    },
    {
      "lang": "C",
      "code": "/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     struct TreeNode *left;\n *     struct TreeNode *right;\n * };\n */\n\n\nbool hasPathSum(struct TreeNode* root, int sum){\n\n}\n\n"
    },
    {
      "lang": "C#",
      "code": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     public int val;\n *     public TreeNode left;\n *     public TreeNode right;\n *     public TreeNode(int x) { val = x; }\n * }\n */\npublic class Solution {\n    public bool HasPathSum(TreeNode root, int sum) {\n        \n    }\n}"
    },
    {
      "lang": "JavaScript",
      "code": "/**\n * Definition for a binary tree node.\n * function TreeNode(val) {\n *     this.val = val;\n *     this.left = this.right = null;\n * }\n */\n/**\n * @param {TreeNode} root\n * @param {number} sum\n * @return {boolean}\n */\nvar hasPathSum = function(root, sum) {\n    \n};"
    },
    {
      "lang": "Ruby",
      "code": "# Definition for a binary tree node.\n# class TreeNode\n#     attr_accessor :val, :left, :right\n#     def initialize(val)\n#         @val = val\n#         @left, @right = nil, nil\n#     end\n# end\n\n# @param {TreeNode} root\n# @param {Integer} sum\n# @return {Boolean}\ndef has_path_sum(root, sum)\n    \nend"
    },
    {
      "lang": "Swift",
      "code": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     public var val: Int\n *     public var left: TreeNode?\n *     public var right: TreeNode?\n *     public init(_ val: Int) {\n *         self.val = val\n *         self.left = nil\n *         self.right = nil\n *     }\n * }\n */\nclass Solution {\n    func hasPathSum(_ root: TreeNode?, _ sum: Int) -> Bool {\n        \n    }\n}"
    },
    {
      "lang": "Go",
      "code": "/**\n * Definition for a binary tree node.\n * type TreeNode struct {\n *     Val int\n *     Left *TreeNode\n *     Right *TreeNode\n * }\n */\nfunc hasPathSum(root *TreeNode, sum int) bool {\n    \n}"
    },
    {
      "lang": "Scala",
      "code": "/**\n * Definition for a binary tree node.\n * class TreeNode(var _value: Int) {\n *   var value: Int = _value\n *   var left: TreeNode = null\n *   var right: TreeNode = null\n * }\n */\nobject Solution {\n    def hasPathSum(root: TreeNode, sum: Int): Boolean = {\n        \n    }\n}"
    },
    {
      "lang": "Kotlin",
      "code": "/**\n * Example:\n * var ti = TreeNode(5)\n * var v = ti.`val`\n * Definition for a binary tree node.\n * class TreeNode(var `val`: Int) {\n *     var left: TreeNode? = null\n *     var right: TreeNode? = null\n * }\n */\nclass Solution {\n    fun hasPathSum(root: TreeNode?, sum: Int): Boolean {\n        \n    }\n}"
    },
    {
      "lang": "Rust",
      "code": "// Definition for a binary tree node.\n// #[derive(Debug, PartialEq, Eq)]\n// pub struct TreeNode {\n//   pub val: i32,\n//   pub left: Option<Rc<RefCell<TreeNode>>>,\n//   pub right: Option<Rc<RefCell<TreeNode>>>,\n// }\n// \n// impl TreeNode {\n//   #[inline]\n//   pub fn new(val: i32) -> Self {\n//     TreeNode {\n//       val,\n//       left: None,\n//       right: None\n//     }\n//   }\n// }\nuse std::rc::Rc;\nuse std::cell::RefCell;\nimpl Solution {\n    pub fn has_path_sum(root: Option<Rc<RefCell<TreeNode>>>, sum: i32) -> bool {\n        \n    }\n}"
    },
    {
      "lang": "PHP",
      "code": "/**\n * Definition for a binary tree node.\n * class TreeNode {\n *     public $val = null;\n *     public $left = null;\n *     public $right = null;\n *     function __construct($value) { $this->val = $value; }\n * }\n */\nclass Solution {\n\n    /**\n     * @param TreeNode $root\n     * @param Integer $sum\n     * @return Boolean\n     */\n    function hasPathSum($root, $sum) {\n        \n    }\n}"
    }
  ],
  "stats": "{\"totalAccepted\": \"385K\", \"totalSubmission\": \"977.2K\", \"totalAcceptedRaw\": 384957, \"totalSubmissionRaw\": 977193, \"acRate\": \"39.4%\"}",
  "hints": [],
  "solution": {
    "id": "616",
    "canSeeDetail": true,
    "url": "/articles/path-sum/",
    "content": "[TOC]\r\n\r\n## Solution\r\n\r\n---\r\n\r\n#### Binary tree definition\r\n\r\nFirst of all, here is the definition of the ```TreeNode``` which we would use\r\nin the following implementation.\r\n\r\n<iframe src=\"https://leetcode.com/playground/tUX4pA6z/shared\" frameBorder=\"0\" width=\"100%\" height=\"225\" name=\"tUX4pA6z\"></iframe>\r\n<br />\r\n<br />\r\n\r\n\r\n---\r\n#### Approach 1: Recursion\r\n\r\nThe most intuitive way is to use a recursion here.\r\nOne is going through the tree \r\nby considering at each step the node itself and its children.\r\nIf node *is not* a leaf, one calls recursively `hasPathSum` method \r\nfor its children with a sum decreased by the current node value.\r\nIf node *is* a leaf, one checks if the the current sum is zero, *i.e* \r\nif the initial sum was discovered.\r\n\r\n<iframe src=\"https://leetcode.com/playground/Y9wProSS/shared\" frameBorder=\"0\" width=\"100%\" height=\"293\" name=\"Y9wProSS\"></iframe>\r\n\r\n**Complexity Analysis**\r\n\r\n* Time complexity : we visit each node exactly once, \r\nthus the time complexity is $$\\mathcal{O}(N)$$,\r\nwhere $$N$$ is the number of nodes.\r\n* Space complexity : in the worst case, the tree is completely unbalanced,\r\n*e.g.* each node has only one child node, the recursion call would occur\r\n $$N$$ times (the height of the tree), therefore the storage to keep the call stack would be $$\\mathcal{O}(N)$$.\r\n But in the best case (the tree is completely balanced), the height of the tree would be $$\\log(N)$$.\r\n Therefore, the space complexity in this case would be $$\\mathcal{O}(\\log(N))$$.\r\n<br />\r\n<br />\r\n\r\n\r\n---\r\n#### Approach 2: Iterations\r\n\r\n**Algorithm**\r\n\r\nWe could also convert the above recursion into iteration, \r\nwith the help of stack. DFS would be better than BFS here since \r\nit works faster except the worst case. In the worst case the path `root->leaf` \r\nwith the given sum is the last considered one and in this case DFS results in\r\nthe same productivity as BFS. \r\n\r\n>The idea is to visit each node with the DFS strategy,\r\nwhile updating the remaining sum to cumulate at each visit.\r\n\r\nSo we start from a stack which contains the root node and the corresponding \r\nremaining sum which is ```sum - root.val```.\r\nThen we proceed to the iterations: pop the current node out of the stack \r\nand return ```True``` if the remaining sum is `0` and we're on the leaf node.\r\nIf the remaining sum is not zero or we're not on the leaf yet \r\nthen we push the child nodes \r\nand corresponding remaining sums into stack.  \r\n\r\n<!--![LIS](../Figures/112/112_tr.gif)-->\r\n!?!../Documents/112_LIS.json:1000,543!?!\r\n\r\n<iframe src=\"https://leetcode.com/playground/P6zfFcYp/shared\" frameBorder=\"0\" width=\"100%\" height=\"500\" name=\"P6zfFcYp\"></iframe>\r\n\r\n**Complexity Analysis**\r\n\r\n* Time complexity : the same as the recursion approach $$\\mathcal{O}(N)$$.\r\n* Space complexity : $$\\mathcal{O}(N)$$ since in the worst case, when the tree is completely unbalanced,\r\n*e.g.* each node has only one child node, we would keep all $$N$$ nodes in the stack.\r\n But in the best case (the tree is balanced), the height of the tree would be $$\\log(N)$$.\r\n Therefore, the space complexity in this case would be $$\\mathcal{O}(\\log(N))$$.\r\n\r\nAnalysis written by @[liaison](https://leetcode.com/liaison/)\r\nand @[andvary](https://leetcode.com/andvary/)",
    "contentTypeId": "107",
    "rating": {
      "id": "602",
      "count": 14,
      "average": 4.714,
      "userRating": null
    }
  },
  "status": "ac",
  "sampleTestCase": "[5,4,8,11,null,13,4,7,2,null,null,null,1]\n22",
  "metaData": "{\r\n  \"name\": \"hasPathSum\",\r\n  \"params\": [\r\n    {\r\n      \"name\": \"root\",\r\n      \"type\": \"TreeNode\"\r\n    },\r\n    {\r\n      \"name\": \"sum\",\r\n      \"type\": \"integer\"\r\n    }\r\n  ],\r\n  \"return\": {\r\n    \"type\": \"boolean\"\r\n  }\r\n}",
  "judgerAvailable": true,
  "judgeType": "large",
  "mysqlSchemas": [],
  "enableRunCode": true,
  "enableTestMode": false,
  "libraryUrl": null
}
