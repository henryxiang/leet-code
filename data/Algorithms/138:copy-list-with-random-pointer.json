{
  "questionId": "138",
  "questionFrontendId": "138",
  "boundTopicId": null,
  "title": "Copy List with Random Pointer",
  "titleSlug": "copy-list-with-random-pointer",
  "categoryTitle": "Algorithms",
  "content": "<p>A linked list is given such that each node contains an additional random pointer which could point to any node in the list or null.</p>\n\n<p>Return a <a href=\"https://en.wikipedia.org/wiki/Object_copying#Deep_copy\" target=\"_blank\"><strong>deep copy</strong></a> of the list.</p>\n\n<p>The Linked List is represented in the input/output as a list of <code>n</code> nodes. Each node is represented as a pair of <code>[val, random_index]</code> where:</p>\n\n<ul>\n\t<li><code>val</code>: an integer representing <code>Node.val</code></li>\n\t<li><code>random_index</code>: the index of the node (range from <code>0</code> to <code>n-1</code>) where random pointer points to, or <code>null</code> if it does not point to any node.</li>\n</ul>\n\n<p>&nbsp;</p>\n<p><strong>Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2019/12/18/e1.png\" style=\"width: 700px; height: 142px;\" />\n<pre>\n<strong>Input:</strong> head = [[7,null],[13,0],[11,4],[10,2],[1,0]]\n<strong>Output:</strong> [[7,null],[13,0],[11,4],[10,2],[1,0]]\n</pre>\n\n<p><strong>Example 2:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2019/12/18/e2.png\" style=\"width: 700px; height: 114px;\" />\n<pre>\n<strong>Input:</strong> head = [[1,1],[2,1]]\n<strong>Output:</strong> [[1,1],[2,1]]\n</pre>\n\n<p><strong>Example 3:</strong></p>\n\n<p><strong><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2019/12/18/e3.png\" style=\"width: 700px; height: 122px;\" /></strong></p>\n\n<pre>\n<strong>Input:</strong> head = [[3,null],[3,0],[3,null]]\n<strong>Output:</strong> [[3,null],[3,0],[3,null]]\n</pre>\n\n<p><strong>Example 4:</strong></p>\n\n<pre>\n<strong>Input:</strong> head = []\n<strong>Output:</strong> []\n<strong>Explanation:</strong> Given linked list is empty (null pointer), so return null.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>-10000 &lt;= Node.val &lt;= 10000</code></li>\n\t<li><code>Node.random</code> is null or pointing to a node in the linked list.</li>\n\t<li>Number of Nodes will not exceed 1000.</li>\n</ul>\n",
  "isPaidOnly": false,
  "difficulty": "Medium",
  "likes": 2260,
  "dislikes": 551,
  "isLiked": null,
  "similarQuestions": "[{\"title\": \"Clone Graph\", \"titleSlug\": \"clone-graph\", \"difficulty\": \"Medium\", \"translatedTitle\": null}]",
  "contributors": [],
  "topicTags": [
    {
      "name": "Hash Table",
      "slug": "hash-table"
    },
    {
      "name": "Linked List",
      "slug": "linked-list"
    }
  ],
  "companyTagStats": "{\"1\": [{\"taggedByAdmin\": true, \"name\": \"Amazon\", \"slug\": \"amazon\", \"timesEncountered\": 115}, {\"taggedByAdmin\": true, \"name\": \"Microsoft\", \"slug\": \"microsoft\", \"timesEncountered\": 14}, {\"taggedByAdmin\": false, \"name\": \"Facebook\", \"slug\": \"facebook\", \"timesEncountered\": 10}, {\"taggedByAdmin\": false, \"name\": \"Capital One\", \"slug\": \"capital-one\", \"timesEncountered\": 10}, {\"taggedByAdmin\": true, \"name\": \"Bloomberg\", \"slug\": \"bloomberg\", \"timesEncountered\": 5}, {\"taggedByAdmin\": false, \"name\": \"Oracle\", \"slug\": \"oracle\", \"timesEncountered\": 4}, {\"taggedByAdmin\": false, \"name\": \"Apple\", \"slug\": \"apple\", \"timesEncountered\": 2}, {\"taggedByAdmin\": false, \"name\": \"Yahoo\", \"slug\": \"yahoo\", \"timesEncountered\": 2}, {\"taggedByAdmin\": false, \"name\": \"Qualtrics\", \"slug\": \"qualtrics\", \"timesEncountered\": 2}], \"3\": [{\"taggedByAdmin\": false, \"name\": \"Adobe\", \"slug\": \"adobe\", \"timesEncountered\": 5}, {\"taggedByAdmin\": false, \"name\": \"Alibaba\", \"slug\": \"alibaba\", \"timesEncountered\": 2}, {\"taggedByAdmin\": false, \"name\": \"Mathworks\", \"slug\": \"mathworks\", \"timesEncountered\": 2}, {\"taggedByAdmin\": false, \"name\": \"eBay\", \"slug\": \"ebay\", \"timesEncountered\": 2}, {\"taggedByAdmin\": false, \"name\": \"Visa\", \"slug\": \"visa\", \"timesEncountered\": 2}], \"2\": [{\"taggedByAdmin\": false, \"name\": \"Google\", \"slug\": \"google\", \"timesEncountered\": 5}, {\"taggedByAdmin\": false, \"name\": \"Expedia\", \"slug\": \"expedia\", \"timesEncountered\": 3}, {\"taggedByAdmin\": true, \"name\": \"Uber\", \"slug\": \"uber\", \"timesEncountered\": 2}]}",
  "codeSnippets": [
    {
      "lang": "C++",
      "code": "/*\n// Definition for a Node.\nclass Node {\npublic:\n    int val;\n    Node* next;\n    Node* random;\n    \n    Node(int _val) {\n        val = _val;\n        next = NULL;\n        random = NULL;\n    }\n};\n*/\nclass Solution {\npublic:\n    Node* copyRandomList(Node* head) {\n        \n    }\n};"
    },
    {
      "lang": "Java",
      "code": "/*\n// Definition for a Node.\nclass Node {\n    int val;\n    Node next;\n    Node random;\n\n    public Node(int val) {\n        this.val = val;\n        this.next = null;\n        this.random = null;\n    }\n}\n*/\nclass Solution {\n    public Node copyRandomList(Node head) {\n        \n    }\n}"
    },
    {
      "lang": "Python",
      "code": "\"\"\"\n# Definition for a Node.\nclass Node:\n    def __init__(self, x, next=None, random=None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\"\"\"\nclass Solution(object):\n    def copyRandomList(self, head):\n        \"\"\"\n        :type head: Node\n        :rtype: Node\n        \"\"\"\n        "
    },
    {
      "lang": "Python3",
      "code": "\"\"\"\n# Definition for a Node.\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\"\"\"\nclass Solution:\n    def copyRandomList(self, head: 'Node') -> 'Node':\n        "
    },
    {
      "lang": "C#",
      "code": "/*\n// Definition for a Node.\npublic class Node {\n    public int val;\n    public Node next;\n    public Node random;\n    \n    public Node(int _val) {\n        val = _val;\n        next = null;\n        random = null;\n    }\n}\n*/\npublic class Solution {\n    public Node CopyRandomList(Node head) {\n        \n    }\n}"
    },
    {
      "lang": "JavaScript",
      "code": "/**\n * // Definition for a Node.\n * function Node(val, next, random) {\n *    this.val = val;\n *    this.next = next;\n *    this.random = random;\n * };\n */\n/**\n * @param {Node} head\n * @return {Node}\n */\nvar copyRandomList = function(head) {\n    \n};"
    }
  ],
  "stats": "{\"totalAccepted\": \"321.7K\", \"totalSubmission\": \"1M\", \"totalAcceptedRaw\": 321653, \"totalSubmissionRaw\": 1032459, \"acRate\": \"31.2%\"}",
  "hints": [
    "Just iterate the linked list and create copies of the nodes on the go. Since a node can be referenced from multiple nodes due to the random pointers, make sure you are not making multiple copies of the same node.",
    "You may want to use extra space to keep <b>old node ---> new node</b> mapping to prevent creating multiples copies of same node.",
    "We can avoid using extra space for old node ---> new node mapping, by tweaking the original linked list. Simply interweave the nodes of the old and copied list. \r\nFor e.g.\r\n<pre>\r\nOld List: A --> B --> C --> D\r\nInterWeaved List: A --> A' --> B --> B' --> C --> C' --> D --> D'\r\n</pre>",
    "The interweaving is done using <b>next</b> pointers and we can make use of interweaved structure to get the correct reference nodes for <b>random</b> pointers."
  ],
  "solution": {
    "id": "556",
    "canSeeDetail": true,
    "url": "/articles/copy-list-with-random-pointer/",
    "content": "[TOC]\n\n## Solution\n---\n\nLets first look at how the linked list looks like\n<center>\n<img src=\"../Figures/138/138_Copy_List_Random_1.png\" width=\"500\"/>\n</center>\n\nIn the above diagram, for a given node the `next` pointer points to the next node in the linked list. The `next` pointer is something standard for a linked list and this is what ***links*** the nodes together. What is interesting about the diagram and this problem is the `random` pointer which, as the name suggests can point to any node in the linked list or can be a null.\n\n#### Approach 1: Recursive\n\n**Intuition**\n\nThe basic idea behind the recursive solution is to consider the linked list like a graph. Every node of the Linked List has 2 pointers (edges in a graph). Since, random pointers add the randomness to the structure we might visit the same node again leading to cycles.\n\n<center>\n<img src=\"../Figures/138/138_Copy_List_Random_2.png\" width=\"500\"/>\n</center>\n\nIn the diagram above we can see the random pointer points back to the previously seen node hence leading to a cycle. We need to take care of these cycles in the implementation.\n\nAll we do in this approach is to just traverse the graph and clone it. Cloning essentially means creating a new node for every unseen node you encounter. The traversal part will happen recursively in a depth first manner. Note that we have to keep track of nodes already processed because, as pointed out earlier, we can have cycles because of the random pointers.\n\n**Algorithm**\n\n1. Start traversing the graph from `head` node.\n\n    Lets see the linked structure as a graph. Below is the graph representation of the above linked list example.\n    <center>\n    <img src=\"../Figures/138/138_Copy_List_Random_7.png\" width=\"500\"/>\n    </center>\n\n    In the above example `head` is where we begin our graph traversal.\n\n2. If we already have a cloned copy of the current node in the visited dictionary, we use the cloned node reference.  \n3. If we don't have a cloned copy in the visited dictionary, we create a new node and add it to the visited dictionary.\n`visited_dictionary[current_node] = cloned_node_for_current_node.`\n4. We then make two recursive calls, one using the `random` pointer and the other using `next` pointer. The diagram from step 1, shows `random` and `next` pointers in red and blue color respectively. Essentially we are making recursive calls for the children of the current node. In this implementation, the children are the nodes pointed by the `random` and the `next` pointers.\n<pre>\ncloned_node_for_current_node.next = copyRandomList(current_node.next);\ncloned_node_for_current_node.random = copyRandomList(current_node.random);\n</pre>\n\n<br>\n\n<iframe src=\"https://leetcode.com/playground/DJ8RvR8X/shared\" frameBorder=\"0\" width=\"100%\" height=\"500\" name=\"DJ8RvR8X\"></iframe>\n\n**Complexity Analysis**\n\n* Time Complexity: $$O(N)$$ where N is the number of nodes in the linked list.\n* Space Complexity: $$O(N)$$. If we look closely, we have the recursion stack and we also have the space complexity to keep track of nodes already cloned i.e. using the visited dictionary. But asymptotically, the complexity is $$O(N)$$.\n<br/>\n<br/>\n\n---\n\n#### Approach 2: Iterative with $$O(N)$$ Space\n\n**Intuition**\n\nThe iterative solution to this problem does not model it as a graph, instead simply treats it as a LinkedList.\nWhen we are iterating over the list, we can create new nodes via the random pointer or the next pointer whichever points to a node that doesn't exist in our old --> new dictionary.\n\n**Algorithm**\n\n1. Traverse the linked list starting at `head` of the linked list.\n    <center>\n    <img src=\"../Figures/138/138_Copy_List_Random_3.png\" width=\"600\"/>\n    </center>\n\n    In the above diagram we create a new cloned `head` node. The cloned node is shown using dashed lines. In the implementation we would even store the reference of this newly created node in a visited dictionary.\n\n2. Random Pointer\n    * If the `random` pointer of the current node $$i$$ points to the a node $$j$$ and a clone of $$j$$ already exists in the visited dictionary, we will simply use the cloned node reference from the visited dictionary.\n    * If the `random` pointer of the current node $$i$$ points to the a node $$j$$ which has not been created yet, we create a new node corresponding to $$j$$ and add it to the visited dictionary.\n\n    <center>\n    <img src=\"../Figures/138/138_Copy_List_Random_4.png\" width=\"600\"/>\n    </center>\n\n    In the above diagram the `random` pointer of node $$A$$ points to a node $$C$$. Node $$C$$ which was not visited yet as we can see from the previous diagram. Hence we create a new cloned $$C'$$ node corresponding to node $$C$$ and add it to visited dictionary.\n\n3. Next Pointer\n    * If the `next` pointer of the current node $$i$$ points to the a node $$j$$ and a clone of $$j$$ already exists in the visited dictionary, we will simply use the cloned node reference from the visited dictionary.\n    * If the `next` pointer of the current node $$i$$ points to the a node $$j$$ which has not been created yet, we create a new node corresponding to $$j$$ and add it to the visited dictionary.\n\n    <center>\n    <img src=\"../Figures/138/138_Copy_List_Random_5.png\" width=\"600\"/>\n    </center>\n\n    In the above diagram the `next` pointer of node $$A$$ points to a node $$B$$. Node $$B$$ which was not visited yet as we can see from the previous diagram. Hence we create a new cloned $$B'$$ node corresponding to node $$B$$ and add it to visited dictionary.\n\n4. We repeat steps 2 and 3 until we reach the end of the linked list.\n\n    <center>\n    <img src=\"../Figures/138/138_Copy_List_Random_6.png\" width=\"600\"/>\n    </center>\n\n    In the above diagram, the `random` pointer of node $$B$$ points to an already visited node $$A$$. Hence in step 2, we don't create a new copy for the clone. Instead we point `random` pointer of cloned node $$B'$$ to already existing cloned node $$A'$$.\n\n    Also, the `next` pointer of node $$B$$ points to an already visited node $$C$$. Hence in step 3, we don't create a new copy for the clone. Instead we point `next` pointer of cloned node $$B'$$ to already existing cloned node $$C'$$.\n\n<iframe src=\"https://leetcode.com/playground/jKbPYfgd/shared\" frameBorder=\"0\" width=\"100%\" height=\"500\" name=\"jKbPYfgd\"></iframe>\n\n**Complexity Analysis**\n\n* Time Complexity : $$O(N)$$ because we make one pass over the original linked list.\n* Space Complexity : $$O(N)$$ as we have a dictionary containing mapping from old list nodes to new list nodes. Since there are $$N$$ nodes, we have $$O(N)$$ space complexity.\n<br/>\n<br/>\n\n---\n\n#### Approach 3: Iterative with $$O(1)$$ Space\n\n**Intuition**\n\nInstead of a separate dictionary to keep the old node --> new node mapping, we can tweak the original linked list and keep every cloned node next to its original node. This interleaving of old and new nodes allows us to solve this problem without any extra space. Lets look at how the algorithm works.\n\n**Algorithm**\n\n1. Traverse the original list and clone the nodes as you go and place the cloned copy next to its original node. This new linked list is essentially a interweaving of original and cloned nodes.\n\n    <center>\n    <img src=\"../Figures/138/138_Copy_List_Random_8_1.png\" width=\"800\"/>\n    </center>\n    <center>\n    <img src=\"../Figures/138/138_Copy_List_Random_8_2.png\" width=\"800\"/>\n    </center>\n\n    As you can see we just use the value of original node to create the cloned copy. The `next` pointer is used to create the weaving. Note that this operation ends up modifying the original linked list.\n    <pre>\n    cloned_node.next = original_node.next\n    original_node.next = cloned_node\n    </pre>\n\n2. Iterate the list having both the new and old nodes intertwined with each other and use the original nodes' random pointers to assign references to random pointers for cloned nodes. For eg. If `B` has a random pointer to `A`, this means `B'` has a random pointer to `A'`.\n\n    <center>\n    <img src=\"../Figures/138/138_Copy_List_Random_9_1.png\" width=\"800\"/>\n    </center>\n\n3. Now that the `random` pointers are assigned to the correct node, the `next` pointers need to be correctly assigned to unweave the current linked list and get back the original list and the cloned list.\n\n    <center>\n    <img src=\"../Figures/138/138_Copy_List_Random_10.png\" width=\"800\"/>\n    </center>\n\n\n<iframe src=\"https://leetcode.com/playground/maLCYfzX/shared\" frameBorder=\"0\" width=\"100%\" height=\"500\" name=\"maLCYfzX\"></iframe>\n\n**Complexity Analysis**\n\n* Time Complexity : $$O(N)$$\n* Space Complexity : $$O(1)$$\n<br /><br/>\n\n---\nAnalysis written by: [@godayaldivya](https://leetcode.com/godayaldivya/).",
    "contentTypeId": "107",
    "rating": {
      "id": "547",
      "count": 95,
      "average": 4.853,
      "userRating": null
    }
  },
  "status": null,
  "sampleTestCase": "[[7,null],[13,0],[11,4],[10,2],[1,0]]\r",
  "metaData": "{\n  \"name\": \"copyRandomList\",\n  \"params\": [\n    {\n      \"name\": \"head\",\n      \"type\": \"Node\"\n    }\n  ],\n  \"return\": {\n    \"type\": \"Node\"\n  },\n  \"structures\": [\n    {\n      \"name\": \"Node\",\n      \"comment\": \"Definition for a Node.\",\n      \"members\": [\n        {\n          \"name\": \"val\",\n          \"type\": \"integer\"\n        },\n        {\n          \"name\": \"next\",\n          \"type\": \"Node\"\n        },\n        {\n          \"name\": \"random\",\n          \"type\": \"Node\"\n        }\n      ]\n    }\n  ],\n  \"languages\": [\n    \"cpp\",\n    \"java\",\n    \"python\",\n    \"csharp\",\n    \"javascript\",\n    \"python3\"\n  ],\n  \"manual\": true\n}",
  "judgerAvailable": true,
  "judgeType": "large",
  "mysqlSchemas": [],
  "enableRunCode": true,
  "enableTestMode": false,
  "libraryUrl": null
}
