{
  "questionId": "142",
  "questionFrontendId": "142",
  "boundTopicId": null,
  "title": "Linked List Cycle II",
  "titleSlug": "linked-list-cycle-ii",
  "categoryTitle": "Algorithms",
  "content": "<p>Given a linked list, return the node where the cycle begins. If there is no cycle, return <code>null</code>.</p>\n\n<p>To represent a cycle in the given linked list, we use an integer <code>pos</code> which represents the position (0-indexed)&nbsp;in the linked list where tail connects to. If <code>pos</code> is <code>-1</code>, then there is no cycle in the linked list.</p>\n\n<p><b>Note:</b> Do not modify the linked list.</p>\n\n<p>&nbsp;</p>\n\n<p><strong>Example 1:</strong></p>\n\n<pre>\n<strong>Input: </strong>head = [3,2,0,-4], pos = 1\n<strong>Output: </strong>tail connects to node index 1\n<strong>Explanation:</strong> There is a cycle in the linked list, where tail connects to the second node.\n</pre>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2018/12/07/circularlinkedlist.png\" style=\"height: 97px; width: 300px;\" /></p>\n\n<p><strong>Example 2:</strong></p>\n\n<pre>\n<strong>Input: </strong>head = [1,2], pos = 0\n<strong>Output: </strong>tail connects to node index 0\n<strong>Explanation:</strong> There is a cycle in the linked list, where tail connects to the first node.\n</pre>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2018/12/07/circularlinkedlist_test2.png\" style=\"height: 74px; width: 141px;\" /></p>\n\n<p><strong>Example 3:</strong></p>\n\n<pre>\n<strong>Input: </strong>head = [1], pos = -1\n<strong>Output: </strong>no cycle\n<strong>Explanation:</strong> There is no cycle in the linked list.\n</pre>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2018/12/07/circularlinkedlist_test3.png\" style=\"height: 45px; width: 45px;\" /></p>\n\n<p>&nbsp;</p>\n\n<p><b>Follow-up</b>:<br />\nCan you solve it without using extra space?</p>\n",
  "isPaidOnly": false,
  "difficulty": "Medium",
  "likes": 1939,
  "dislikes": 156,
  "isLiked": null,
  "similarQuestions": "[{\"title\": \"Linked List Cycle\", \"titleSlug\": \"linked-list-cycle\", \"difficulty\": \"Easy\", \"translatedTitle\": null}, {\"title\": \"Find the Duplicate Number\", \"titleSlug\": \"find-the-duplicate-number\", \"difficulty\": \"Medium\", \"translatedTitle\": null}]",
  "contributors": [],
  "topicTags": [
    {
      "name": "Linked List",
      "slug": "linked-list"
    },
    {
      "name": "Two Pointers",
      "slug": "two-pointers"
    }
  ],
  "companyTagStats": "{\"1\": [{\"taggedByAdmin\": false, \"name\": \"Microsoft\", \"slug\": \"microsoft\", \"timesEncountered\": 3}], \"2\": [{\"taggedByAdmin\": false, \"name\": \"Amazon\", \"slug\": \"amazon\", \"timesEncountered\": 4}, {\"taggedByAdmin\": false, \"name\": \"Google\", \"slug\": \"google\", \"timesEncountered\": 2}, {\"taggedByAdmin\": false, \"name\": \"LinkedIn\", \"slug\": \"linkedin\", \"timesEncountered\": 2}, {\"taggedByAdmin\": false, \"name\": \"eBay\", \"slug\": \"ebay\", \"timesEncountered\": 2}], \"3\": [{\"taggedByAdmin\": false, \"name\": \"Bloomberg\", \"slug\": \"bloomberg\", \"timesEncountered\": 2}, {\"taggedByAdmin\": false, \"name\": \"Apple\", \"slug\": \"apple\", \"timesEncountered\": 2}]}",
  "codeSnippets": [
    {
      "lang": "C++",
      "code": "/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode(int x) : val(x), next(NULL) {}\n * };\n */\nclass Solution {\npublic:\n    ListNode *detectCycle(ListNode *head) {\n        \n    }\n};"
    },
    {
      "lang": "Java",
      "code": "/**\n * Definition for singly-linked list.\n * class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode(int x) {\n *         val = x;\n *         next = null;\n *     }\n * }\n */\npublic class Solution {\n    public ListNode detectCycle(ListNode head) {\n        \n    }\n}"
    },
    {
      "lang": "Python",
      "code": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, x):\n#         self.val = x\n#         self.next = None\n\nclass Solution(object):\n    def detectCycle(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        "
    },
    {
      "lang": "Python3",
      "code": "# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, x):\n#         self.val = x\n#         self.next = None\n\nclass Solution:\n    def detectCycle(self, head: ListNode) -> ListNode:\n        "
    },
    {
      "lang": "C",
      "code": "/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     struct ListNode *next;\n * };\n */\nstruct ListNode *detectCycle(struct ListNode *head) {\n    \n}"
    },
    {
      "lang": "C#",
      "code": "/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     public int val;\n *     public ListNode next;\n *     public ListNode(int x) {\n *         val = x;\n *         next = null;\n *     }\n * }\n */\npublic class Solution {\n    public ListNode DetectCycle(ListNode head) {\n        \n    }\n}"
    },
    {
      "lang": "JavaScript",
      "code": "/**\n * Definition for singly-linked list.\n * function ListNode(val) {\n *     this.val = val;\n *     this.next = null;\n * }\n */\n\n/**\n * @param {ListNode} head\n * @return {ListNode}\n */\nvar detectCycle = function(head) {\n    \n};"
    },
    {
      "lang": "Go",
      "code": "/**\n * Definition for singly-linked list.\n * type ListNode struct {\n *     Val int\n *     Next *ListNode\n * }\n */\nfunc detectCycle(head *ListNode) *ListNode {\n    \n}"
    },
    {
      "lang": "PHP",
      "code": "/**\n * Definition for a singly-linked list.\n * class ListNode {\n *     public $val = 0;\n *     public $next = null;\n *     function __construct($val) { $this->val = $val; }\n * }\n */\nclass Solution {\n\n    /**\n     * @param ListNode $head\n     * @param Integer $pos\n     * @return ListNode\n     */\n    function detectCycle($head, $pos) {\n        \n    }\n}"
    }
  ],
  "stats": "{\"totalAccepted\": \"260.6K\", \"totalSubmission\": \"755K\", \"totalAcceptedRaw\": 260593, \"totalSubmissionRaw\": 755000, \"acRate\": \"34.5%\"}",
  "hints": [],
  "solution": {
    "id": "315",
    "canSeeDetail": true,
    "url": "/articles/linked-list-cycle-ii/",
    "content": "[TOC]\n\n#### Approach 1: Hash Table\n\n**Intuition**\n\nIf we keep track of the nodes that we've seen already in a `Set`, we can\ntraverse the list and return the first duplicate node.\n\n**Algorithm**\n\nFirst, we allocate a `Set` to store `ListNode` references. Then, we traverse\nthe list, checking `visited` for containment of the current node. If the node\nhas already been seen, then it is necessarily the entrance to the cycle. If\nany other node were the entrance to the cycle, then we would have already\nreturned that node instead. Otherwise, the `if` condition will never be\nsatisfied, and our function will return `null`.\n\nThe algorithm necessarily terminates for any list with a finite number of\nnodes, as the domain of input lists can be divided into two categories:\ncyclic and acyclic lists. An acyclic list resembles a `null`-terminated chain\nof nodes, while a cyclic list can be thought of as an acyclic list with the\nfinal `null` replaced by a reference to some previous node. If the `while`\nloop terminates, we return `null`, as we have traversed the entire list\nwithout encountering a duplicate reference. In this case, the list is\nacyclic. For a cyclic list, the `while` loop will never terminate, but at\nsome point the `if` condition will be satisfied and cause the function to\nreturn.\n\n<iframe src=\"https://leetcode.com/playground/cMo8bmHh/shared\" frameBorder=\"0\" width=\"100%\" height=\"327\" name=\"cMo8bmHh\"></iframe>\n\n**Complexity Analysis**\n\n* Time complexity : $$O(n)$$\n\n    For both cyclic and acyclic inputs, the algorithm must visit each node exactly once. This is transparently obvious for acyclic lists because the $$n$$th node points to `null`, causing the loop to terminate. For cyclic lists, the `if` condition will cause the function to return after visiting the $$n$$th node, as it points to some node that is already in `visited`. In both cases, the number of nodes visited is exactly $$n$$, so the runtime is linear in the number of nodes.\n\n* Space complexity : $$O(n)$$\n\n    For both cyclic and acyclic inputs, we will need to insert each node into the `Set` once. The only difference between the two cases is whether we discover that the \"last\" node points to `null` or a previously-visited node. Therefore, because the `Set` will contain $$n$$ distinct nodes, the memory footprint is linear in the number of nodes.\n\n<br />\n\n---\n#### Approach 2: Floyd's Tortoise and Hare\n\n**Intuition**\n\nWhat happens when a fast runner (a hare) races a slow runner (a tortoise) on\na circular track? At some point, the fast runner will catch up to the slow\nrunner from behind.\n\n**Algorithm**\n\nFloyd's algorithm is separated into two distinct _phases_. In the first\nphase, it determines whether a cycle is present in the list. If no cycle is\npresent, it returns `null` immediately, as it is impossible to find the\nentrance to a nonexistant cycle. Otherwise, it uses the located \"intersection\nnode\" to find the entrance to the cycle.\n\n*Phase 1*\n\nHere, we initialize two pointers - the fast `hare` and the slow `tortoise`.\nThen, until `hare` can no longer advance, we increment `tortoise` once and\n`hare` twice.[^1] If, after advancing them, `hare` and `tortoise` point to\nthe same node, we return it. Otherwise, we continue. If the `while` loop\nterminates without returning a node, then the list is acyclic, and we return\n`null` to indicate as much.\n\nTo see why this works, consider the image below:\n\n<center>\n    <img src=\"../Figures/142/Slide1.PNG\" alt=\"Diagram of cyclic list\" style=\"width: 650px;\"/>\n</center>\n\nHere, the nodes in the cycle have been labelled from 0 to $$C-1$$, where\n$$C$$ is the length of the cycle. The noncyclic nodes have been labelled from\n$$-F$$ to -1, where $$F$$ is the number of nodes outside of the cycle. After\n$$F$$ iterations, `tortoise` points to node 0 and `hare` points to some node\n$$h$$, where $$F \\equiv h \\pmod C$$. This is because `hare` traverses $$2F$$\nnodes over the course of $$F$$ iterations, exactly $$F$$ of which are in the\ncycle. After $$C-h$$ more iterations, `tortoise` obviously points to node\n$$C-h$$, but (less obviously) `hare` also points to the same node. To see why,\nremember that `hare` traverses $$2(C-h)$$ from its starting position of $$h$$:\n\n$$\n\\begin{aligned}\n    h + 2(C-h) &= 2C - h \\\\\n                &\\equiv C-h \\pmod C\n\\end{aligned}\n$$\n\nTherefore, given that the list is cyclic, `hare` and `tortoise` will\neventually both point to the same node, known henceforce as the\n_intersection_.\n\n*Phase 2*\n\nGiven that phase 1 finds an intersection, phase 2 proceeds to find the node\nthat is the entrance to the cycle. To do so, we initialize two more pointers:\n`ptr1`, which points to the head of the list, and `ptr2`, which points to\nthe intersection. Then, we advance each of them by 1 until they meet; the\nnode where they meet is the entrance to the cycle, so we return it.\n\nUse the diagram below to help understand the proof of this approach's\ncorrectness.\n\n<center>\n    <img src=\"../Figures/142/diagram.png\" alt=\"Phase 2 diagram\" style=\"width: 650px;\"/>\n</center>\n\nWe can harness the fact that `hare` moves twice as quickly as `tortoise` to\nassert that when `hare` and `tortoise` meet at node $$h$$, `hare` has\ntraversed twice as many nodes. Using this fact, we deduce the following:\n\n$$\n\\begin{aligned}\n    2 \\cdot distance(tortoise) &= distance(hare) \\\\\n                        2(F+a) &= F+a+b+a \\\\\n                         2F+2a &= F+2a+b \\\\\n                             F &= b \\\\\n\\end{aligned}\n$$\n\nBecause $$F=b$$, pointers starting at nodes $$h$$ and $$0$$ will traverse the\nsame number of nodes before meeting.\n\nTo see the entire algorithm in action, check out the animation below:\n\n!?!../Documents/142_Linked_List_Cycle_II.json:1280,720!?!\n\n<iframe src=\"https://leetcode.com/playground/ZZzspTLp/shared\" frameBorder=\"0\" width=\"100%\" height=\"500\" name=\"ZZzspTLp\"></iframe>\n\n**Complexity Analysis**\n\n* Time complexity : $$O(n)$$\n\n    For cyclic lists, `hare` and `tortoise` will point to the same node after\n    $$F+C-h$$ iterations, as demonstrated in the proof of correctness.\n    $$F+C-h \\leq F+C = n$$, so phase 1 runs in $$O(n)$$ time. Phase 2\n    runs for $$F < n$$ iterations, so it also runs in $$O(n)$$ time.\n\n    For acyclic lists, `hare` will reach the end of the list in roughly\n    $$\\dfrac{n}{2}$$ iterations, causing the function to return before phase\n    2. Therefore, regardless of which category of list the algorithm\n    receives, it runs in time linearly proportional to the number of nodes.\n\n* Space complexity : $$O(1)$$\n\n    Floyd's Tortoise and Hare algorithm allocates only pointers, so it runs\n    with constant overall memory usage.\n\n\n**Footnotes**\n\n[^1]: It is sufficient to check only `hare` because it will always be ahead\nof `tortoise` in an acyclic list.",
    "contentTypeId": "107",
    "rating": {
      "id": "310",
      "count": 28,
      "average": 4.786,
      "userRating": null
    }
  },
  "status": null,
  "sampleTestCase": "[3,2,0,-4]\n1",
  "metaData": "{\n  \"name\": \"detectCycle\",\n  \"params\": [\n    {\n      \"name\": \"head\",\n      \"type\": \"ListNode\"\n    },\n    {\n      \"name\": \"pos\",\n      \"type\": \"integer\"\n    }\n  ],\n  \"return\": {\n    \"type\": \"ListNode\"\n  },\n  \"languages\": [\n    \"cpp\",\n    \"java\",\n    \"python\",\n    \"c\",\n    \"csharp\",\n    \"javascript\",\n    \"golang\",\n    \"python3\"\n  ],\n  \"manual\": true\n}",
  "judgerAvailable": true,
  "judgeType": "large",
  "mysqlSchemas": [],
  "enableRunCode": true,
  "enableTestMode": false,
  "libraryUrl": null
}
