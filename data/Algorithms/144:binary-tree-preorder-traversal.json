{
  "questionId": "144",
  "questionFrontendId": "144",
  "boundTopicId": null,
  "title": "Binary Tree Preorder Traversal",
  "titleSlug": "binary-tree-preorder-traversal",
  "categoryTitle": "Algorithms",
  "content": "<p>Given a binary tree, return the <em>preorder</em> traversal of its nodes&#39; values.</p>\r\n\r\n<p><strong>Example:</strong></p>\r\n\r\n<pre>\r\n<strong>Input:</strong>&nbsp;<code>[1,null,2,3]</code>\r\n   1\r\n    \\\r\n     2\r\n    /\r\n   3\r\n\r\n<strong>Output:</strong>&nbsp;<code>[1,2,3]</code>\r\n</pre>\r\n\r\n<p><strong>Follow up:</strong> Recursive solution is trivial, could you do it iteratively?</p>\r\n",
  "isPaidOnly": false,
  "difficulty": "Medium",
  "likes": 1066,
  "dislikes": 46,
  "isLiked": null,
  "similarQuestions": "[{\"title\": \"Binary Tree Inorder Traversal\", \"titleSlug\": \"binary-tree-inorder-traversal\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Verify Preorder Sequence in Binary Search Tree\", \"titleSlug\": \"verify-preorder-sequence-in-binary-search-tree\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"N-ary Tree Preorder Traversal\", \"titleSlug\": \"n-ary-tree-preorder-traversal\", \"difficulty\": \"Easy\", \"translatedTitle\": null}]",
  "contributors": [],
  "topicTags": [
    {
      "name": "Stack",
      "slug": "stack"
    },
    {
      "name": "Tree",
      "slug": "tree"
    }
  ],
  "companyTagStats": "{\"1\": [{\"taggedByAdmin\": false, \"name\": \"Amazon\", \"slug\": \"amazon\", \"timesEncountered\": 2}], \"2\": [{\"taggedByAdmin\": false, \"name\": \"Cisco\", \"slug\": \"cisco\", \"timesEncountered\": 2}, {\"taggedByAdmin\": false, \"name\": \"Google\", \"slug\": \"google\", \"timesEncountered\": 2}], \"3\": []}",
  "codeSnippets": [
    {
      "lang": "C++",
      "code": "/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\n * };\n */\nclass Solution {\npublic:\n    vector<int> preorderTraversal(TreeNode* root) {\n        \n    }\n};"
    },
    {
      "lang": "Java",
      "code": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode(int x) { val = x; }\n * }\n */\nclass Solution {\n    public List<Integer> preorderTraversal(TreeNode root) {\n        \n    }\n}"
    },
    {
      "lang": "Python",
      "code": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, x):\n#         self.val = x\n#         self.left = None\n#         self.right = None\n\nclass Solution(object):\n    def preorderTraversal(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[int]\n        \"\"\"\n        "
    },
    {
      "lang": "Python3",
      "code": "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, x):\n#         self.val = x\n#         self.left = None\n#         self.right = None\n\nclass Solution:\n    def preorderTraversal(self, root: TreeNode) -> List[int]:\n        "
    },
    {
      "lang": "C",
      "code": "/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     struct TreeNode *left;\n *     struct TreeNode *right;\n * };\n */\n\n\n/**\n * Note: The returned array must be malloced, assume caller calls free().\n */\nint* preorderTraversal(struct TreeNode* root, int* returnSize){\n\n}\n\n"
    },
    {
      "lang": "C#",
      "code": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     public int val;\n *     public TreeNode left;\n *     public TreeNode right;\n *     public TreeNode(int x) { val = x; }\n * }\n */\npublic class Solution {\n    public IList<int> PreorderTraversal(TreeNode root) {\n        \n    }\n}"
    },
    {
      "lang": "JavaScript",
      "code": "/**\n * Definition for a binary tree node.\n * function TreeNode(val) {\n *     this.val = val;\n *     this.left = this.right = null;\n * }\n */\n/**\n * @param {TreeNode} root\n * @return {number[]}\n */\nvar preorderTraversal = function(root) {\n    \n};"
    },
    {
      "lang": "Ruby",
      "code": "# Definition for a binary tree node.\n# class TreeNode\n#     attr_accessor :val, :left, :right\n#     def initialize(val)\n#         @val = val\n#         @left, @right = nil, nil\n#     end\n# end\n\n# @param {TreeNode} root\n# @return {Integer[]}\ndef preorder_traversal(root)\n    \nend"
    },
    {
      "lang": "Swift",
      "code": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     public var val: Int\n *     public var left: TreeNode?\n *     public var right: TreeNode?\n *     public init(_ val: Int) {\n *         self.val = val\n *         self.left = nil\n *         self.right = nil\n *     }\n * }\n */\nclass Solution {\n    func preorderTraversal(_ root: TreeNode?) -> [Int] {\n        \n    }\n}"
    },
    {
      "lang": "Go",
      "code": "/**\n * Definition for a binary tree node.\n * type TreeNode struct {\n *     Val int\n *     Left *TreeNode\n *     Right *TreeNode\n * }\n */\nfunc preorderTraversal(root *TreeNode) []int {\n    \n}"
    },
    {
      "lang": "Scala",
      "code": "/**\n * Definition for a binary tree node.\n * class TreeNode(var _value: Int) {\n *   var value: Int = _value\n *   var left: TreeNode = null\n *   var right: TreeNode = null\n * }\n */\nobject Solution {\n    def preorderTraversal(root: TreeNode): List[Int] = {\n        \n    }\n}"
    },
    {
      "lang": "Kotlin",
      "code": "/**\n * Example:\n * var ti = TreeNode(5)\n * var v = ti.`val`\n * Definition for a binary tree node.\n * class TreeNode(var `val`: Int) {\n *     var left: TreeNode? = null\n *     var right: TreeNode? = null\n * }\n */\nclass Solution {\n    fun preorderTraversal(root: TreeNode?): List<Int> {\n        \n    }\n}"
    },
    {
      "lang": "Rust",
      "code": "// Definition for a binary tree node.\n// #[derive(Debug, PartialEq, Eq)]\n// pub struct TreeNode {\n//   pub val: i32,\n//   pub left: Option<Rc<RefCell<TreeNode>>>,\n//   pub right: Option<Rc<RefCell<TreeNode>>>,\n// }\n// \n// impl TreeNode {\n//   #[inline]\n//   pub fn new(val: i32) -> Self {\n//     TreeNode {\n//       val,\n//       left: None,\n//       right: None\n//     }\n//   }\n// }\nuse std::rc::Rc;\nuse std::cell::RefCell;\nimpl Solution {\n    pub fn preorder_traversal(root: Option<Rc<RefCell<TreeNode>>>) -> Vec<i32> {\n        \n    }\n}"
    },
    {
      "lang": "PHP",
      "code": "/**\n * Definition for a binary tree node.\n * class TreeNode {\n *     public $val = null;\n *     public $left = null;\n *     public $right = null;\n *     function __construct($value) { $this->val = $value; }\n * }\n */\nclass Solution {\n\n    /**\n     * @param TreeNode $root\n     * @return Integer[]\n     */\n    function preorderTraversal($root) {\n        \n    }\n}"
    }
  ],
  "stats": "{\"totalAccepted\": \"409.2K\", \"totalSubmission\": \"766.2K\", \"totalAcceptedRaw\": 409218, \"totalSubmissionRaw\": 766202, \"acRate\": \"53.4%\"}",
  "hints": [],
  "solution": {
    "id": "594",
    "canSeeDetail": true,
    "url": "/articles/binary-tree-preorder-transversal/",
    "content": "[TOC]\r\n\r\n## Solution\r\n\r\n---\r\n\r\n#### How to traverse the tree\r\n\r\n\r\nThere are two general strategies to traverse a tree:\r\n\r\n- *Breadth First Search* (`BFS`)\r\n\r\n    We scan through the tree level by level, following the order of height,\r\n    from top to bottom. The nodes on higher level would be visited before\r\n    the ones with lower levels.\r\n     \r\n- *Depth First Search* (`DFS`)\r\n\r\n    In this strategy, we adopt the `depth` as the priority, so that one\r\n    would start from a root and reach all the way down to certain leaf,\r\n    and then back to root to reach another branch.\r\n\r\n    The DFS strategy can further be distinguished as\r\n    `preorder`, `inorder`, and `postorder` depending on the relative order\r\n    among the root node, left node and right node.\r\n    \r\nOn the following figure the nodes are numerated in the order you visit them,\r\nplease follow ```1-2-3-4-5``` to compare different strategies.\r\n\r\n![postorder](../Figures/145_transverse.png)\r\n\r\nHere the problem is to implement postorder traversal using iterations.\r\n<br />\r\n<br />\r\n\r\n\r\n---\r\n#### Approach 1: Iterations\r\n\r\n**Algorithm**\r\n\r\nFirst of all, here is the definition of the ```TreeNode``` which we would use\r\nin the following implementation.\r\n\r\n<iframe src=\"https://leetcode.com/playground/tXtrJwT2/shared\" frameBorder=\"0\" width=\"100%\" height=\"225\" name=\"tXtrJwT2\"></iframe>\r\n\r\nLet's start from the root and then at each iteration \r\npop the current node out of the stack and\r\npush its child nodes. \r\nIn the implemented strategy we push nodes into output list \r\nfollowing the order ```Top->Bottom``` and ```Left->Right```, that\r\nnaturally reproduces preorder traversal.\r\n\r\n<iframe src=\"https://leetcode.com/playground/BRAuDZUW/shared\" frameBorder=\"0\" width=\"100%\" height=\"429\" name=\"BRAuDZUW\"></iframe>\r\n\r\n\r\n\r\n**Complexity Analysis**\r\n\r\n* Time complexity : we visit each node exactly once, thus the \r\ntime complexity is $$\\mathcal{O}(N)$$,\r\nwhere $$N$$ is the number of nodes, *i.e.* the size of tree.\r\n\r\n* Space complexity : depending on the tree structure, \r\nwe could keep up to the entire tree, therefore, the space complexity is $$\\mathcal{O}(N)$$.\r\n<br />\r\n<br />\r\n\r\n\r\n---\r\n#### Approach 2: Morris traversal\r\n\r\nThis approach is based on [Morris's article](https://www.sciencedirect.com/science/article/pii/0020019079900681) \r\nwhich is intended to optimize the space complexity. The algorithm does not use additional space \r\nfor the computation, and the memory \r\nis only used to keep the output. \r\nIf one prints the output directly along the computation, the space complexity \r\nwould be $$\\mathcal{O}(1)$$.\r\n\r\n**Algorithm**\r\n\r\nHere the idea is to go down from the node to its predecessor, \r\nand each predecessor will be visited twice.\r\nFor this go one step left if possible and then always right till the end.\r\nWhen we visit a leaf (node's predecessor) first time, it has a zero right child, \r\nso we update output and establish \r\nthe pseudo link ```predecessor.right = root``` to mark the fact the predecessor is visited.\r\nWhen we visit the same predecessor the second time, it \r\nalready points to the current node, thus we remove pseudo link and \r\nmove right to the next node.\r\n\r\nIf the first one step left is impossible, \r\nupdate output and move right to next node.\r\n\r\n<!--![LIS](../Figures/144/144_gif.gif)-->\r\n!?!../Documents/144_LIS.json:1000,582!?!\r\n \r\n<iframe src=\"https://leetcode.com/playground/YX2Q6eH4/shared\" frameBorder=\"0\" width=\"100%\" height=\"500\" name=\"YX2Q6eH4\"></iframe>\r\n\r\n**Complexity Analysis**\r\n\r\n* Time complexity : we visit each predecessor exactly twice descending down \r\nfrom the node, thus the time complexity is $$\\mathcal{O}(N)$$,\r\nwhere $$N$$ is the number of nodes, *i.e.* the size of tree.\r\n\r\n* Space complexity : we use no additional memory for the computation itself, \r\nbut output list contains $$N$$ elements, and thus space complexity is $$\\mathcal{O}(N)$$.\r\n\r\nAnalysis written by @[liaison](https://leetcode.com/liaison/)\r\nand @[andvary](https://leetcode.com/andvary/)",
    "contentTypeId": "107",
    "rating": {
      "id": "580",
      "count": 17,
      "average": 5,
      "userRating": null
    }
  },
  "status": null,
  "sampleTestCase": "[1,null,2,3]",
  "metaData": "{\r\n  \"name\": \"preorderTraversal\",\r\n  \"params\": [\r\n    {\r\n      \"name\": \"root\",\r\n      \"type\": \"TreeNode\"\r\n    }\r\n  ],\r\n  \"return\": {\r\n    \"type\": \"list<integer>\",\r\n    \"dealloc\": true\r\n  }\r\n}",
  "judgerAvailable": true,
  "judgeType": "large",
  "mysqlSchemas": [],
  "enableRunCode": true,
  "enableTestMode": false,
  "libraryUrl": null
}
