{
  "questionId": "145",
  "questionFrontendId": "145",
  "boundTopicId": null,
  "title": "Binary Tree Postorder Traversal",
  "titleSlug": "binary-tree-postorder-traversal",
  "categoryTitle": "Algorithms",
  "content": "<p>Given a binary tree, return the <em>postorder</em> traversal of its nodes&#39; values.</p>\r\n\r\n<p><strong>Example:</strong></p>\r\n\r\n<pre>\r\n<strong>Input:</strong>&nbsp;<code>[1,null,2,3]</code>\r\n   1\r\n    \\\r\n     2\r\n    /\r\n   3\r\n\r\n<strong>Output:</strong>&nbsp;<code>[3,2,1]</code>\r\n</pre>\r\n\r\n<p><strong>Follow up:</strong> Recursive solution is trivial, could you do it iteratively?</p>\r\n",
  "isPaidOnly": false,
  "difficulty": "Hard",
  "likes": 1260,
  "dislikes": 66,
  "isLiked": null,
  "similarQuestions": "[{\"title\": \"Binary Tree Inorder Traversal\", \"titleSlug\": \"binary-tree-inorder-traversal\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"N-ary Tree Postorder Traversal\", \"titleSlug\": \"n-ary-tree-postorder-traversal\", \"difficulty\": \"Easy\", \"translatedTitle\": null}]",
  "contributors": [],
  "topicTags": [
    {
      "name": "Stack",
      "slug": "stack"
    },
    {
      "name": "Tree",
      "slug": "tree"
    }
  ],
  "companyTagStats": "{\"1\": [{\"taggedByAdmin\": false, \"name\": \"Google\", \"slug\": \"google\", \"timesEncountered\": 2}], \"3\": [{\"taggedByAdmin\": false, \"name\": \"Baidu\", \"slug\": \"baidu\", \"timesEncountered\": 2}, {\"taggedByAdmin\": false, \"name\": \"Adobe\", \"slug\": \"adobe\", \"timesEncountered\": 2}], \"2\": [{\"taggedByAdmin\": false, \"name\": \"Amazon\", \"slug\": \"amazon\", \"timesEncountered\": 5}, {\"taggedByAdmin\": false, \"name\": \"Facebook\", \"slug\": \"facebook\", \"timesEncountered\": 3}, {\"taggedByAdmin\": false, \"name\": \"Uber\", \"slug\": \"uber\", \"timesEncountered\": 2}]}",
  "codeSnippets": [
    {
      "lang": "C++",
      "code": "/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\n * };\n */\nclass Solution {\npublic:\n    vector<int> postorderTraversal(TreeNode* root) {\n        \n    }\n};"
    },
    {
      "lang": "Java",
      "code": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode(int x) { val = x; }\n * }\n */\nclass Solution {\n    public List<Integer> postorderTraversal(TreeNode root) {\n        \n    }\n}"
    },
    {
      "lang": "Python",
      "code": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, x):\n#         self.val = x\n#         self.left = None\n#         self.right = None\n\nclass Solution(object):\n    def postorderTraversal(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[int]\n        \"\"\"\n        "
    },
    {
      "lang": "Python3",
      "code": "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, x):\n#         self.val = x\n#         self.left = None\n#         self.right = None\n\nclass Solution:\n    def postorderTraversal(self, root: TreeNode) -> List[int]:\n        "
    },
    {
      "lang": "C",
      "code": "/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     struct TreeNode *left;\n *     struct TreeNode *right;\n * };\n */\n\n\n/**\n * Note: The returned array must be malloced, assume caller calls free().\n */\nint* postorderTraversal(struct TreeNode* root, int* returnSize){\n\n}\n\n"
    },
    {
      "lang": "C#",
      "code": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     public int val;\n *     public TreeNode left;\n *     public TreeNode right;\n *     public TreeNode(int x) { val = x; }\n * }\n */\npublic class Solution {\n    public IList<int> PostorderTraversal(TreeNode root) {\n        \n    }\n}"
    },
    {
      "lang": "JavaScript",
      "code": "/**\n * Definition for a binary tree node.\n * function TreeNode(val) {\n *     this.val = val;\n *     this.left = this.right = null;\n * }\n */\n/**\n * @param {TreeNode} root\n * @return {number[]}\n */\nvar postorderTraversal = function(root) {\n    \n};"
    },
    {
      "lang": "Ruby",
      "code": "# Definition for a binary tree node.\n# class TreeNode\n#     attr_accessor :val, :left, :right\n#     def initialize(val)\n#         @val = val\n#         @left, @right = nil, nil\n#     end\n# end\n\n# @param {TreeNode} root\n# @return {Integer[]}\ndef postorder_traversal(root)\n    \nend"
    },
    {
      "lang": "Swift",
      "code": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     public var val: Int\n *     public var left: TreeNode?\n *     public var right: TreeNode?\n *     public init(_ val: Int) {\n *         self.val = val\n *         self.left = nil\n *         self.right = nil\n *     }\n * }\n */\nclass Solution {\n    func postorderTraversal(_ root: TreeNode?) -> [Int] {\n        \n    }\n}"
    },
    {
      "lang": "Go",
      "code": "/**\n * Definition for a binary tree node.\n * type TreeNode struct {\n *     Val int\n *     Left *TreeNode\n *     Right *TreeNode\n * }\n */\nfunc postorderTraversal(root *TreeNode) []int {\n    \n}"
    },
    {
      "lang": "Scala",
      "code": "/**\n * Definition for a binary tree node.\n * class TreeNode(var _value: Int) {\n *   var value: Int = _value\n *   var left: TreeNode = null\n *   var right: TreeNode = null\n * }\n */\nobject Solution {\n    def postorderTraversal(root: TreeNode): List[Int] = {\n        \n    }\n}"
    },
    {
      "lang": "Kotlin",
      "code": "/**\n * Example:\n * var ti = TreeNode(5)\n * var v = ti.`val`\n * Definition for a binary tree node.\n * class TreeNode(var `val`: Int) {\n *     var left: TreeNode? = null\n *     var right: TreeNode? = null\n * }\n */\nclass Solution {\n    fun postorderTraversal(root: TreeNode?): List<Int> {\n        \n    }\n}"
    },
    {
      "lang": "Rust",
      "code": "// Definition for a binary tree node.\n// #[derive(Debug, PartialEq, Eq)]\n// pub struct TreeNode {\n//   pub val: i32,\n//   pub left: Option<Rc<RefCell<TreeNode>>>,\n//   pub right: Option<Rc<RefCell<TreeNode>>>,\n// }\n// \n// impl TreeNode {\n//   #[inline]\n//   pub fn new(val: i32) -> Self {\n//     TreeNode {\n//       val,\n//       left: None,\n//       right: None\n//     }\n//   }\n// }\nuse std::rc::Rc;\nuse std::cell::RefCell;\nimpl Solution {\n    pub fn postorder_traversal(root: Option<Rc<RefCell<TreeNode>>>) -> Vec<i32> {\n        \n    }\n}"
    },
    {
      "lang": "PHP",
      "code": "/**\n * Definition for a binary tree node.\n * class TreeNode {\n *     public $val = null;\n *     public $left = null;\n *     public $right = null;\n *     function __construct($value) { $this->val = $value; }\n * }\n */\nclass Solution {\n\n    /**\n     * @param TreeNode $root\n     * @return Integer[]\n     */\n    function postorderTraversal($root) {\n        \n    }\n}"
    }
  ],
  "stats": "{\"totalAccepted\": \"313.4K\", \"totalSubmission\": \"608.6K\", \"totalAcceptedRaw\": 313425, \"totalSubmissionRaw\": 608563, \"acRate\": \"51.5%\"}",
  "hints": [],
  "solution": {
    "id": "585",
    "canSeeDetail": true,
    "url": "/articles/binary-tree-postorder-transversal/",
    "content": "[TOC]\r\n\r\n## Solution\r\n\r\n---\r\n\r\n#### How to transverse the tree\r\n\r\n\r\nThere are two general strategies to transverse a tree:\r\n\r\n- *Breadth First Search* (`BFS`)\r\n\r\n    We scan through the tree level by level, following the order of height,\r\n    from top to bottom. The nodes on higher level would be visited before\r\n    the ones with lower levels.\r\n     \r\n- *Depth First Search* (`DFS`)\r\n\r\n    In this strategy, we adopt the `depth` as the priority, so that one\r\n    would start from a root and reach all the way down to certain leaf,\r\n    and then back to root to reach another branch.\r\n\r\n    The DFS strategy can further be distinguished as\r\n    `preorder`, `inorder`, and `postorder` depending on the relative order\r\n    among the root node, left node and right node.\r\n    \r\nOn the following figure the nodes are numerated in the order you visit them,\r\nplease follow ```1-2-3-4-5``` to compare different strategies.\r\n\r\n<center><img src=\"../Figures/145_transverse.png\" width=\"550px\" /></center>\r\n\r\nHere the problem is to implement postorder transversal using iterations.\r\n<br />\r\n<br />\r\n\r\n\r\n---\r\n#### Approach 1: Iterations\r\n\r\n**Algorithm**\r\n\r\nFirst of all, here is the definition of the ```TreeNode``` which we would use\r\nin the following implementation.\r\n\r\n<iframe src=\"https://leetcode.com/playground/Z7ycWmHJ/shared\" frameBorder=\"0\" width=\"100%\" height=\"225\" name=\"Z7ycWmHJ\"></iframe>\r\n\r\nLet's start from the root and then at each iteration \r\npop the current node out of the stack and\r\npush its child nodes. \r\nIn the implemented strategy we push nodes into stack following the order ```Top->Bottom``` and ```Left->Right```.\r\nSince DFS postorder transversal is ```Bottom->Top``` and ```Left->Right``` the output list\r\nshould be reverted after the end of loop.\r\n\r\n<iframe src=\"https://leetcode.com/playground/YRFwoGpj/shared\" frameBorder=\"0\" width=\"100%\" height=\"429\" name=\"YRFwoGpj\"></iframe>\r\n\r\n\r\n\r\n**Complexity Analysis**\r\n\r\n* Time complexity : we visit each node exactly once, thus the \r\ntime complexity is $$\\mathcal{O}(N)$$,\r\nwhere $$N$$ is the number of nodes, *i.e.* the size of tree.\r\n\r\n* Space complexity : depending on the tree structure, \r\nwe could keep up to the entire tree, therefore, the space complexity is $$\\mathcal{O}(N)$$.\r\n\r\nAnalysis written by @[liaison](https://leetcode.com/liaison/)\r\nand @[andvary](https://leetcode.com/andvary/)",
    "contentTypeId": "107",
    "rating": {
      "id": "571",
      "count": 18,
      "average": 3.5,
      "userRating": null
    }
  },
  "status": null,
  "sampleTestCase": "[1,null,2,3]",
  "metaData": "{\r\n  \"name\": \"postorderTraversal\",\r\n  \"params\": [\r\n    {\r\n      \"name\": \"root\",\r\n      \"type\": \"TreeNode\"\r\n    }\r\n  ],\r\n  \"return\": {\r\n    \"type\": \"list<integer>\",\r\n    \"dealloc\": true\r\n  }\r\n}",
  "judgerAvailable": true,
  "judgeType": "large",
  "mysqlSchemas": [],
  "enableRunCode": true,
  "enableTestMode": false,
  "libraryUrl": null
}
