{
  "questionId": "173",
  "questionFrontendId": "173",
  "boundTopicId": null,
  "title": "Binary Search Tree Iterator",
  "titleSlug": "binary-search-tree-iterator",
  "categoryTitle": "Algorithms",
  "content": "<p>Implement an iterator over a binary search tree (BST). Your iterator will be initialized with the root node of a BST.</p>\r\n\r\n<p>Calling <code>next()</code> will return the next smallest number in the BST.</p>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<ul>\r\n</ul>\r\n\r\n<p><strong>Example:</strong></p>\r\n\r\n<p><strong><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2018/12/25/bst-tree.png\" style=\"width: 189px; height: 178px;\" /></strong></p>\r\n\r\n<pre>\r\nBSTIterator iterator = new BSTIterator(root);\r\niterator.next();    // return 3\r\niterator.next();    // return 7\r\niterator.hasNext(); // return true\r\niterator.next();    // return 9\r\niterator.hasNext(); // return true\r\niterator.next();    // return 15\r\niterator.hasNext(); // return true\r\niterator.next();    // return 20\r\niterator.hasNext(); // return false\r\n</pre>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p><b>Note:</b></p>\r\n\r\n<ul>\r\n\t<li><code>next()</code> and <code>hasNext()</code> should run in average O(1) time and uses O(<i>h</i>) memory, where <i>h</i> is the height of the tree.</li>\r\n\t<li>You may assume that&nbsp;<code>next()</code>&nbsp;call&nbsp;will always be valid, that is, there will be at least a next smallest number in the BST when <code>next()</code> is called.</li>\r\n</ul>\r\n",
  "isPaidOnly": false,
  "difficulty": "Medium",
  "likes": 1855,
  "dislikes": 256,
  "isLiked": null,
  "similarQuestions": "[{\"title\": \"Binary Tree Inorder Traversal\", \"titleSlug\": \"binary-tree-inorder-traversal\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Flatten 2D Vector\", \"titleSlug\": \"flatten-2d-vector\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Zigzag Iterator\", \"titleSlug\": \"zigzag-iterator\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Peeking Iterator\", \"titleSlug\": \"peeking-iterator\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Inorder Successor in BST\", \"titleSlug\": \"inorder-successor-in-bst\", \"difficulty\": \"Medium\", \"translatedTitle\": null}]",
  "contributors": [
    {
      "username": "shtian",
      "profileUrl": "/shtian/",
      "avatarUrl": "https://www.gravatar.com/avatar/258979a79ee1a54a2a14ce2db5389ca1.png?s=200"
    }
  ],
  "topicTags": [
    {
      "name": "Stack",
      "slug": "stack"
    },
    {
      "name": "Tree",
      "slug": "tree"
    },
    {
      "name": "Design",
      "slug": "design"
    }
  ],
  "companyTagStats": "{\"1\": [{\"taggedByAdmin\": true, \"name\": \"Facebook\", \"slug\": \"facebook\", \"timesEncountered\": 20}, {\"taggedByAdmin\": true, \"name\": \"Google\", \"slug\": \"google\", \"timesEncountered\": 5}, {\"taggedByAdmin\": false, \"name\": \"Amazon\", \"slug\": \"amazon\", \"timesEncountered\": 4}, {\"taggedByAdmin\": false, \"name\": \"Uber\", \"slug\": \"uber\", \"timesEncountered\": 3}, {\"taggedByAdmin\": false, \"name\": \"Oracle\", \"slug\": \"oracle\", \"timesEncountered\": 3}, {\"taggedByAdmin\": false, \"name\": \"Bloomberg\", \"slug\": \"bloomberg\", \"timesEncountered\": 3}, {\"taggedByAdmin\": true, \"name\": \"LinkedIn\", \"slug\": \"linkedin\", \"timesEncountered\": 2}, {\"taggedByAdmin\": false, \"name\": \"eBay\", \"slug\": \"ebay\", \"timesEncountered\": 2}, {\"taggedByAdmin\": false, \"name\": \"Apple\", \"slug\": \"apple\", \"timesEncountered\": 2}, {\"taggedByAdmin\": false, \"name\": \"Qualtrics\", \"slug\": \"qualtrics\", \"timesEncountered\": 2}], \"3\": [{\"taggedByAdmin\": false, \"name\": \"Cloudera\", \"slug\": \"cloudera\", \"timesEncountered\": 3}, {\"taggedByAdmin\": false, \"name\": \"AppDynamics\", \"slug\": \"appdynamics\", \"timesEncountered\": 2}, {\"taggedByAdmin\": false, \"name\": \"Cisco\", \"slug\": \"cisco\", \"timesEncountered\": 2}, {\"taggedByAdmin\": false, \"name\": \"Alibaba\", \"slug\": \"alibaba\", \"timesEncountered\": 2}, {\"taggedByAdmin\": false, \"name\": \"Splunk\", \"slug\": \"splunk\", \"timesEncountered\": 2}], \"2\": [{\"taggedByAdmin\": true, \"name\": \"Microsoft\", \"slug\": \"microsoft\", \"timesEncountered\": 5}]}",
  "codeSnippets": [
    {
      "lang": "C++",
      "code": "/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\n * };\n */\nclass BSTIterator {\npublic:\n    BSTIterator(TreeNode* root) {\n        \n    }\n    \n    /** @return the next smallest number */\n    int next() {\n        \n    }\n    \n    /** @return whether we have a next smallest number */\n    bool hasNext() {\n        \n    }\n};\n\n/**\n * Your BSTIterator object will be instantiated and called as such:\n * BSTIterator* obj = new BSTIterator(root);\n * int param_1 = obj->next();\n * bool param_2 = obj->hasNext();\n */"
    },
    {
      "lang": "Java",
      "code": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode(int x) { val = x; }\n * }\n */\nclass BSTIterator {\n\n    public BSTIterator(TreeNode root) {\n        \n    }\n    \n    /** @return the next smallest number */\n    public int next() {\n        \n    }\n    \n    /** @return whether we have a next smallest number */\n    public boolean hasNext() {\n        \n    }\n}\n\n/**\n * Your BSTIterator object will be instantiated and called as such:\n * BSTIterator obj = new BSTIterator(root);\n * int param_1 = obj.next();\n * boolean param_2 = obj.hasNext();\n */"
    },
    {
      "lang": "Python",
      "code": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, x):\n#         self.val = x\n#         self.left = None\n#         self.right = None\n\nclass BSTIterator(object):\n\n    def __init__(self, root):\n        \"\"\"\n        :type root: TreeNode\n        \"\"\"\n        \n\n    def next(self):\n        \"\"\"\n        @return the next smallest number\n        :rtype: int\n        \"\"\"\n        \n\n    def hasNext(self):\n        \"\"\"\n        @return whether we have a next smallest number\n        :rtype: bool\n        \"\"\"\n        \n\n\n# Your BSTIterator object will be instantiated and called as such:\n# obj = BSTIterator(root)\n# param_1 = obj.next()\n# param_2 = obj.hasNext()"
    },
    {
      "lang": "Python3",
      "code": "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, x):\n#         self.val = x\n#         self.left = None\n#         self.right = None\n\nclass BSTIterator:\n\n    def __init__(self, root: TreeNode):\n        \n\n    def next(self) -> int:\n        \"\"\"\n        @return the next smallest number\n        \"\"\"\n        \n\n    def hasNext(self) -> bool:\n        \"\"\"\n        @return whether we have a next smallest number\n        \"\"\"\n        \n\n\n# Your BSTIterator object will be instantiated and called as such:\n# obj = BSTIterator(root)\n# param_1 = obj.next()\n# param_2 = obj.hasNext()"
    },
    {
      "lang": "C",
      "code": "/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     struct TreeNode *left;\n *     struct TreeNode *right;\n * };\n */\n\n\n\ntypedef struct {\n    \n} BSTIterator;\n\n\nBSTIterator* bSTIteratorCreate(struct TreeNode* root) {\n    \n}\n\n/** @return the next smallest number */\nint bSTIteratorNext(BSTIterator* obj) {\n  \n}\n\n/** @return whether we have a next smallest number */\nbool bSTIteratorHasNext(BSTIterator* obj) {\n  \n}\n\nvoid bSTIteratorFree(BSTIterator* obj) {\n    \n}\n\n/**\n * Your BSTIterator struct will be instantiated and called as such:\n * BSTIterator* obj = bSTIteratorCreate(root);\n * int param_1 = bSTIteratorNext(obj);\n \n * bool param_2 = bSTIteratorHasNext(obj);\n \n * bSTIteratorFree(obj);\n*/"
    },
    {
      "lang": "C#",
      "code": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     public int val;\n *     public TreeNode left;\n *     public TreeNode right;\n *     public TreeNode(int x) { val = x; }\n * }\n */\npublic class BSTIterator {\n\n    public BSTIterator(TreeNode root) {\n        \n    }\n    \n    /** @return the next smallest number */\n    public int Next() {\n        \n    }\n    \n    /** @return whether we have a next smallest number */\n    public bool HasNext() {\n        \n    }\n}\n\n/**\n * Your BSTIterator object will be instantiated and called as such:\n * BSTIterator obj = new BSTIterator(root);\n * int param_1 = obj.Next();\n * bool param_2 = obj.HasNext();\n */"
    },
    {
      "lang": "JavaScript",
      "code": "/**\n * Definition for a binary tree node.\n * function TreeNode(val) {\n *     this.val = val;\n *     this.left = this.right = null;\n * }\n */\n/**\n * @param {TreeNode} root\n */\nvar BSTIterator = function(root) {\n    \n};\n\n/**\n * @return the next smallest number\n * @return {number}\n */\nBSTIterator.prototype.next = function() {\n    \n};\n\n/**\n * @return whether we have a next smallest number\n * @return {boolean}\n */\nBSTIterator.prototype.hasNext = function() {\n    \n};\n\n/** \n * Your BSTIterator object will be instantiated and called as such:\n * var obj = new BSTIterator(root)\n * var param_1 = obj.next()\n * var param_2 = obj.hasNext()\n */"
    },
    {
      "lang": "Ruby",
      "code": "# Definition for a binary tree node.\n# class TreeNode\n#     attr_accessor :val, :left, :right\n#     def initialize(val)\n#         @val = val\n#         @left, @right = nil, nil\n#     end\n# end\n\nclass BSTIterator\n\n=begin\n    :type root: TreeNode\n=end\n    def initialize(root)\n        \n    end\n\n\n=begin\n    @return the next smallest number\n    :rtype: Integer\n=end\n    def next()\n        \n    end\n\n\n=begin\n    @return whether we have a next smallest number\n    :rtype: Boolean\n=end\n    def has_next()\n        \n    end\n\n\nend\n\n# Your BSTIterator object will be instantiated and called as such:\n# obj = BSTIterator.new(root)\n# param_1 = obj.next()\n# param_2 = obj.has_next()"
    },
    {
      "lang": "Swift",
      "code": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     public var val: Int\n *     public var left: TreeNode?\n *     public var right: TreeNode?\n *     public init(_ val: Int) {\n *         self.val = val\n *         self.left = nil\n *         self.right = nil\n *     }\n * }\n */\n\nclass BSTIterator {\n\n    init(_ root: TreeNode?) {\n        \n    }\n    \n    /** @return the next smallest number */\n    func next() -> Int {\n        \n    }\n    \n    /** @return whether we have a next smallest number */\n    func hasNext() -> Bool {\n        \n    }\n}\n\n/**\n * Your BSTIterator object will be instantiated and called as such:\n * let obj = BSTIterator(root)\n * let ret_1: Int = obj.next()\n * let ret_2: Bool = obj.hasNext()\n */"
    },
    {
      "lang": "Go",
      "code": "/**\n * Definition for a binary tree node.\n * type TreeNode struct {\n *     Val int\n *     Left *TreeNode\n *     Right *TreeNode\n * }\n */\ntype BSTIterator struct {\n    \n}\n\n\nfunc Constructor(root *TreeNode) BSTIterator {\n    \n}\n\n\n/** @return the next smallest number */\nfunc (this *BSTIterator) Next() int {\n    \n}\n\n\n/** @return whether we have a next smallest number */\nfunc (this *BSTIterator) HasNext() bool {\n    \n}\n\n\n/**\n * Your BSTIterator object will be instantiated and called as such:\n * obj := Constructor(root);\n * param_1 := obj.Next();\n * param_2 := obj.HasNext();\n */"
    },
    {
      "lang": "Scala",
      "code": "/**\n * Definition for a binary tree node.\n * class TreeNode(var _value: Int) {\n *   var value: Int = _value\n *   var left: TreeNode = null\n *   var right: TreeNode = null\n * }\n */\nclass BSTIterator(_root: TreeNode) {\n\n    /** @return the next smallest number */\n    def next(): Int = {\n        \n    }\n\n    /** @return whether we have a next smallest number */\n    def hasNext(): Boolean = {\n        \n    }\n\n}\n\n/**\n * Your BSTIterator object will be instantiated and called as such:\n * var obj = new BSTIterator(root)\n * var param_1 = obj.next()\n * var param_2 = obj.hasNext()\n */"
    },
    {
      "lang": "Kotlin",
      "code": "/**\n * Example:\n * var ti = TreeNode(5)\n * var v = ti.`val`\n * Definition for a binary tree node.\n * class TreeNode(var `val`: Int) {\n *     var left: TreeNode? = null\n *     var right: TreeNode? = null\n * }\n */\nclass BSTIterator(root: TreeNode?) {\n\n    /** @return the next smallest number */\n    fun next(): Int {\n        \n    }\n\n    /** @return whether we have a next smallest number */\n    fun hasNext(): Boolean {\n        \n    }\n\n}\n\n/**\n * Your BSTIterator object will be instantiated and called as such:\n * var obj = BSTIterator(root)\n * var param_1 = obj.next()\n * var param_2 = obj.hasNext()\n */"
    },
    {
      "lang": "Rust",
      "code": "// Definition for a binary tree node.\n// #[derive(Debug, PartialEq, Eq)]\n// pub struct TreeNode {\n//   pub val: i32,\n//   pub left: Option<Rc<RefCell<TreeNode>>>,\n//   pub right: Option<Rc<RefCell<TreeNode>>>,\n// }\n// \n// impl TreeNode {\n//   #[inline]\n//   pub fn new(val: i32) -> Self {\n//     TreeNode {\n//       val,\n//       left: None,\n//       right: None\n//     }\n//   }\n// }\nstruct BSTIterator {\n\n}\n\n\n/** \n * `&self` means the method takes an immutable reference.\n * If you need a mutable reference, change it to `&mut self` instead.\n */\nimpl BSTIterator {\n\n    fn new(root: Option<Rc<RefCell<TreeNode>>>) -> Self {\n        \n    }\n    \n    /** @return the next smallest number */\n    fn next(&self) -> i32 {\n        \n    }\n    \n    /** @return whether we have a next smallest number */\n    fn has_next(&self) -> bool {\n        \n    }\n}\n\n/**\n * Your BSTIterator object will be instantiated and called as such:\n * let obj = BSTIterator::new(root);\n * let ret_1: i32 = obj.next();\n * let ret_2: bool = obj.has_next();\n */"
    },
    {
      "lang": "PHP",
      "code": "/**\n * Definition for a binary tree node.\n * class TreeNode {\n *     public $val = null;\n *     public $left = null;\n *     public $right = null;\n *     function __construct($value) { $this->val = $value; }\n * }\n */\nclass BSTIterator {\n    /**\n     * @param TreeNode $root\n     */\n    function __construct($root) {\n        \n    }\n  \n    /**\n     * @return the next smallest number\n     * @return Integer\n     */\n    function next() {\n        \n    }\n  \n    /**\n     * @return whether we have a next smallest number\n     * @return Boolean\n     */\n    function hasNext() {\n        \n    }\n}\n\n/**\n * Your BSTIterator object will be instantiated and called as such:\n * $obj = BSTIterator($root);\n * $ret_1 = $obj->next();\n * $ret_2 = $obj->hasNext();\n */"
    }
  ],
  "stats": "{\"totalAccepted\": \"250.1K\", \"totalSubmission\": \"479.5K\", \"totalAcceptedRaw\": 250063, \"totalSubmissionRaw\": 479482, \"acRate\": \"52.2%\"}",
  "hints": [],
  "solution": {
    "id": "737",
    "canSeeDetail": true,
    "url": "/articles/binary-search-tree-iterator/",
    "content": "[TOC]\n\n## Solution\n\nBefore looking at the solutions for this problem, let's try and boil down what the problem statement essentially asks us to do. So, we need to implement an iterator class with two functions namely `next()` and `hasNext()`. The `hasNext()` function returns a boolean value indicating whether there are any more elements left in the binary search tree or not. The `next()` function returns the next smallest element in the BST. Therefore, the first time we call the `next()` function, it should return the smallest element in the BST and likewise, when we call `next()` for the very last time, it should return the largest element in the BST. \n\nYou might be wondering as to what could be the use case for an iterator. Essentially, an iterator can be used to *iterate over* any container object. For our purpose, the container object is a binary search tree. If such an iterator is defined, then the traversal logic can be abstracted out and we can simply make use of the iterator to process the elements in a certain order.\n\n```python\n1. new_iterator = BSTIterator(root);\n2. while (new_iterator.hasNext())\n3.     process(new_iterator.next());\n```\n\nNow that we know the motivation behind designing a good iterator class for a data structure, let's take a look at another interesting aspect about the iterator that we have to build for this problem. Usually, an iterator simply goes over each of the elements of the container one by one. For the BST, we want the iterator to return elements in an ascending order.\n\n> An important property of the binary search tree is that the inorder traversal of a BST gives us the elements in a sorted order. Thus, the inorder traversal will be the core of the solutions that we will look ahead.\n\n!?!../Documents/173_anim.json:770,405!?!\n\n---\n\n#### Approach 1: Flattening the BST\n\n**Intuition**\n\nIn computer programming, an iterator is an object that enables a programmer to traverse a container, particularly lists. This is the Wikipedia definition of an iterator. Naturally, the easiest way to implement an iterator would be on an array like container interface. So, if we had an array, all we would need is a pointer or an index and we could easily implement the two required functions `next()` and `hasNext()`.\n\nHence, the first approach that we will look at is based on this idea. We will be using additional memory and we will flatten the binary search tree into an array. Since we need the elements to be in a sorted order, we will do an inorder traversal over the tree and store the elements in a new array and then build the iterator functions using this new array.\n\n**Algorithm**\n\n1. Initialize an empty array that will contain the nodes of the binary search tree in the sorted order. \n2. We traverse the binary search tree in the inorder fashion and for each node that we process, we add it to our array `nodes`. Note that before processing a node, its left subtree has to be processed (or recursed upon) and after processing a node, its right subtree has to be recursed upon.\n3. Once we have all the nodes in an array, we simply need a pointer or an index in that array to implement the two functions `next` and `hasNext`. Whenever there's a call to `hasNext`, we simply check if the index has reached the end of the array or not. For the call to `next` function, we simply return the element pointed by the index. Also, after a the `next` function call is made, we have to move the index one step forward to simulate the progress of our iterator. \n\n<center>\n<img src=\"../Figures/173/appr_1.png\"></center>\n\n<iframe src=\"https://leetcode.com/playground/wjgc9wdu/shared\" frameBorder=\"0\" width=\"100%\" height=\"500\" name=\"wjgc9wdu\"></iframe>\n\n**Complexity analysis**\n\n* Time complexity : $$O(N)$$ is the time taken by the constructor for the iterator. The problem statement only asks us to analyze the complexity of the two functions, however, when implementing a class, it's important to also note the time it takes to initialize a new object of the class and in this case it would be linear in terms of the number of nodes in the BST. In addition to the space occupied by the new array we initialized, the recursion stack for the inorder traversal also occupies space but that is limited to $$O(h)$$ where $$h$$ is the height of the tree.\n    - `next()` would take $$O(1)$$ \n    - `hasNext()` would take $$O(1)$$\n* Space complexity : $$O(N)$$ since we create a new array to contain all the nodes of the BST. This doesn't comply with the requirement specified in the problem statement that the maximum space complexity of either of the functions should be $$O(h)$$ where $$h$$ is the height of the tree and for a well balanced BST, the height is usually $$logN$$. So, we get great time complexities but we had to compromise on the space. Note that the new array is used for both the function calls and hence the space complexity for both the calls is $$O(N)$$.\n<br/>\n<br/>\n\n---\n\n#### Approach 2: Controlled Recursion\n\n**Intuition**\n\nThe approach we saw earlier uses space which is linear in the number of nodes in the binary search tree. However, the reason we had to resort to such an approach was because we can control the iteration over the array. We can't really *pause* a recursion in between and then start it off sometime later. \n\n>However, if we could simulate a controlled recursion for an inorder traversal, we wouldn't really need to use any additional space other than the space used by the stack for our recursion simulation. \n\nSo, this approach essentially uses a custom stack to simulate the inorder traversal i.e. we will be taking an iterative approach to inorder traversal rather than going with the recursive approach and in doing so, we will be able to easily implement the two function calls without any other additional space. \n\nThings however, do get a bit complicated as far as the time complexity of the two operations is concerned and that is where we will spend a little bit of time to understand if this approach complies with all the asymptotic complexity requirements of the question. Let's move on to the algorithm for now to look at this idea more concretely.\n\n**Algorithm**\n\n1. Initialize an empty stack `S` which will be used to simulate the inorder traversal for our binary search tree. Note that we will be following the same approach for inorder traversal as before except that now we will be using our own stack rather than the system stack. Since we are using a custom data structure, we can *pause* and *resume* the recursion at will.\n2. Let's also consider a helper function that we will be calling again and again in the implementation. This function, called `_inorder_left` will essentially add all the nodes in the leftmost branch of the tree rooted at the given node `root` to the stack and it will keep on doing so until there is no `left` child of the `root` node. Something like the following code:\n                \n      <pre>def inorder_left(root):\n      while (root):\n        S.append(root)\n        root = root.left</pre>\n        \n      For a given node `root`, the next smallest element will *always* be the leftmost element in its tree. So, for a given root node, we keep on following the leftmost branch until we reach a node which doesn't have a left child and that will be the next smallest element. For the root of our BST, this leftmost node would be the smallest node in the tree. Rest of the nodes are added to the stack because they are pending processing. Try and relate this with a dry run of a simple recursive inorder traversal and things will make a bit more sense. \n      \n3. The first time `next()` function call is made, the smallest element of the BST has to be returned and then our simulated recursion has to move one step forward i.e. move onto the next smallest element in the BST. The invariant that will be maintained in this algorithm is that the stack top always contains the element to be returned for the `next()` function call. However, there is additional work that needs to be done to maintain that invariant. It's very easy to implement the `hasNext()` function since all we need to check is if the stack is empty or not. So, we will only focus on the `next()` call from now. \n\n4. Initially, given the root node of the BST, we call the function `_inorder_left` and that ensures our invariant holds. Let's see this first step with an example.\n    \n    <center>\n    <img src=\"../Figures/173/approach_2-1.png\" width=\"700\"></center>\n    \n5. Suppose we get a call to the `next()` function. The node which we have to return i.e. the next smallest element in the binary search tree iterator is the one sitting at the top of our stack. So, for the example above, that node would be `2` which is the correct value. Now, there are two possibilities that we have to deal with:\n      * One is where the node at the top of the stack is actually a leaf node. This is the best case and here we don't have to do anything. Simply pop the node off the stack and return its value. So, this would be a constant time operation.\n      * Second is where the node has a `right` child. We don't need to check for the left child because of the way we have added nodes onto the stack. The topmost node either won't have a `left` child or would already have the `left` subtree processed. If it has a `right` child, then we call our helper function on the node's right child. This would comparatively be a costly operation depending upon the structure of the tree.\n      \n        <center>\n        <img src=\"../Figures/173/approach_2-2.png\" width=\"700\"></center>\n        \n6. We keep on maintaining the invariant this way in the function call for `next` and this way we will always be able to return the next smallest element in the BST from the top of the stack. Again, it's important to understand that obtaining the next smallest element doesn't take much time. However, some time is spent in maintaining the invariant that the stack top will *always* have the node we are looking for.       \n\n<iframe src=\"https://leetcode.com/playground/Mu4q3jYZ/shared\" frameBorder=\"0\" width=\"100%\" height=\"500\" name=\"Mu4q3jYZ\"></iframe>\n\n**Complexity analysis**        \n\n* Time complexity : The time complexity for this approach is very interesting to analyze. Let's look at the complexities for both the functions in the class:\n    - `hasNext` is the easier of the lot since all we do in this is to return true if there are any elements left in the stack. Otherwise, we return false. So clearly, this is an $$O(1)$$ operation every time. Let's look at the more complicated function now to see if we satisfy all the requirements in the problem statement\n    - `next` involves two major operations. One is where we pop an element from the stack which becomes the next smallest element to return. This is a $$O(1)$$ operation. However, we then make a  call to our helper function `_inorder_left` which iterates over a bunch of nodes. This is clearly a linear time operation i.e. $$O(N)$$ in the worst case. This is true. \n    \n        >However, the important thing to note here is that we only make such a call for nodes which have a right child. Otherwise, we simply return. Also, even if we end up calling the helper function, it won't always process N nodes. They will be much lesser. Only if we have a skewed tree would there be N nodes for the root. But that is the only node for which we would call the helper function. \n        \n        Thus, the amortized (average) time complexity for this function would still be $$O(1)$$ which is what the question asks for. We don't need to have a solution which gives constant time operations for *every* call. We need that complexity on average and that is what we get. \n      \n* Space complexity: The space complexity is $$O(h)$$ which is occupied by our custom stack for simulating the inorder traversal. Again, we satisfy the space requirements as well as specified in the problem statement.\n<br />\n\n---\n\nAnalysis written by: [@sachinmalhotra1993](https://leetcode.com/sachinmalhotra1993).",
    "contentTypeId": "107",
    "rating": {
      "id": "722",
      "count": 85,
      "average": 4.929,
      "userRating": null
    }
  },
  "status": null,
  "sampleTestCase": "[\"BSTIterator\",\"next\",\"next\",\"hasNext\",\"next\",\"hasNext\",\"next\",\"hasNext\",\"next\",\"hasNext\"]\n[[[7,3,15,null,null,9,20]],[null],[null],[null],[null],[null],[null],[null],[null],[null]]",
  "metaData": "{\r\n    \"classname\": \"BSTIterator\",\r\n    \"maxbytesperline\": 200000,\r\n    \"constructor\": {\r\n        \"params\": [\r\n            { \"type\": \"TreeNode\",\r\n              \"name\": \"root\"\r\n            }\r\n            ]\r\n    },\r\n    \"methods\": [\r\n        {\r\n            \"name\" : \"next\",\r\n            \"params\": [],\r\n            \"comment\": \"@return the next smallest number\",\r\n            \"return\": {\r\n                \"type\": \"integer\"\r\n            }\r\n        },\r\n        {\r\n            \"name\" : \"hasNext\",\r\n            \"params\": [],\r\n            \"comment\": \"@return whether we have a next smallest number\",\r\n            \"return\": {\r\n                \"type\": \"boolean\"\r\n            }\r\n        }\r\n    ],\r\n    \"systemdesign\": true,\r\n    \"params\": [\r\n        {\r\n            \"name\": \"inputs\",\r\n            \"type\": \"integer[]\"\r\n        },\r\n        {\r\n            \"name\": \"inputs\",\r\n            \"type\": \"integer[]\"\r\n        }\r\n    ],\r\n    \"return\": {\r\n        \"type\": \"integer[]\",\r\n        \"dealloc\": true\r\n    }\r\n}",
  "judgerAvailable": true,
  "judgeType": "large",
  "mysqlSchemas": [],
  "enableRunCode": true,
  "enableTestMode": false,
  "libraryUrl": null
}
