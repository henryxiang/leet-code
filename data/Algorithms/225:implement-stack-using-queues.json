{
  "questionId": "225",
  "questionFrontendId": "225",
  "boundTopicId": null,
  "title": "Implement Stack using Queues",
  "titleSlug": "implement-stack-using-queues",
  "categoryTitle": "Algorithms",
  "content": "<p>Implement the following operations of a stack using queues.</p>\r\n\r\n<ul>\r\n\t<li>push(x) -- Push element x onto stack.</li>\r\n\t<li>pop() -- Removes the element on top of the stack.</li>\r\n\t<li>top() -- Get the top element.</li>\r\n\t<li>empty() -- Return whether the stack is empty.</li>\r\n</ul>\r\n\r\n<p><b>Example:</b></p>\r\n\r\n<pre>\r\nMyStack stack = new MyStack();\r\n\r\nstack.push(1);\r\nstack.push(2);  \r\nstack.top();   // returns 2\r\nstack.pop();   // returns 2\r\nstack.empty(); // returns false</pre>\r\n\r\n<p><b>Notes:</b></p>\r\n\r\n<ul>\r\n\t<li>You must use <i>only</i> standard operations of a queue -- which means only <code>push to back</code>, <code>peek/pop from front</code>, <code>size</code>, and <code>is empty</code> operations are valid.</li>\r\n\t<li>Depending on your language, queue may not be supported natively. You may simulate a queue by using a list or deque (double-ended queue), as long as you use only standard operations of a queue.</li>\r\n\t<li>You may assume that all operations are valid (for example, no pop or top operations will be called on an empty stack).</li>\r\n</ul>\r\n",
  "isPaidOnly": false,
  "difficulty": "Easy",
  "likes": 446,
  "dislikes": 493,
  "isLiked": null,
  "similarQuestions": "[{\"title\": \"Implement Queue using Stacks\", \"titleSlug\": \"implement-queue-using-stacks\", \"difficulty\": \"Easy\", \"translatedTitle\": null}]",
  "contributors": [
    {
      "username": "jianchao-li",
      "profileUrl": "/jianchao-li/",
      "avatarUrl": "https://assets.leetcode.com/users/jianchaolifighter/avatar_1529298385.png"
    }
  ],
  "topicTags": [
    {
      "name": "Stack",
      "slug": "stack"
    },
    {
      "name": "Design",
      "slug": "design"
    }
  ],
  "companyTagStats": "{\"3\": [{\"taggedByAdmin\": false, \"name\": \"Apple\", \"slug\": \"apple\", \"timesEncountered\": 2}, {\"taggedByAdmin\": false, \"name\": \"Oracle\", \"slug\": \"oracle\", \"timesEncountered\": 2}, {\"taggedByAdmin\": true, \"name\": \"Bloomberg\", \"slug\": \"bloomberg\", \"timesEncountered\": 0}], \"1\": [{\"taggedByAdmin\": false, \"name\": \"Microsoft\", \"slug\": \"microsoft\", \"timesEncountered\": 4}, {\"taggedByAdmin\": false, \"name\": \"Amazon\", \"slug\": \"amazon\", \"timesEncountered\": 3}, {\"taggedByAdmin\": false, \"name\": \"Citadel\", \"slug\": \"citadel\", \"timesEncountered\": 2}], \"2\": [{\"taggedByAdmin\": false, \"name\": \"Twilio\", \"slug\": \"twilio\", \"timesEncountered\": 3}, {\"taggedByAdmin\": false, \"name\": \"Mathworks\", \"slug\": \"mathworks\", \"timesEncountered\": 2}, {\"taggedByAdmin\": false, \"name\": \"Yahoo\", \"slug\": \"yahoo\", \"timesEncountered\": 2}]}",
  "codeSnippets": [
    {
      "lang": "C++",
      "code": "class MyStack {\npublic:\n    /** Initialize your data structure here. */\n    MyStack() {\n        \n    }\n    \n    /** Push element x onto stack. */\n    void push(int x) {\n        \n    }\n    \n    /** Removes the element on top of the stack and returns that element. */\n    int pop() {\n        \n    }\n    \n    /** Get the top element. */\n    int top() {\n        \n    }\n    \n    /** Returns whether the stack is empty. */\n    bool empty() {\n        \n    }\n};\n\n/**\n * Your MyStack object will be instantiated and called as such:\n * MyStack* obj = new MyStack();\n * obj->push(x);\n * int param_2 = obj->pop();\n * int param_3 = obj->top();\n * bool param_4 = obj->empty();\n */"
    },
    {
      "lang": "Java",
      "code": "class MyStack {\n\n    /** Initialize your data structure here. */\n    public MyStack() {\n        \n    }\n    \n    /** Push element x onto stack. */\n    public void push(int x) {\n        \n    }\n    \n    /** Removes the element on top of the stack and returns that element. */\n    public int pop() {\n        \n    }\n    \n    /** Get the top element. */\n    public int top() {\n        \n    }\n    \n    /** Returns whether the stack is empty. */\n    public boolean empty() {\n        \n    }\n}\n\n/**\n * Your MyStack object will be instantiated and called as such:\n * MyStack obj = new MyStack();\n * obj.push(x);\n * int param_2 = obj.pop();\n * int param_3 = obj.top();\n * boolean param_4 = obj.empty();\n */"
    },
    {
      "lang": "Python",
      "code": "class MyStack(object):\n\n    def __init__(self):\n        \"\"\"\n        Initialize your data structure here.\n        \"\"\"\n        \n\n    def push(self, x):\n        \"\"\"\n        Push element x onto stack.\n        :type x: int\n        :rtype: None\n        \"\"\"\n        \n\n    def pop(self):\n        \"\"\"\n        Removes the element on top of the stack and returns that element.\n        :rtype: int\n        \"\"\"\n        \n\n    def top(self):\n        \"\"\"\n        Get the top element.\n        :rtype: int\n        \"\"\"\n        \n\n    def empty(self):\n        \"\"\"\n        Returns whether the stack is empty.\n        :rtype: bool\n        \"\"\"\n        \n\n\n# Your MyStack object will be instantiated and called as such:\n# obj = MyStack()\n# obj.push(x)\n# param_2 = obj.pop()\n# param_3 = obj.top()\n# param_4 = obj.empty()"
    },
    {
      "lang": "Python3",
      "code": "class MyStack:\n\n    def __init__(self):\n        \"\"\"\n        Initialize your data structure here.\n        \"\"\"\n        \n\n    def push(self, x: int) -> None:\n        \"\"\"\n        Push element x onto stack.\n        \"\"\"\n        \n\n    def pop(self) -> int:\n        \"\"\"\n        Removes the element on top of the stack and returns that element.\n        \"\"\"\n        \n\n    def top(self) -> int:\n        \"\"\"\n        Get the top element.\n        \"\"\"\n        \n\n    def empty(self) -> bool:\n        \"\"\"\n        Returns whether the stack is empty.\n        \"\"\"\n        \n\n\n# Your MyStack object will be instantiated and called as such:\n# obj = MyStack()\n# obj.push(x)\n# param_2 = obj.pop()\n# param_3 = obj.top()\n# param_4 = obj.empty()"
    },
    {
      "lang": "C",
      "code": "\n\n\ntypedef struct {\n    \n} MyStack;\n\n/** Initialize your data structure here. */\n\nMyStack* myStackCreate() {\n    \n}\n\n/** Push element x onto stack. */\nvoid myStackPush(MyStack* obj, int x) {\n  \n}\n\n/** Removes the element on top of the stack and returns that element. */\nint myStackPop(MyStack* obj) {\n  \n}\n\n/** Get the top element. */\nint myStackTop(MyStack* obj) {\n  \n}\n\n/** Returns whether the stack is empty. */\nbool myStackEmpty(MyStack* obj) {\n  \n}\n\nvoid myStackFree(MyStack* obj) {\n    \n}\n\n/**\n * Your MyStack struct will be instantiated and called as such:\n * MyStack* obj = myStackCreate();\n * myStackPush(obj, x);\n \n * int param_2 = myStackPop(obj);\n \n * int param_3 = myStackTop(obj);\n \n * bool param_4 = myStackEmpty(obj);\n \n * myStackFree(obj);\n*/"
    },
    {
      "lang": "C#",
      "code": "public class MyStack {\n\n    /** Initialize your data structure here. */\n    public MyStack() {\n        \n    }\n    \n    /** Push element x onto stack. */\n    public void Push(int x) {\n        \n    }\n    \n    /** Removes the element on top of the stack and returns that element. */\n    public int Pop() {\n        \n    }\n    \n    /** Get the top element. */\n    public int Top() {\n        \n    }\n    \n    /** Returns whether the stack is empty. */\n    public bool Empty() {\n        \n    }\n}\n\n/**\n * Your MyStack object will be instantiated and called as such:\n * MyStack obj = new MyStack();\n * obj.Push(x);\n * int param_2 = obj.Pop();\n * int param_3 = obj.Top();\n * bool param_4 = obj.Empty();\n */"
    },
    {
      "lang": "JavaScript",
      "code": "/**\n * Initialize your data structure here.\n */\nvar MyStack = function() {\n    \n};\n\n/**\n * Push element x onto stack. \n * @param {number} x\n * @return {void}\n */\nMyStack.prototype.push = function(x) {\n    \n};\n\n/**\n * Removes the element on top of the stack and returns that element.\n * @return {number}\n */\nMyStack.prototype.pop = function() {\n    \n};\n\n/**\n * Get the top element.\n * @return {number}\n */\nMyStack.prototype.top = function() {\n    \n};\n\n/**\n * Returns whether the stack is empty.\n * @return {boolean}\n */\nMyStack.prototype.empty = function() {\n    \n};\n\n/** \n * Your MyStack object will be instantiated and called as such:\n * var obj = new MyStack()\n * obj.push(x)\n * var param_2 = obj.pop()\n * var param_3 = obj.top()\n * var param_4 = obj.empty()\n */"
    },
    {
      "lang": "Ruby",
      "code": "class MyStack\n\n=begin\n    Initialize your data structure here.\n=end\n    def initialize()\n        \n    end\n\n\n=begin\n    Push element x onto stack.\n    :type x: Integer\n    :rtype: Void\n=end\n    def push(x)\n        \n    end\n\n\n=begin\n    Removes the element on top of the stack and returns that element.\n    :rtype: Integer\n=end\n    def pop()\n        \n    end\n\n\n=begin\n    Get the top element.\n    :rtype: Integer\n=end\n    def top()\n        \n    end\n\n\n=begin\n    Returns whether the stack is empty.\n    :rtype: Boolean\n=end\n    def empty()\n        \n    end\n\n\nend\n\n# Your MyStack object will be instantiated and called as such:\n# obj = MyStack.new()\n# obj.push(x)\n# param_2 = obj.pop()\n# param_3 = obj.top()\n# param_4 = obj.empty()"
    },
    {
      "lang": "Swift",
      "code": "\nclass MyStack {\n\n    /** Initialize your data structure here. */\n    init() {\n        \n    }\n    \n    /** Push element x onto stack. */\n    func push(_ x: Int) {\n        \n    }\n    \n    /** Removes the element on top of the stack and returns that element. */\n    func pop() -> Int {\n        \n    }\n    \n    /** Get the top element. */\n    func top() -> Int {\n        \n    }\n    \n    /** Returns whether the stack is empty. */\n    func empty() -> Bool {\n        \n    }\n}\n\n/**\n * Your MyStack object will be instantiated and called as such:\n * let obj = MyStack()\n * obj.push(x)\n * let ret_2: Int = obj.pop()\n * let ret_3: Int = obj.top()\n * let ret_4: Bool = obj.empty()\n */"
    },
    {
      "lang": "Go",
      "code": "type MyStack struct {\n    \n}\n\n\n/** Initialize your data structure here. */\nfunc Constructor() MyStack {\n    \n}\n\n\n/** Push element x onto stack. */\nfunc (this *MyStack) Push(x int)  {\n    \n}\n\n\n/** Removes the element on top of the stack and returns that element. */\nfunc (this *MyStack) Pop() int {\n    \n}\n\n\n/** Get the top element. */\nfunc (this *MyStack) Top() int {\n    \n}\n\n\n/** Returns whether the stack is empty. */\nfunc (this *MyStack) Empty() bool {\n    \n}\n\n\n/**\n * Your MyStack object will be instantiated and called as such:\n * obj := Constructor();\n * obj.Push(x);\n * param_2 := obj.Pop();\n * param_3 := obj.Top();\n * param_4 := obj.Empty();\n */"
    },
    {
      "lang": "Scala",
      "code": "class MyStack() {\n\n    /** Initialize your data structure here. */\n    \n\n    /** Push element x onto stack. */\n    def push(x: Int) {\n        \n    }\n\n    /** Removes the element on top of the stack and returns that element. */\n    def pop(): Int = {\n        \n    }\n\n    /** Get the top element. */\n    def top(): Int = {\n        \n    }\n\n    /** Returns whether the stack is empty. */\n    def empty(): Boolean = {\n        \n    }\n\n}\n\n/**\n * Your MyStack object will be instantiated and called as such:\n * var obj = new MyStack()\n * obj.push(x)\n * var param_2 = obj.pop()\n * var param_3 = obj.top()\n * var param_4 = obj.empty()\n */"
    },
    {
      "lang": "Kotlin",
      "code": "class MyStack() {\n\n    /** Initialize your data structure here. */\n    \n\n    /** Push element x onto stack. */\n    fun push(x: Int) {\n        \n    }\n\n    /** Removes the element on top of the stack and returns that element. */\n    fun pop(): Int {\n        \n    }\n\n    /** Get the top element. */\n    fun top(): Int {\n        \n    }\n\n    /** Returns whether the stack is empty. */\n    fun empty(): Boolean {\n        \n    }\n\n}\n\n/**\n * Your MyStack object will be instantiated and called as such:\n * var obj = MyStack()\n * obj.push(x)\n * var param_2 = obj.pop()\n * var param_3 = obj.top()\n * var param_4 = obj.empty()\n */"
    },
    {
      "lang": "Rust",
      "code": "struct MyStack {\n\n}\n\n\n/** \n * `&self` means the method takes an immutable reference.\n * If you need a mutable reference, change it to `&mut self` instead.\n */\nimpl MyStack {\n\n    /** Initialize your data structure here. */\n    fn new() -> Self {\n        \n    }\n    \n    /** Push element x onto stack. */\n    fn push(&self, x: i32) {\n        \n    }\n    \n    /** Removes the element on top of the stack and returns that element. */\n    fn pop(&self) -> i32 {\n        \n    }\n    \n    /** Get the top element. */\n    fn top(&self) -> i32 {\n        \n    }\n    \n    /** Returns whether the stack is empty. */\n    fn empty(&self) -> bool {\n        \n    }\n}\n\n/**\n * Your MyStack object will be instantiated and called as such:\n * let obj = MyStack::new();\n * obj.push(x);\n * let ret_2: i32 = obj.pop();\n * let ret_3: i32 = obj.top();\n * let ret_4: bool = obj.empty();\n */"
    },
    {
      "lang": "PHP",
      "code": "class MyStack {\n    /**\n     * Initialize your data structure here.\n     */\n    function __construct() {\n        \n    }\n  \n    /**\n     * Push element x onto stack.\n     * @param Integer $x\n     * @return NULL\n     */\n    function push($x) {\n        \n    }\n  \n    /**\n     * Removes the element on top of the stack and returns that element.\n     * @return Integer\n     */\n    function pop() {\n        \n    }\n  \n    /**\n     * Get the top element.\n     * @return Integer\n     */\n    function top() {\n        \n    }\n  \n    /**\n     * Returns whether the stack is empty.\n     * @return Boolean\n     */\n    function empty() {\n        \n    }\n}\n\n/**\n * Your MyStack object will be instantiated and called as such:\n * $obj = MyStack();\n * $obj->push($x);\n * $ret_2 = $obj->pop();\n * $ret_3 = $obj->top();\n * $ret_4 = $obj->empty();\n */"
    }
  ],
  "stats": "{\"totalAccepted\": \"152.9K\", \"totalSubmission\": \"364K\", \"totalAcceptedRaw\": 152920, \"totalSubmissionRaw\": 363978, \"acRate\": \"42.0%\"}",
  "hints": [],
  "solution": {
    "id": "41",
    "canSeeDetail": true,
    "url": "/articles/implement-stack-using-queues/",
    "content": "[TOC]\r\n\r\n## Summary\r\nThis article is for beginners. It introduces the following ideas:\r\nStack, Queue.\r\n\r\n## Solution\r\n---\r\n#### Approach #1 (Two Queues, push - $$O(1)$$, pop $$O(n)$$ )\r\n\r\n**Intuition**\r\n\r\nStack is **LIFO** (last in - first out) data structure, in which elements are added and removed from the same end, called `top`.\r\nIn general stack is implemented using array or linked list, but in the current article we will review a different approach for implementing stack using queues. In contrast queue is **FIFO** (first in - first out) data structure, in which elements are added only from the one side - `rear` and removed from the other - `front`. In order to implement stack using queues, we need to maintain two queues `q1` and `q2`. Also we will keep top stack element in a constant memory.\r\n\r\n**Algorithm**\r\n\r\n**Push**\r\n\r\nThe new element is always added to the rear of queue `q1` and it is kept as `top` stack element\r\n\r\n![Push an element in stack](https://leetcode.com/media/original_images/225_stack_using_queues_pushA.png){:width=\"539px\"}\r\n{:align=\"center\"}\r\n\r\n*Figure 1. Push an element in stack*\r\n{:align=\"center\"}\r\n\r\n**Java**\r\n\r\n```java\r\nprivate Queue<Integer> q1 = new LinkedList<>();\r\nprivate Queue<Integer> q2 = new LinkedList<>();\r\nprivate int top;\r\n\r\n// Push element x onto stack.\r\npublic void push(int x) {\r\n    q1.add(x);\r\n    top = x;\r\n}\r\n```\r\n**Complexity Analysis**\r\n\r\n* Time complexity : $$O(1)$$. Queue is implemented as linked list and `add` operation has $$O(1)$$ time complexity.\r\n\r\n* Space complexity : $$O(1)$$\r\n\r\n**Pop**\r\n\r\nWe need to remove the element from the top of the stack. This is the last inserted element in `q1`.\r\nBecause queue is FIFO (first in - first out) data structure, the last inserted element could be removed only after all elements, except it, have been removed. For this reason we need to maintain additional queue `q2`, which will serve as a temporary storage to enqueue the removed elements from q1. The last inserted element in `q2` is kept as top. Then the algorithm removes the last element in `q1`. We swap `q1` with `q2` to avoid copying all elements from `q2` to `q1`.\r\n\r\n![Pop an element from stack](https://leetcode.com/media/original_images/225_stack_using_queues_popA.png){:width=\"539px\"}\r\n{:align=\"center\"}\r\n\r\n*Figure 2. Pop an element from stack*\r\n{:align=\"center\"}\r\n\r\n**Java**\r\n\r\n```java\r\n// Removes the element on top of the stack.\r\npublic void pop() {\r\n    while (q1.size() > 1) {\r\n        top = q1.remove();\r\n        q2.add(top);\r\n    }\r\n    q1.remove();\r\n    Queue<Integer> temp = q1;\r\n    q1 = q2;\r\n    q2 = temp;\r\n}\r\n```\r\n\r\n**Complexity Analysis**\r\n\r\n* Time complexity : $$O(n)$$. The algorithm  dequeues n elements from `q1` and enqueues $$n - 1$$ elements to `q2`, where $$n$$ is the stack size. This gives $$2n - 1$$ operations.\r\n* Space complexity : $$O(1)$$.\r\n\r\n---\r\n#### Approach #2 (Two Queues, push - $$O(n)$$, pop $$O(1)$$ )\r\n\r\n**Algorithm**\r\n\r\n**Push**\r\n\r\nThe algorithm inserts each new element to queue `q2` and keep it as the `top` element. In case queue `q1` is not empty (there are elements in the stack), we remove all elements from `q1` and add them to `q2`. In this way the new inserted element (`top` element in the stack) will be always positioned at the front of `q2`. We swap `q1` with `q2` to avoid copying all elements from `q2` to `q1`.\r\n\r\n![Push an element in stack](https://leetcode.com/media/original_images/225_stack_using_queues_pushB.png){:width=\"539px\"}\r\n{:align=\"center\"}\r\n\r\n*Figure 3. Push an element in stack*\r\n{:align=\"center\"}\r\n\r\n**Java**\r\n\r\n```java\r\npublic void push(int x) {\r\n    q2.add(x);\r\n    top = x;\r\n    while (!q1.isEmpty()) {                \r\n        q2.add(q1.remove());\r\n    }\r\n    Queue<Integer> temp = q1;\r\n    q1 = q2;\r\n    q2 = temp;\r\n}\r\n```\r\n\r\n**Complexity Analysis**\r\n\r\n* Time complexity : $$O(n)$$. The algorithm  removes n elements from `q1` and inserts $$n + 1$$ elements to `q2`, where n is the stack size. This gives $$2n + 1$$ operations. The operations `add` and `remove` in linked lists has $$O(1)$$ complexity.\r\n\r\n* Space complexity : $$O(1)$$.\r\n\r\n**Pop**\r\n\r\nThe algorithm dequeues an element from  queue `q1` and keeps front element of `q1` as `top`.\r\n\r\n![Pop an element from stack](https://leetcode.com/media/original_images/225_stack_using_queues_popB.png){:width=\"539px\"}\r\n{:align=\"center\"}\r\n\r\n*Figure 4. Pop an element from stack*\r\n{:align=\"center\"}\r\n\r\n**Java**\r\n\r\n```java\r\n// Removes the element on top of the stack.\r\npublic void pop() {\r\n    q1.remove();\r\n    if (!q1.isEmpty()) {\r\n    \ttop = q1.peek();\r\n    }\r\n}\r\n```\r\n\r\n**Complexity Analysis**\r\n\r\n* Time complexity : $$O(1)$$.\r\n* Space complexity : $$O(1)$$.\r\n\r\nIn both approaches `empty` and `top` operations have the same implementation.\r\n\r\n**Empty**\r\n\r\nQueue `q1` always contains all stack elements, so the algorithm checks `q1` size to return if the stack is empty.\r\n\r\n```java\r\n// Return whether the stack is empty.\r\npublic boolean empty() {\r\n    return q1.isEmpty();\r\n}\r\n```\r\nTime complexity : $$O(1)$$.\r\n\r\nSpace complexity : $$O(1)$$.\r\n\r\n**Top**\r\n\r\nThe `top` element is kept in constant memory and is modified each time when we push or pop an element.\r\n\r\n```java\r\n// Get the top element.\r\npublic int top() {\r\n    return top;\r\n}\r\n```\r\nTime complexity : $$O(1)$$.\r\n The `top` element has been calculated in advance and only returned in `top` operation.\r\n\r\nSpace complexity : $$O(1)$$.\r\n\r\n---\r\n#### Approach #3 (One Queue, push - $$O(n)$$, pop $$O(1)$$ )\r\n\r\nThe mentioned above two approaches have one weakness, they use two queues. This could be optimized as we use only one queue, instead of two.\r\n\r\n**Algorithm**\r\n\r\n**Push**\r\n\r\nWhen we push an element into a queue, it will be stored at back of the queue due to queue's properties.\r\nBut we need to implement a stack, where last inserted element should be in the front of the queue, not at the back. To achieve this we can invert the order of queue elements when pushing a new element.\r\n\r\n![Push an element in stack](https://leetcode.com/media/original_images/225_stack_using_queues_pushC.png){:width=\"539px\"}\r\n{:align=\"center\"}\r\n\r\n*Figure 5. Push an element in stack*\r\n{:align=\"center\"}\r\n\r\n**Java**\r\n\r\n```java\r\nprivate LinkedList<Integer> q1 = new LinkedList<>();\r\n\r\n// Push element x onto stack.\r\npublic void push(int x) {\r\n    q1.add(x);\r\n    int sz = q1.size();\r\n    while (sz > 1) {\r\n        q1.add(q1.remove());\r\n        sz--;\r\n    }\r\n}\r\n```\r\n\r\n**Complexity Analysis**\r\n\r\n* Time complexity : $$O(n)$$. The algorithm  removes n elements and inserts $$n + 1$$ elements to `q1` , where n is the stack size. This gives $$2n + 1$$ operations. The operations `add` and `remove` in linked lists has $$O(1)$$ complexity.\r\n\r\n* Space complexity : $$O(1)$$.\r\n\r\n**Pop**\r\n\r\n The last inserted element is always stored at the front of `q1` and we can pop it for constant time.\r\n\r\n**Java**\r\n```java\r\n// Removes the element on top of the stack.\r\npublic void pop() {\r\n    q1.remove();\r\n}\r\n```\r\n**Complexity Analysis**\r\n\r\n* Time complexity : $$O(1)$$.\r\n* Space complexity : $$O(1)$$.\r\n\r\n**Empty**\r\n\r\nQueue `q1` contains all stack elements, so the algorithm checks if `q1` is empty.\r\n\r\n```java\r\n// Return whether the stack is empty.\r\npublic boolean empty() {\r\n    return q1.isEmpty();\r\n}\r\n```\r\nTime complexity : $$O(1)$$.\r\n\r\nSpace complexity : $$O(1)$$.\r\n\r\n**Top**\r\n\r\nThe `top` element is always positioned at the front of `q1`. Algorithm return it.\r\n\r\n```java\r\n// Get the top element.\r\npublic int top() {\r\n    return q1.peek();\r\n}\r\n```\r\nTime complexity : $$O(1)$$.\r\n\r\nSpace complexity : $$O(1)$$.\r\n\r\nAnalysis written by: @elmirap.",
    "contentTypeId": "107",
    "rating": {
      "id": "38",
      "count": 82,
      "average": 4.744,
      "userRating": null
    }
  },
  "status": null,
  "sampleTestCase": "[\"MyStack\",\"push\",\"push\",\"top\",\"pop\",\"empty\"]\n[[],[1],[2],[],[],[]]",
  "metaData": "{\r\n    \"classname\": \"MyStack\",\r\n    \"constructor\": {\r\n        \"params\": [\r\n            {\r\n                \"type\": \"integer\",\r\n                \"name\": \"maxSize\",\r\n                \"lang\": \"c\",\r\n                \"value\": \"64000\"\r\n            }\r\n        ],\r\n        \"comment\": \"Initialize your data structure here.\"\r\n    },\r\n    \"methods\": [\r\n        {\r\n            \"name\" : \"push\",\r\n            \"params\": [\r\n                {\r\n                    \"type\": \"integer\",\r\n                    \"name\": \"x\"\r\n                }\r\n            ],\r\n            \"return\": {\r\n                \"type\": \"void\"\r\n            },\r\n            \"comment\": \"Push element x onto stack.\"\r\n        },\r\n        {\r\n            \"name\" : \"pop\",\r\n            \"params\": [\r\n            ],\r\n            \"return\": {\r\n                \"type\": \"integer\"\r\n            },\r\n            \"comment\": \"Removes the element on top of the stack and returns that element.\"\r\n        },\r\n        {\r\n            \"name\" : \"top\",\r\n            \"params\": [\r\n            ],\r\n            \"return\": {\r\n                \"type\": \"integer\"\r\n            },\r\n            \"comment\": \"Get the top element.\"\r\n        },\r\n        {\r\n            \"name\" : \"empty\",\r\n            \"params\": [\r\n            ],\r\n            \"return\": {\r\n                \"type\": \"boolean\"\r\n            },\r\n            \"comment\": \"Returns whether the stack is empty.\"\r\n        }\r\n    ],\r\n    \"systemdesign\": true,\r\n    \"params\": [\r\n        {\r\n            \"name\": \"inputs\",\r\n            \"type\": \"integer[]\"\r\n        },\r\n        {\r\n            \"name\": \"inputs\",\r\n            \"type\": \"integer[]\"\r\n        }\r\n    ],\r\n    \"return\": {\r\n        \"type\": \"list<String>\",\r\n        \"dealloc\": true\r\n    }\r\n}",
  "judgerAvailable": true,
  "judgeType": "large",
  "mysqlSchemas": [],
  "enableRunCode": true,
  "enableTestMode": false,
  "libraryUrl": null
}
