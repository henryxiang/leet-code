{
  "questionId": "226",
  "questionFrontendId": "226",
  "boundTopicId": null,
  "title": "Invert Binary Tree",
  "titleSlug": "invert-binary-tree",
  "categoryTitle": "Algorithms",
  "content": "<p>Invert a binary tree.</p>\r\n\r\n<p><strong>Example:</strong></p>\r\n\r\n<p>Input:</p>\r\n\r\n<pre>\r\n     4\r\n   /   \\\r\n  2     7\r\n / \\   / \\\r\n1   3 6   9</pre>\r\n\r\n<p>Output:</p>\r\n\r\n<pre>\r\n     4\r\n   /   \\\r\n  7     2\r\n / \\   / \\\r\n9   6 3   1</pre>\r\n\r\n<p><strong>Trivia:</strong><br />\r\nThis problem was inspired by <a href=\"https://twitter.com/mxcl/status/608682016205344768\" target=\"_blank\">this original tweet</a> by <a href=\"https://twitter.com/mxcl\" target=\"_blank\">Max Howell</a>:</p>\r\n\r\n<blockquote>Google: 90% of our engineers use the software you wrote (Homebrew), but you can&rsquo;t invert a binary tree on a whiteboard so f*** off.</blockquote>\r\n",
  "isPaidOnly": false,
  "difficulty": "Easy",
  "likes": 2303,
  "dislikes": 38,
  "isLiked": null,
  "similarQuestions": "[]",
  "contributors": [],
  "topicTags": [
    {
      "name": "Tree",
      "slug": "tree"
    }
  ],
  "companyTagStats": "{\"1\": [{\"taggedByAdmin\": false, \"name\": \"Google\", \"slug\": \"google\", \"timesEncountered\": 3}, {\"taggedByAdmin\": false, \"name\": \"Amazon\", \"slug\": \"amazon\", \"timesEncountered\": 2}], \"2\": [{\"taggedByAdmin\": false, \"name\": \"Bloomberg\", \"slug\": \"bloomberg\", \"timesEncountered\": 2}], \"3\": [{\"taggedByAdmin\": false, \"name\": \"Uber\", \"slug\": \"uber\", \"timesEncountered\": 2}, {\"taggedByAdmin\": false, \"name\": \"Salesforce\", \"slug\": \"salesforce\", \"timesEncountered\": 2}, {\"taggedByAdmin\": false, \"name\": \"Facebook\", \"slug\": \"facebook\", \"timesEncountered\": 2}]}",
  "codeSnippets": [
    {
      "lang": "C++",
      "code": "/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\n * };\n */\nclass Solution {\npublic:\n    TreeNode* invertTree(TreeNode* root) {\n        \n    }\n};"
    },
    {
      "lang": "Java",
      "code": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode(int x) { val = x; }\n * }\n */\nclass Solution {\n    public TreeNode invertTree(TreeNode root) {\n        \n    }\n}"
    },
    {
      "lang": "Python",
      "code": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, x):\n#         self.val = x\n#         self.left = None\n#         self.right = None\n\nclass Solution(object):\n    def invertTree(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: TreeNode\n        \"\"\"\n        "
    },
    {
      "lang": "Python3",
      "code": "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, x):\n#         self.val = x\n#         self.left = None\n#         self.right = None\n\nclass Solution:\n    def invertTree(self, root: TreeNode) -> TreeNode:\n        "
    },
    {
      "lang": "C",
      "code": "/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     struct TreeNode *left;\n *     struct TreeNode *right;\n * };\n */\n\n\nstruct TreeNode* invertTree(struct TreeNode* root){\n\n}\n\n"
    },
    {
      "lang": "C#",
      "code": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     public int val;\n *     public TreeNode left;\n *     public TreeNode right;\n *     public TreeNode(int x) { val = x; }\n * }\n */\npublic class Solution {\n    public TreeNode InvertTree(TreeNode root) {\n        \n    }\n}"
    },
    {
      "lang": "JavaScript",
      "code": "/**\n * Definition for a binary tree node.\n * function TreeNode(val) {\n *     this.val = val;\n *     this.left = this.right = null;\n * }\n */\n/**\n * @param {TreeNode} root\n * @return {TreeNode}\n */\nvar invertTree = function(root) {\n    \n};"
    },
    {
      "lang": "Ruby",
      "code": "# Definition for a binary tree node.\n# class TreeNode\n#     attr_accessor :val, :left, :right\n#     def initialize(val)\n#         @val = val\n#         @left, @right = nil, nil\n#     end\n# end\n\n# @param {TreeNode} root\n# @return {TreeNode}\ndef invert_tree(root)\n    \nend"
    },
    {
      "lang": "Swift",
      "code": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     public var val: Int\n *     public var left: TreeNode?\n *     public var right: TreeNode?\n *     public init(_ val: Int) {\n *         self.val = val\n *         self.left = nil\n *         self.right = nil\n *     }\n * }\n */\nclass Solution {\n    func invertTree(_ root: TreeNode?) -> TreeNode? {\n        \n    }\n}"
    },
    {
      "lang": "Go",
      "code": "/**\n * Definition for a binary tree node.\n * type TreeNode struct {\n *     Val int\n *     Left *TreeNode\n *     Right *TreeNode\n * }\n */\nfunc invertTree(root *TreeNode) *TreeNode {\n    \n}"
    },
    {
      "lang": "Scala",
      "code": "/**\n * Definition for a binary tree node.\n * class TreeNode(var _value: Int) {\n *   var value: Int = _value\n *   var left: TreeNode = null\n *   var right: TreeNode = null\n * }\n */\nobject Solution {\n    def invertTree(root: TreeNode): TreeNode = {\n        \n    }\n}"
    },
    {
      "lang": "Kotlin",
      "code": "/**\n * Example:\n * var ti = TreeNode(5)\n * var v = ti.`val`\n * Definition for a binary tree node.\n * class TreeNode(var `val`: Int) {\n *     var left: TreeNode? = null\n *     var right: TreeNode? = null\n * }\n */\nclass Solution {\n    fun invertTree(root: TreeNode?): TreeNode? {\n        \n    }\n}"
    },
    {
      "lang": "Rust",
      "code": "// Definition for a binary tree node.\n// #[derive(Debug, PartialEq, Eq)]\n// pub struct TreeNode {\n//   pub val: i32,\n//   pub left: Option<Rc<RefCell<TreeNode>>>,\n//   pub right: Option<Rc<RefCell<TreeNode>>>,\n// }\n// \n// impl TreeNode {\n//   #[inline]\n//   pub fn new(val: i32) -> Self {\n//     TreeNode {\n//       val,\n//       left: None,\n//       right: None\n//     }\n//   }\n// }\nuse std::rc::Rc;\nuse std::cell::RefCell;\nimpl Solution {\n    pub fn invert_tree(root: Option<Rc<RefCell<TreeNode>>>) -> Option<Rc<RefCell<TreeNode>>> {\n        \n    }\n}"
    },
    {
      "lang": "PHP",
      "code": "/**\n * Definition for a binary tree node.\n * class TreeNode {\n *     public $val = null;\n *     public $left = null;\n *     public $right = null;\n *     function __construct($value) { $this->val = $value; }\n * }\n */\nclass Solution {\n\n    /**\n     * @param TreeNode $root\n     * @return TreeNode\n     */\n    function invertTree($root) {\n        \n    }\n}"
    }
  ],
  "stats": "{\"totalAccepted\": \"393.9K\", \"totalSubmission\": \"647.7K\", \"totalAcceptedRaw\": 393920, \"totalSubmissionRaw\": 647731, \"acRate\": \"60.8%\"}",
  "hints": [],
  "solution": {
    "id": "37",
    "canSeeDetail": true,
    "url": "/articles/invert-binary-tree/",
    "content": "[TOC]\r\n\r\n## Solution\r\n---\r\n#### Approach #1 (Recursive) [Accepted]\r\n\r\n\r\nThis is a classic tree problem that is best-suited for a recursive approach.\r\n\r\n\r\n**Algorithm**\r\n\r\nThe inverse of an empty tree is the empty tree. The inverse of a tree with root $$r$$, and subtrees $$\\mbox{right}$$ and $$\\mbox{left}$$, is a tree with root $$r$$, whose right subtree is the inverse of $$\\mbox{left}$$, and whose left subtree is the inverse of $$\\mbox{right}$$.\r\n\r\n**Java**\r\n\r\n```java\r\npublic TreeNode invertTree(TreeNode root) {\r\n    if (root == null) {\r\n        return null;\r\n    }\r\n    TreeNode right = invertTree(root.right);\r\n    TreeNode left = invertTree(root.left);\r\n    root.left = right;\r\n    root.right = left;\r\n    return root;\r\n}\r\n```\r\n\r\n**Complexity Analysis**\r\n\r\nSince each node in the tree is visited only once, the time complexity is $$O(n)$$, where $$n$$ is the number of nodes in the tree. We cannot do better than that, since at the very least we have to visit each node to invert it.\r\n\r\nBecause of recursion, $$O(h)$$ function calls will be placed on the stack in the worst case, where $$h$$ is the height of the tree. Because $$h\\in O(n)$$, the space complexity is $$O(n)$$.\r\n\r\n---\r\n#### Approach #2 (Iterative) [Accepted]\r\n\r\nAlternatively, we can solve the problem iteratively, in a manner similar to breadth-first search.\r\n\r\n**Algorithm**\r\n\r\nThe idea is that we need to swap the left and right child of all nodes in the tree. So we create a queue to store nodes whose left and right child have not been swapped yet. Initially, only the root is in the queue. As long as the queue is not empty, remove the next node from the queue, swap its children, and add the children to the queue. Null nodes are not added to the queue. Eventually, the queue will be empty and all the children swapped, and we return the original root.\r\n\r\n**Java**\r\n```java\r\npublic TreeNode invertTree(TreeNode root) {\r\n    if (root == null) return null;\r\n    Queue<TreeNode> queue = new LinkedList<TreeNode>();\r\n    queue.add(root);\r\n    while (!queue.isEmpty()) {\r\n        TreeNode current = queue.poll();\r\n        TreeNode temp = current.left;\r\n        current.left = current.right;\r\n        current.right = temp;\r\n        if (current.left != null) queue.add(current.left);\r\n        if (current.right != null) queue.add(current.right);\r\n    }\r\n    return root;\r\n}\r\n```\r\n\r\n**Complexity Analysis**\r\n\r\nSince each node in the tree is visited / added to the queue only once, the time complexity is $$O(n)$$, where $$n$$ is the number of nodes in the tree.\r\n\r\nSpace complexity is $$O(n)$$, since in the worst case, the queue will contain all nodes in one level of the binary tree. For a full binary tree, the leaf level has $$\\lceil \\frac{n}{2}\\rceil=O(n)$$ leaves.\r\n\r\nAnalysis written by: @noran",
    "contentTypeId": "107",
    "rating": {
      "id": "39",
      "count": 89,
      "average": 4.786,
      "userRating": null
    }
  },
  "status": null,
  "sampleTestCase": "[4,2,7,1,3,6,9]",
  "metaData": "{\r\n  \"name\": \"invertTree\",\r\n  \"params\": [\r\n    {\r\n      \"name\": \"root\",\r\n      \"type\": \"TreeNode\"\r\n    }\r\n  ],\r\n  \"return\": {\r\n    \"type\": \"TreeNode\"\r\n  }\r\n}",
  "judgerAvailable": true,
  "judgeType": "large",
  "mysqlSchemas": [],
  "enableRunCode": true,
  "enableTestMode": false,
  "libraryUrl": null
}
