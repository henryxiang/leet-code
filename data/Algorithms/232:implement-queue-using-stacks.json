{
  "questionId": "232",
  "questionFrontendId": "232",
  "boundTopicId": null,
  "title": "Implement Queue using Stacks",
  "titleSlug": "implement-queue-using-stacks",
  "categoryTitle": "Algorithms",
  "content": "<p>Implement the following operations of a queue using stacks.</p>\r\n\r\n<ul>\r\n\t<li>push(x) -- Push element x to the back of queue.</li>\r\n\t<li>pop() -- Removes the element from in front of queue.</li>\r\n\t<li>peek() -- Get the front element.</li>\r\n\t<li>empty() -- Return whether the queue is empty.</li>\r\n</ul>\r\n\r\n<p><b>Example:</b></p>\r\n\r\n<pre>\r\nMyQueue queue = new MyQueue();\r\n\r\nqueue.push(1);\r\nqueue.push(2);  \r\nqueue.peek();  // returns 1\r\nqueue.pop();   // returns 1\r\nqueue.empty(); // returns false</pre>\r\n\r\n<p><b>Notes:</b></p>\r\n\r\n<ul>\r\n\t<li>You must use <i>only</i> standard operations of a stack -- which means only <code>push to top</code>, <code>peek/pop from top</code>, <code>size</code>, and <code>is empty</code> operations are valid.</li>\r\n\t<li>Depending on your language, stack may not be supported natively. You may simulate a stack by using a list or deque (double-ended queue), as long as you use only standard operations of a stack.</li>\r\n\t<li>You may assume that all operations are valid (for example, no pop or peek operations will be called on an empty queue).</li>\r\n</ul>\r\n",
  "isPaidOnly": false,
  "difficulty": "Easy",
  "likes": 752,
  "dislikes": 126,
  "isLiked": null,
  "similarQuestions": "[{\"title\": \"Implement Stack using Queues\", \"titleSlug\": \"implement-stack-using-queues\", \"difficulty\": \"Easy\", \"translatedTitle\": null}]",
  "contributors": [],
  "topicTags": [
    {
      "name": "Stack",
      "slug": "stack"
    },
    {
      "name": "Design",
      "slug": "design"
    }
  ],
  "companyTagStats": "{\"3\": [{\"taggedByAdmin\": false, \"name\": \"Google\", \"slug\": \"google\", \"timesEncountered\": 5}, {\"taggedByAdmin\": false, \"name\": \"eBay\", \"slug\": \"ebay\", \"timesEncountered\": 4}, {\"taggedByAdmin\": false, \"name\": \"Yandex\", \"slug\": \"yandex\", \"timesEncountered\": 3}, {\"taggedByAdmin\": false, \"name\": \"ByteDance\", \"slug\": \"bytedance\", \"timesEncountered\": 2}, {\"taggedByAdmin\": false, \"name\": \"Uber\", \"slug\": \"uber\", \"timesEncountered\": 2}], \"1\": [{\"taggedByAdmin\": true, \"name\": \"Microsoft\", \"slug\": \"microsoft\", \"timesEncountered\": 6}, {\"taggedByAdmin\": false, \"name\": \"Mathworks\", \"slug\": \"mathworks\", \"timesEncountered\": 3}, {\"taggedByAdmin\": false, \"name\": \"Oracle\", \"slug\": \"oracle\", \"timesEncountered\": 3}, {\"taggedByAdmin\": false, \"name\": \"Amazon\", \"slug\": \"amazon\", \"timesEncountered\": 2}, {\"taggedByAdmin\": false, \"name\": \"Apple\", \"slug\": \"apple\", \"timesEncountered\": 2}, {\"taggedByAdmin\": true, \"name\": \"Bloomberg\", \"slug\": \"bloomberg\", \"timesEncountered\": 2}], \"2\": [{\"taggedByAdmin\": false, \"name\": \"Yahoo\", \"slug\": \"yahoo\", \"timesEncountered\": 2}]}",
  "codeSnippets": [
    {
      "lang": "C++",
      "code": "class MyQueue {\npublic:\n    /** Initialize your data structure here. */\n    MyQueue() {\n        \n    }\n    \n    /** Push element x to the back of queue. */\n    void push(int x) {\n        \n    }\n    \n    /** Removes the element from in front of queue and returns that element. */\n    int pop() {\n        \n    }\n    \n    /** Get the front element. */\n    int peek() {\n        \n    }\n    \n    /** Returns whether the queue is empty. */\n    bool empty() {\n        \n    }\n};\n\n/**\n * Your MyQueue object will be instantiated and called as such:\n * MyQueue* obj = new MyQueue();\n * obj->push(x);\n * int param_2 = obj->pop();\n * int param_3 = obj->peek();\n * bool param_4 = obj->empty();\n */"
    },
    {
      "lang": "Java",
      "code": "class MyQueue {\n\n    /** Initialize your data structure here. */\n    public MyQueue() {\n        \n    }\n    \n    /** Push element x to the back of queue. */\n    public void push(int x) {\n        \n    }\n    \n    /** Removes the element from in front of queue and returns that element. */\n    public int pop() {\n        \n    }\n    \n    /** Get the front element. */\n    public int peek() {\n        \n    }\n    \n    /** Returns whether the queue is empty. */\n    public boolean empty() {\n        \n    }\n}\n\n/**\n * Your MyQueue object will be instantiated and called as such:\n * MyQueue obj = new MyQueue();\n * obj.push(x);\n * int param_2 = obj.pop();\n * int param_3 = obj.peek();\n * boolean param_4 = obj.empty();\n */"
    },
    {
      "lang": "Python",
      "code": "class MyQueue(object):\n\n    def __init__(self):\n        \"\"\"\n        Initialize your data structure here.\n        \"\"\"\n        \n\n    def push(self, x):\n        \"\"\"\n        Push element x to the back of queue.\n        :type x: int\n        :rtype: None\n        \"\"\"\n        \n\n    def pop(self):\n        \"\"\"\n        Removes the element from in front of queue and returns that element.\n        :rtype: int\n        \"\"\"\n        \n\n    def peek(self):\n        \"\"\"\n        Get the front element.\n        :rtype: int\n        \"\"\"\n        \n\n    def empty(self):\n        \"\"\"\n        Returns whether the queue is empty.\n        :rtype: bool\n        \"\"\"\n        \n\n\n# Your MyQueue object will be instantiated and called as such:\n# obj = MyQueue()\n# obj.push(x)\n# param_2 = obj.pop()\n# param_3 = obj.peek()\n# param_4 = obj.empty()"
    },
    {
      "lang": "Python3",
      "code": "class MyQueue:\n\n    def __init__(self):\n        \"\"\"\n        Initialize your data structure here.\n        \"\"\"\n        \n\n    def push(self, x: int) -> None:\n        \"\"\"\n        Push element x to the back of queue.\n        \"\"\"\n        \n\n    def pop(self) -> int:\n        \"\"\"\n        Removes the element from in front of queue and returns that element.\n        \"\"\"\n        \n\n    def peek(self) -> int:\n        \"\"\"\n        Get the front element.\n        \"\"\"\n        \n\n    def empty(self) -> bool:\n        \"\"\"\n        Returns whether the queue is empty.\n        \"\"\"\n        \n\n\n# Your MyQueue object will be instantiated and called as such:\n# obj = MyQueue()\n# obj.push(x)\n# param_2 = obj.pop()\n# param_3 = obj.peek()\n# param_4 = obj.empty()"
    },
    {
      "lang": "C",
      "code": "\n\n\ntypedef struct {\n    \n} MyQueue;\n\n/** Initialize your data structure here. */\n\nMyQueue* myQueueCreate() {\n    \n}\n\n/** Push element x to the back of queue. */\nvoid myQueuePush(MyQueue* obj, int x) {\n  \n}\n\n/** Removes the element from in front of queue and returns that element. */\nint myQueuePop(MyQueue* obj) {\n  \n}\n\n/** Get the front element. */\nint myQueuePeek(MyQueue* obj) {\n  \n}\n\n/** Returns whether the queue is empty. */\nbool myQueueEmpty(MyQueue* obj) {\n  \n}\n\nvoid myQueueFree(MyQueue* obj) {\n    \n}\n\n/**\n * Your MyQueue struct will be instantiated and called as such:\n * MyQueue* obj = myQueueCreate();\n * myQueuePush(obj, x);\n \n * int param_2 = myQueuePop(obj);\n \n * int param_3 = myQueuePeek(obj);\n \n * bool param_4 = myQueueEmpty(obj);\n \n * myQueueFree(obj);\n*/"
    },
    {
      "lang": "C#",
      "code": "public class MyQueue {\n\n    /** Initialize your data structure here. */\n    public MyQueue() {\n        \n    }\n    \n    /** Push element x to the back of queue. */\n    public void Push(int x) {\n        \n    }\n    \n    /** Removes the element from in front of queue and returns that element. */\n    public int Pop() {\n        \n    }\n    \n    /** Get the front element. */\n    public int Peek() {\n        \n    }\n    \n    /** Returns whether the queue is empty. */\n    public bool Empty() {\n        \n    }\n}\n\n/**\n * Your MyQueue object will be instantiated and called as such:\n * MyQueue obj = new MyQueue();\n * obj.Push(x);\n * int param_2 = obj.Pop();\n * int param_3 = obj.Peek();\n * bool param_4 = obj.Empty();\n */"
    },
    {
      "lang": "JavaScript",
      "code": "/**\n * Initialize your data structure here.\n */\nvar MyQueue = function() {\n    \n};\n\n/**\n * Push element x to the back of queue. \n * @param {number} x\n * @return {void}\n */\nMyQueue.prototype.push = function(x) {\n    \n};\n\n/**\n * Removes the element from in front of queue and returns that element.\n * @return {number}\n */\nMyQueue.prototype.pop = function() {\n    \n};\n\n/**\n * Get the front element.\n * @return {number}\n */\nMyQueue.prototype.peek = function() {\n    \n};\n\n/**\n * Returns whether the queue is empty.\n * @return {boolean}\n */\nMyQueue.prototype.empty = function() {\n    \n};\n\n/** \n * Your MyQueue object will be instantiated and called as such:\n * var obj = new MyQueue()\n * obj.push(x)\n * var param_2 = obj.pop()\n * var param_3 = obj.peek()\n * var param_4 = obj.empty()\n */"
    },
    {
      "lang": "Ruby",
      "code": "class MyQueue\n\n=begin\n    Initialize your data structure here.\n=end\n    def initialize()\n        \n    end\n\n\n=begin\n    Push element x to the back of queue.\n    :type x: Integer\n    :rtype: Void\n=end\n    def push(x)\n        \n    end\n\n\n=begin\n    Removes the element from in front of queue and returns that element.\n    :rtype: Integer\n=end\n    def pop()\n        \n    end\n\n\n=begin\n    Get the front element.\n    :rtype: Integer\n=end\n    def peek()\n        \n    end\n\n\n=begin\n    Returns whether the queue is empty.\n    :rtype: Boolean\n=end\n    def empty()\n        \n    end\n\n\nend\n\n# Your MyQueue object will be instantiated and called as such:\n# obj = MyQueue.new()\n# obj.push(x)\n# param_2 = obj.pop()\n# param_3 = obj.peek()\n# param_4 = obj.empty()"
    },
    {
      "lang": "Swift",
      "code": "\nclass MyQueue {\n\n    /** Initialize your data structure here. */\n    init() {\n        \n    }\n    \n    /** Push element x to the back of queue. */\n    func push(_ x: Int) {\n        \n    }\n    \n    /** Removes the element from in front of queue and returns that element. */\n    func pop() -> Int {\n        \n    }\n    \n    /** Get the front element. */\n    func peek() -> Int {\n        \n    }\n    \n    /** Returns whether the queue is empty. */\n    func empty() -> Bool {\n        \n    }\n}\n\n/**\n * Your MyQueue object will be instantiated and called as such:\n * let obj = MyQueue()\n * obj.push(x)\n * let ret_2: Int = obj.pop()\n * let ret_3: Int = obj.peek()\n * let ret_4: Bool = obj.empty()\n */"
    },
    {
      "lang": "Go",
      "code": "type MyQueue struct {\n    \n}\n\n\n/** Initialize your data structure here. */\nfunc Constructor() MyQueue {\n    \n}\n\n\n/** Push element x to the back of queue. */\nfunc (this *MyQueue) Push(x int)  {\n    \n}\n\n\n/** Removes the element from in front of queue and returns that element. */\nfunc (this *MyQueue) Pop() int {\n    \n}\n\n\n/** Get the front element. */\nfunc (this *MyQueue) Peek() int {\n    \n}\n\n\n/** Returns whether the queue is empty. */\nfunc (this *MyQueue) Empty() bool {\n    \n}\n\n\n/**\n * Your MyQueue object will be instantiated and called as such:\n * obj := Constructor();\n * obj.Push(x);\n * param_2 := obj.Pop();\n * param_3 := obj.Peek();\n * param_4 := obj.Empty();\n */"
    },
    {
      "lang": "Scala",
      "code": "class MyQueue() {\n\n    /** Initialize your data structure here. */\n    \n\n    /** Push element x to the back of queue. */\n    def push(x: Int) {\n        \n    }\n\n    /** Removes the element from in front of queue and returns that element. */\n    def pop(): Int = {\n        \n    }\n\n    /** Get the front element. */\n    def peek(): Int = {\n        \n    }\n\n    /** Returns whether the queue is empty. */\n    def empty(): Boolean = {\n        \n    }\n\n}\n\n/**\n * Your MyQueue object will be instantiated and called as such:\n * var obj = new MyQueue()\n * obj.push(x)\n * var param_2 = obj.pop()\n * var param_3 = obj.peek()\n * var param_4 = obj.empty()\n */"
    },
    {
      "lang": "Kotlin",
      "code": "class MyQueue() {\n\n    /** Initialize your data structure here. */\n    \n\n    /** Push element x to the back of queue. */\n    fun push(x: Int) {\n        \n    }\n\n    /** Removes the element from in front of queue and returns that element. */\n    fun pop(): Int {\n        \n    }\n\n    /** Get the front element. */\n    fun peek(): Int {\n        \n    }\n\n    /** Returns whether the queue is empty. */\n    fun empty(): Boolean {\n        \n    }\n\n}\n\n/**\n * Your MyQueue object will be instantiated and called as such:\n * var obj = MyQueue()\n * obj.push(x)\n * var param_2 = obj.pop()\n * var param_3 = obj.peek()\n * var param_4 = obj.empty()\n */"
    },
    {
      "lang": "Rust",
      "code": "struct MyQueue {\n\n}\n\n\n/** \n * `&self` means the method takes an immutable reference.\n * If you need a mutable reference, change it to `&mut self` instead.\n */\nimpl MyQueue {\n\n    /** Initialize your data structure here. */\n    fn new() -> Self {\n        \n    }\n    \n    /** Push element x to the back of queue. */\n    fn push(&self, x: i32) {\n        \n    }\n    \n    /** Removes the element from in front of queue and returns that element. */\n    fn pop(&self) -> i32 {\n        \n    }\n    \n    /** Get the front element. */\n    fn peek(&self) -> i32 {\n        \n    }\n    \n    /** Returns whether the queue is empty. */\n    fn empty(&self) -> bool {\n        \n    }\n}\n\n/**\n * Your MyQueue object will be instantiated and called as such:\n * let obj = MyQueue::new();\n * obj.push(x);\n * let ret_2: i32 = obj.pop();\n * let ret_3: i32 = obj.peek();\n * let ret_4: bool = obj.empty();\n */"
    },
    {
      "lang": "PHP",
      "code": "class MyQueue {\n    /**\n     * Initialize your data structure here.\n     */\n    function __construct() {\n        \n    }\n  \n    /**\n     * Push element x to the back of queue.\n     * @param Integer $x\n     * @return NULL\n     */\n    function push($x) {\n        \n    }\n  \n    /**\n     * Removes the element from in front of queue and returns that element.\n     * @return Integer\n     */\n    function pop() {\n        \n    }\n  \n    /**\n     * Get the front element.\n     * @return Integer\n     */\n    function peek() {\n        \n    }\n  \n    /**\n     * Returns whether the queue is empty.\n     * @return Boolean\n     */\n    function empty() {\n        \n    }\n}\n\n/**\n * Your MyQueue object will be instantiated and called as such:\n * $obj = MyQueue();\n * $obj->push($x);\n * $ret_2 = $obj->pop();\n * $ret_3 = $obj->peek();\n * $ret_4 = $obj->empty();\n */"
    }
  ],
  "stats": "{\"totalAccepted\": \"179.5K\", \"totalSubmission\": \"388.6K\", \"totalAcceptedRaw\": 179512, \"totalSubmissionRaw\": 388575, \"acRate\": \"46.2%\"}",
  "hints": [],
  "solution": {
    "id": "47",
    "canSeeDetail": true,
    "url": "/articles/implement-queue-using-stacks/",
    "content": "[TOC]\r\n\r\n## Summary\r\nThis article is for beginners. It introduces the following ideas:\r\nQueue, Stack.\r\n\r\n## Solution\r\n\r\nQueue is **FIFO** (first in - first out) data structure, in which the elements are inserted from one side - `rear` and removed from the other - `front`.\r\nThe most intuitive way to implement it is with linked lists, but this article will introduce another approach  using stacks.\r\nStack is **LIFO** (last in - first out) data structure, in which elements are added and removed from the same end, called `top`.\r\nTo satisfy **FIFO** property of a queue we need to keep two stacks. They serve to reverse arrival order of the  elements and one of them store the queue elements in their final order.\r\n\r\n---\r\n#### Approach #1 (Two Stacks) Push - $$O(n)$$ per operation, Pop - $$O(1)$$ per operation.\r\n\r\n**Algorithm**\r\n\r\n**Push**\r\n\r\nA queue is FIFO (first-in-first-out) but a stack is LIFO (last-in-first-out). This means the newest element must be pushed to the bottom of the stack. To do so we first transfer all `s1` elements to auxiliary stack `s2`. Then the newly arrived element is pushed on top of `s2` and all its elements are popped and pushed to `s1`.\r\n\r\n![Push an element in queue](https://leetcode.com/media/original_images/232_queue_using_stacksBPush.png){:width=\"539px\"}\r\n{:align=\"center\"}\r\n\r\n*Figure 1. Push an element in queue*\r\n{:align=\"center\"}\r\n\r\n**Java**\r\n\r\n```java\r\nprivate int front;\r\n\r\npublic void push(int x) {\r\n    if (s1.empty())\r\n        front = x;\r\n    while (!s1.isEmpty())\r\n        s2.push(s1.pop());\r\n    s2.push(x);\r\n    while (!s2.isEmpty())\r\n        s1.push(s2.pop());\r\n}\r\n```\r\n\r\n**Complexity Analysis**\r\n\r\n* Time complexity : $$O(n)$$.\r\n\r\n Each element, with the exception of the newly arrived, is pushed and popped twice. The last inserted element is popped and pushed once. Therefore this gives  $$4 n + 2$$  operations where $$n$$ is the queue size. The  `push` and `pop` operations have $$O(1)$$ time complexity.\r\n\r\n* Space complexity : $$O(n)$$.\r\nWe need additional memory to store the queue elements\r\n\r\n**Pop**\r\n\r\nThe algorithm pops an element from  the stack `s1`, because `s1` stores always on its top the first inserted element in the queue.\r\nThe front element of the queue is kept as `front`.\r\n\r\n![Pop an element from queue](https://leetcode.com/media/original_images/232_queue_using_stacksBPop.png){:width=\"539px\"}\r\n{:align=\"center\"}\r\n\r\n*Figure 2. Pop an element from queue*\r\n{:align=\"center\"}\r\n\r\n**Java**\r\n\r\n```java\r\n\r\n// Removes the element from the front of queue.\r\npublic void pop() {\r\n    s1.pop();\r\n    if (!s1.empty())\r\n        front = s1.peek();\r\n}\r\n```\r\n\r\n**Complexity Analysis**\r\n\r\n* Time complexity : $$O(1)$$.\r\n* Space complexity : $$O(1)$$.\r\n\r\n**Empty**\r\n\r\nStack `s1` contains all stack elements, so the algorithm checks `s1` size to return if the queue is empty.\r\n\r\n```java\r\n// Return whether the queue is empty.\r\npublic boolean empty() {\r\n    return s1.isEmpty();\r\n}\r\n```\r\n\r\nTime complexity : $$O(1)$$.\r\n\r\nSpace complexity : $$O(1)$$.\r\n\r\n**Peek**\r\n\r\nThe `front` element is kept in constant memory and is modified when we push or pop an element.\r\n\r\n```java\r\n// Get the front element.\r\npublic int peek() {\r\n  return front;\r\n}\r\n```\r\n\r\nTime complexity : $$O(1)$$.\r\nThe `front` element has been calculated in advance and only returned in `peek` operation.\r\n\r\nSpace complexity : $$O(1)$$.\r\n\r\n---\r\n#### Approach #2 (Two Stacks) Push - $$O(1)$$ per operation, Pop - Amortized $$O(1)$$ per operation.\r\n\r\n**Algorithm**\r\n\r\n**Push**\r\n\r\nThe newly arrived element is always added on top of stack `s1` and the first element is kept as `front` queue element\r\n\r\n![Push an element in queue](https://leetcode.com/media/original_images/232_queue_using_stacksAPush.png){:width=\"539px\"}\r\n{:align=\"center\"}\r\n\r\n*Figure 3. Push an element in queue*\r\n{:align=\"center\"}\r\n\r\n**Java**\r\n\r\n```java\r\n\r\nprivate Stack<Integer> s1 = new Stack<>();\r\nprivate Stack<Integer> s2 = new Stack<>();\r\n\r\n// Push element x to the back of queue.\r\npublic void push(int x) {\r\n    if (s1.empty())\r\n        front = x;\r\n    s1.push(x);\r\n}\r\n```\r\n\r\n**Complexity Analysis**\r\n\r\n* Time complexity : $$O(1)$$.\r\n\r\n Аppending an element to a stack is an O(1) operation.\r\n\r\n* Space complexity : $$O(n)$$.\r\nWe need additional memory to store the queue elements\r\n\r\n**Pop**\r\n\r\nWe have to remove element in front of the queue. This is the first inserted element in the stack `s1` and it is positioned at the bottom of the stack because of stack's `LIFO (last in - first out)` policy. To remove the bottom element  from  `s1`, we have to pop all elements from `s1` and to push them on to an additional stack `s2`, which helps us to store the elements of `s1` in reversed order. This way  the bottom element of `s1` will be positioned on top of `s2` and we can simply pop it from stack `s2`. Once `s2` is empty, the algorithm transfer data from `s1` to `s2` again.\r\n\r\n![Pop an element from stack](https://leetcode.com/media/original_images/232_queue_using_stacksAPop.png){:width=\"539px\"}\r\n{:align=\"center\"}\r\n\r\n*Figure 4. Pop an element from stack*\r\n{:align=\"center\"}\r\n\r\n**Java**\r\n\r\n```java\r\n// Removes the element from in front of queue.\r\npublic void pop() {\r\n    if (s2.isEmpty()) {\r\n        while (!s1.isEmpty())\r\n            s2.push(s1.pop());\r\n    }\r\n    s2.pop();    \r\n}\r\n```\r\n\r\n**Complexity Analysis**\r\n\r\n* Time complexity: Amortized $$O(1)$$, Worst-case $$O(n)$$.\r\n\r\nIn the worst case scenario when stack `s2` is empty, the algorithm pops $$n$$ elements from stack s1 and pushes $$n$$ elements to `s2`, where $$n$$ is the queue size. This gives $$2n$$ operations, which is $$O(n)$$. But when stack `s2` is not empty the algorithm has $$O(1)$$ time complexity. So what does it mean by Amortized $$O(1)$$? Please see the next section on Amortized Analysis for more information.\r\n\r\n* Space complexity : $$O(1)$$.\r\n\r\n**Amortized Analysis**\r\n\r\nAmortized analysis gives the average performance (over time) of each operation in the worst case. The basic idea is that a worst case operation can alter the state in such a way that the worst case cannot occur again for a long time, thus amortizing its cost.\r\n\r\nConsider this example where we start with an empty queue with the following sequence of operations applied:\r\n\r\n$$\r\npush_1, push_2, \\ldots, push_n, pop_1,pop_2 \\ldots, pop_n\r\n$$\r\n\r\nThe worst case time complexity of a single pop operation is $$O(n)$$. Since we have $$n$$ pop operations, using the worst-case per operation analysis gives us a total of $$O(n^2)$$ time.\r\n\r\nHowever, in a sequence of operations the worst case does not occur often in each operation - some operations may be cheap, some may be expensive. Therefore, a traditional worst-case per operation analysis can give overly pessimistic bound. For example, in a dynamic array only some inserts take a linear time, though others - a constant time.\r\n\r\nIn the example above, the number of times pop operation can be called is limited by the number of push operations before it. Although a single pop operation could be expensive, it is expensive only once per `n` times (queue size), when `s2` is empty and there is a need for data transfer between `s1` and `s2`. Hence the total time complexity of the sequence is : `n` (for push operations) + `2*n` (for first pop operation) + `n - 1` ( for pop operations) which is $$O(2*n)$$.This gives $$O(2n/2n)$$ = $$O(1)$$ average time per operation.\r\n\r\n**Empty**\r\n\r\nBoth stacks `s1` and `s2` contain all stack elements, so the algorithm checks `s1` and `s2` size to return if the queue is empty.\r\n\r\n```java\r\n\r\n// Return whether the queue is empty.\r\npublic boolean empty() {\r\n    return s1.isEmpty() && s2.isEmpty();\r\n}\r\n```\r\n\r\nTime complexity : $$O(1)$$.\r\n\r\nSpace complexity : $$O(1)$$.\r\n\r\n\r\n**Peek**\r\n\r\nThe `front` element is kept in constant memory and is modified when we push an element. When `s2` is not empty, front element is positioned on the top of `s2`\r\n\r\n```java\r\n// Get the front element.\r\npublic int peek() {\r\n    if (!s2.isEmpty()) {\r\n            return s2.peek();\r\n    }\r\n    return front;\r\n}\r\n```\r\n\r\nTime complexity : $$O(1)$$.\r\n\r\nThe `front` element was either previously calculated or returned as a top element of stack `s2`. Therefore complexity is $$O(1)$$\r\n\r\nSpace complexity : $$O(1)$$.\r\n\r\nAnalysis written by: @elmirap.",
    "contentTypeId": "107",
    "rating": {
      "id": "45",
      "count": 50,
      "average": 4.18,
      "userRating": null
    }
  },
  "status": null,
  "sampleTestCase": "[\"MyQueue\",\"push\",\"push\",\"peek\",\"pop\",\"empty\"]\n[[],[1],[2],[],[],[]]",
  "metaData": "{\r\n    \"classname\": \"MyQueue\",\r\n    \"constructor\": {\r\n        \"params\": [\r\n            {\r\n                \"type\": \"integer\",\r\n                \"name\": \"maxSize\",\r\n                \"lang\": \"c\",\r\n                \"value\": \"64000\"\r\n            }\r\n        ],\r\n        \"comment\": \"Initialize your data structure here.\"\r\n    },\r\n    \"methods\": [\r\n        {\r\n            \"name\" : \"push\",\r\n            \"params\": [\r\n                {\r\n                    \"type\": \"integer\",\r\n                    \"name\": \"x\"\r\n                }\r\n            ],\r\n            \"return\": {\r\n                \"type\": \"void\"\r\n            },\r\n            \"comment\": \"Push element x to the back of queue.\"\r\n        },\r\n        {\r\n            \"name\" : \"pop\",\r\n            \"params\": [\r\n            ],\r\n            \"return\": {\r\n                \"type\": \"integer\"\r\n            },\r\n            \"comment\": \"Removes the element from in front of queue and returns that element.\"\r\n        },\r\n        {\r\n            \"name\" : \"peek\",\r\n            \"params\": [\r\n            ],\r\n            \"return\": {\r\n                \"type\": \"integer\"\r\n            },\r\n            \"comment\": \"Get the front element.\"\r\n        },\r\n        {\r\n            \"name\" : \"empty\",\r\n            \"params\": [\r\n            ],\r\n            \"return\": {\r\n                \"type\": \"boolean\"\r\n            },\r\n            \"comment\": \"Returns whether the queue is empty.\"\r\n        }\r\n    ],\r\n    \"systemdesign\": true,\r\n    \"params\": [\r\n        {\r\n            \"name\": \"inputs\",\r\n            \"type\": \"integer[]\"\r\n        },\r\n        {\r\n            \"name\": \"inputs\",\r\n            \"type\": \"integer[]\"\r\n        }\r\n    ],\r\n    \"return\": {\r\n        \"type\": \"list<String>\",\r\n        \"dealloc\": true\r\n    }\r\n}",
  "judgerAvailable": true,
  "judgeType": "large",
  "mysqlSchemas": [],
  "enableRunCode": true,
  "enableTestMode": false,
  "libraryUrl": null
}
