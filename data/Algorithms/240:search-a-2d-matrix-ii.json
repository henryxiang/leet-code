{
  "questionId": "240",
  "questionFrontendId": "240",
  "boundTopicId": null,
  "title": "Search a 2D Matrix II",
  "titleSlug": "search-a-2d-matrix-ii",
  "categoryTitle": "Algorithms",
  "content": "<p>Write an efficient algorithm that searches for a value in an <i>m</i> x <i>n</i> matrix. This matrix has the following properties:</p>\r\n\r\n<ul>\r\n\t<li>Integers in each row are sorted in ascending from left to right.</li>\r\n\t<li>Integers in each column are sorted in ascending from top to bottom.</li>\r\n</ul>\r\n\r\n<p><strong>Example:</strong></p>\r\n\r\n<p>Consider the following matrix:</p>\r\n\r\n<pre>\r\n[\r\n  [1,   4,  7, 11, 15],\r\n  [2,   5,  8, 12, 19],\r\n  [3,   6,  9, 16, 22],\r\n  [10, 13, 14, 17, 24],\r\n  [18, 21, 23, 26, 30]\r\n]\r\n</pre>\r\n\r\n<p>Given&nbsp;target&nbsp;=&nbsp;<code>5</code>, return&nbsp;<code>true</code>.</p>\r\n\r\n<p>Given&nbsp;target&nbsp;=&nbsp;<code>20</code>, return&nbsp;<code>false</code>.</p>\r\n",
  "isPaidOnly": false,
  "difficulty": "Medium",
  "likes": 2191,
  "dislikes": 64,
  "isLiked": null,
  "similarQuestions": "[{\"title\": \"Search a 2D Matrix\", \"titleSlug\": \"search-a-2d-matrix\", \"difficulty\": \"Medium\", \"translatedTitle\": null}]",
  "contributors": [],
  "topicTags": [
    {
      "name": "Binary Search",
      "slug": "binary-search"
    },
    {
      "name": "Divide and Conquer",
      "slug": "divide-and-conquer"
    }
  ],
  "companyTagStats": "{\"2\": [{\"taggedByAdmin\": false, \"name\": \"Paypal\", \"slug\": \"paypal\", \"timesEncountered\": 3}, {\"taggedByAdmin\": true, \"name\": \"Google\", \"slug\": \"google\", \"timesEncountered\": 2}, {\"taggedByAdmin\": false, \"name\": \"Walmart Labs\", \"slug\": \"walmart-labs\", \"timesEncountered\": 2}, {\"taggedByAdmin\": false, \"name\": \"Expedia\", \"slug\": \"expedia\", \"timesEncountered\": 2}, {\"taggedByAdmin\": false, \"name\": \"Salesforce\", \"slug\": \"salesforce\", \"timesEncountered\": 2}], \"3\": [{\"taggedByAdmin\": false, \"name\": \"Goldman Sachs\", \"slug\": \"goldman-sachs\", \"timesEncountered\": 4}, {\"taggedByAdmin\": false, \"name\": \"Bloomberg\", \"slug\": \"bloomberg\", \"timesEncountered\": 3}, {\"taggedByAdmin\": false, \"name\": \"Tencent\", \"slug\": \"tencent\", \"timesEncountered\": 3}, {\"taggedByAdmin\": false, \"name\": \"Baidu\", \"slug\": \"baidu\", \"timesEncountered\": 2}, {\"taggedByAdmin\": true, \"name\": \"Apple\", \"slug\": \"apple\", \"timesEncountered\": 0}], \"1\": [{\"taggedByAdmin\": true, \"name\": \"Amazon\", \"slug\": \"amazon\", \"timesEncountered\": 65}, {\"taggedByAdmin\": false, \"name\": \"Microsoft\", \"slug\": \"microsoft\", \"timesEncountered\": 10}, {\"taggedByAdmin\": false, \"name\": \"Facebook\", \"slug\": \"facebook\", \"timesEncountered\": 3}, {\"taggedByAdmin\": false, \"name\": \"SAP\", \"slug\": \"sap\", \"timesEncountered\": 2}, {\"taggedByAdmin\": false, \"name\": \"Citadel\", \"slug\": \"citadel\", \"timesEncountered\": 2}]}",
  "codeSnippets": [
    {
      "lang": "C++",
      "code": "class Solution {\r\npublic:\r\n    bool searchMatrix(vector<vector<int>>& matrix, int target) {\r\n        \r\n    }\r\n};"
    },
    {
      "lang": "Java",
      "code": "class Solution {\r\n    public boolean searchMatrix(int[][] matrix, int target) {\r\n        \r\n    }\r\n}"
    },
    {
      "lang": "Python",
      "code": "class Solution(object):\r\n    def searchMatrix(self, matrix, target):\r\n        \"\"\"\r\n        :type matrix: List[List[int]]\r\n        :type target: int\r\n        :rtype: bool\r\n        \"\"\"\r\n        "
    },
    {
      "lang": "Python3",
      "code": "class Solution:\r\n    def searchMatrix(self, matrix, target):\r\n        \"\"\"\r\n        :type matrix: List[List[int]]\r\n        :type target: int\r\n        :rtype: bool\r\n        \"\"\"\r\n        "
    },
    {
      "lang": "C",
      "code": "bool searchMatrix(int** matrix, int matrixRowSize, int matrixColSize, int target) {\r\n    \r\n}"
    },
    {
      "lang": "C#",
      "code": "public class Solution {\r\n    public bool SearchMatrix(int[,] matrix, int target) {\r\n        \r\n    }\r\n}"
    },
    {
      "lang": "JavaScript",
      "code": "/**\r\n * @param {number[][]} matrix\r\n * @param {number} target\r\n * @return {boolean}\r\n */\r\nvar searchMatrix = function(matrix, target) {\r\n    \r\n};"
    },
    {
      "lang": "Ruby",
      "code": "# @param {Integer[][]} matrix\r\n# @param {Integer} target\r\n# @return {Boolean}\r\ndef search_matrix(matrix, target)\r\n    \r\nend"
    },
    {
      "lang": "Swift",
      "code": "class Solution {\n    func searchMatrix(_ matrix: [[Int]], _ target: Int) -> Bool {\n\n    }\n}"
    },
    {
      "lang": "Go",
      "code": "func searchMatrix(matrix [][]int, target int) bool {\r\n    \r\n}"
    },
    {
      "lang": "Scala",
      "code": "object Solution {\r\n    def searchMatrix(matrix: Array[Array[Int]], target: Int): Boolean = {\r\n        \r\n    }\r\n}"
    },
    {
      "lang": "Kotlin",
      "code": "class Solution {\r\n    fun searchMatrix(matrix: Array<IntArray>, target: Int): Boolean {\r\n        \r\n    }\r\n}"
    },
    {
      "lang": "PHP",
      "code": "class Solution {\n\n    /**\n     * @param Integer[][] $matrix\n     * @param Integer $target\n     * @return Boolean\n     */\n    function searchMatrix($matrix, $target) {\n        \n    }\n}"
    }
  ],
  "stats": "{\"totalAccepted\": \"243.1K\", \"totalSubmission\": \"577.3K\", \"totalAcceptedRaw\": 243121, \"totalSubmissionRaw\": 577334, \"acRate\": \"42.1%\"}",
  "hints": [],
  "solution": {
    "id": "341",
    "canSeeDetail": true,
    "url": "/articles/search-a-2d-matrix-ii/",
    "content": "[TOC]\n\n## Solution\n---\n#### Approach 1: Brute Force\n\n**Intuition**\n\nAs a baseline, we can search the 2D array the same way we might search an\nunsorted 1D array -- by examining each element.\n\n**Algorithm**\n\nThe algorithm doesn't really do anything more clever than what is explained\nby the intuition; we loop over the array, checking each element in turn. If\nwe find it, we return `true`. Otherwise, if we reach the end of the nested\n`for` loop without returning, we return `false`. The algorithm must return\nthe correct answer in all cases because we exhaust the entire search space.\n\n<iframe src=\"https://leetcode.com/playground/4SyLD4eP/shared\" frameBorder=\"0\" width=\"100%\" height=\"276\" name=\"4SyLD4eP\"></iframe>\n\n**Complexity Analysis**\n\n* Time complexity : $$\\mathcal{O}(nm)$$\n\n    Becase we perform a constant time operation for each element of an\n    $$n\\times m$$ element matrix, the overall time complexity is equal to the\n    size of the matrix.\n\n* Space complexity : $$\\mathcal{O}(1)$$\n\n    The brute force approach does not allocate more additional space than a\n    handful of pointers, so the memory footprint is constant.\n<br />\n<br />\n\n\n---\n#### Approach 2: Binary Search\n\n**Intuition**\n\nThe fact that the matrix is sorted suggests that there must be some way to use\nbinary search to speed up our algorithm.\n\n**Algorithm**\n\nFirst, we ensure that `matrix` is not `null` and not empty. Then, if we\niterate over the matrix diagonals, we can maintain an invariant that the\nslice of the row and column beginning at the current $$(row, col)$$ pair is\nsorted. Therefore, we can always binary search these row and column slices\nfor `target`. We proceed in a logical fashion, iterating over the diagonals,\nbinary searching the rows and columns until we either run out of diagonals\n(meaning we can return `False`) or find `target` (meaning we can return\n`True`). The `binarySearch` function works just like normal binary search,\nbut is made ugly by the need to search both rows and columns of a\ntwo-dimensional array.\n\n<iframe src=\"https://leetcode.com/playground/udti4YjK/shared\" frameBorder=\"0\" width=\"100%\" height=\"500\" name=\"udti4YjK\"></iframe>\n\n**Complexity Analysis**\n\n* Time complexity : $$\\mathcal{O}(lg(n!))$$\n\n    It's not super obvious how $$\\mathcal{O}(lg(n!))$$ time complexity arises\n    from this algorithm, so let's analyze it step-by-step. The\n    asymptotically-largest amount of work performed is in the main loop,\n    which runs for $$min(m, n)$$ iterations, where $$m$$ denotes the number\n    of rows and $$n$$ denotes the number of columns. On each iteration, we\n    perform two binary searches on array slices of length $$m-i$$ and\n    $$n-i$$. Therefore, each iteration of the loop runs in\n    $$\\mathcal{O}(lg(m-i)+lg(n-i))$$ time, where $$i$$ denotes the current\n    iteration. We can simplify this to $$\\mathcal{O}(2\\cdot lg(n-i))=\\mathcal{O}(lg(n-i))$$\n    by seeing that, in the worst case, $$n\\approx m$$. To see why, consider\n    what happens when $$n \\ll m$$ (without loss of generality); $$n$$ will\n    dominate $$m$$ in the asymptotic analysis. By summing the runtimes of all\n    iterations, we get the following expression:\n\n    $$\n        (1) \\quad \\mathcal{O}(lg(n) + lg(n-1) + lg(n-2) + \\ldots + lg(1))\n    $$\n\n    Then, we can leverage the log multiplication rule ($$lg(a)+lg(b)=lg(ab)$$)\n    to rewrite the complexity as:\n\n    $$\n    \\begin{aligned}\n        (2) \\quad \\mathcal{O}(lg(n) + lg(n-1) + lg(n-2) + \\ldots + lg(1)) &=\n                  \\mathcal{O}(lg(n \\cdot (n-1) \\cdot (n-2) \\cdot \\ldots \\cdot 1)) \\\\ &=\n                  \\mathcal{O}(lg(1 \\cdot \\ldots \\cdot (n-2) \\cdot (n-1) \\cdot n)) \\\\\n                                                             &= \\mathcal{O}(lg(n!))\n    \\end{aligned}\n    $$\n\n    Because this time complexity is fairly uncommon, it is worth thinking about\n    its relation to the usual analyses. For one, $$lg(n!) = \\mathcal{O}(nlgn)$$.\n    To see why, recall step 1 from the analysis above; there are $$n$$ terms, each no\n    greater than $$lg(n)$$. Therefore, the asymptotic runtime is certainly no worse than\n    that of an $$\\mathcal{O}(nlgn)$$ algorithm.\n\n* Space complexity : $$\\mathcal{O}(1)$$\n\n    Because our binary search implementation does not literally slice out\n    copies of rows and columns from `matrix`, we can avoid allocating\n    greater-than-constant memory.\n<br />\n<br />\n\n\n---\n#### Approach 3: Divide and Conquer\n\n**Intuition**\n\nWe can partition a sorted two-dimensional matrix into four sorted submatrices,\ntwo of which might contain `target` and two of which definitely do not.\n\n**Algorithm**\n\nBecause this algorithm operates recursively, its correctness can be asserted\nvia the correctness of its base and recursive cases.\n\n*Base Case*\n\nFor a sorted two-dimensional array, there are two ways to determine in\nconstant time whether an arbitrary element `target` can appear in it. First,\nif the array has zero area, it contains no elements and therefore cannot\ncontain `target`. Second, if `target` is smaller than the array's smallest\nelement (found in the top-left corner) or larger than the array's largest\nelement (found in the bottom-right corner), then it definitely is not\npresent.\n\n*Recursive Case*\n\nIf the base case conditions have not been met, then the array has positive\narea and `target` could potentially be present. Therefore, we seek along the\nmatrix's middle column for an index `row` such that\n$$ matrix[row-1][mid] < target < matrix[row][mid] $$ (obviously, if we find\n`target` during this process, we immediately return `true`). The existing\nmatrix can be partitioned into four submatrice around this index; the\ntop-left and bottom-right submatrice cannot contain `target` (via the\nargument outlined in *Base Case* section), so we can prune them from the\nsearch space. Additionally, the bottom-left and top-right submatrice are\nsorted two-dimensional matrices, so we can recursively apply this algorithm\nto them.\n\n<iframe src=\"https://leetcode.com/playground/pSTavpna/shared\" frameBorder=\"0\" width=\"100%\" height=\"500\" name=\"pSTavpna\"></iframe>\n\n**Complexity Analysis**\n\n* Time complexity : $$\\mathcal{O}(nlgn)$$\n\n    First, for ease of analysis, assume that $$n \\approx m$$, as in the\n    analysis of approach 2. Also, assign $$x=n^2=|matrix|$$; this will make\n    the [master method](https://en.wikipedia.org/wiki/Master_theorem_(analysis_of_algorithms))\n    easier to apply. Now, let's model the runtime of the\n    divide & conquer approach as a recurrence relation:\n\n    $$\n        T(x) = 2 \\cdot T(\\frac{x}{4}) + \\sqrt{x}\n    $$\n\n    The first term ($$2 \\cdot T(\\frac{x}{4})$$) arises from the fact that we\n    recurse on two submatrices of roughly one-quarter size, while\n    $$\\sqrt{x}$$ comes from the time spent seeking along a $$O(n)$$-length\n    column for the partition point. After binding the master method variables\n    ($$a=2;b=4;c=0.5$$) we notice that $$\\log_b{a}=c$$. Therefore, this\n    recurrence falls under case 2 of the master method, and the following\n    falls out:\n\n    $$\n    \\begin{aligned}\n        T(x) &= \\mathcal{O}(x^c \\cdot lgx) \\\\\n             &= \\mathcal{O}(x^{0.5} \\cdot lgx) \\\\\n             &= \\mathcal{O}((n^2)^{0.5} \\cdot lg(n^2)) \\\\\n             &= \\mathcal{O}(n \\cdot lg(n^2)) \\\\\n             &= \\mathcal{O}(2n \\cdot lgn) \\\\\n             &= \\mathcal{O}(n \\cdot lgn) \\\\\n    \\end{aligned}\n    $$\n\n    Extension: what would happen to the complexity if we binary searched for\n    the partition point, rather than used a linear scan?\n\n* Space complexity : $$\\mathcal{O}(lgn)$$\n\n    Although this approach does not fundamentally require\n    greater-than-constant addition memory, its use of recursion means that it\n    will use memory proportional to the height of its recursion tree. Because\n    this approach discards half of `matrix` on each level of recursion (and\n    makes two recursive calls), the height of the tree is bounded by $$lgn$$.\n<br />\n<br />\n\n\n---\n#### Approach 4: Search Space Reduction\n\n**Intuition**\n\nBecause the rows and columns of the matrix are sorted (from left-to-right and\ntop-to-bottom, respectively), we can prune $$\\mathcal{O}(m)$$ or \n$$\\mathcal{O}(n)$$ elements when looking at any particular value.\n\n**Algorithm**\n\nFirst, we initialize a $$(row, col)$$ pointer to the bottom-left of the\nmatrix.[^1] Then, until we find `target` and return `true` (or the pointer\npoints to a $$(row, col)$$ that lies outside of the dimensions of the\nmatrix), we do the following: if the currently-pointed-to value is larger\nthan `target` we can move one row \"up\". Otherwise, if the\ncurrently-pointed-to value is smaller than `target`, we can move one column\n\"right\". It is not too tricky to see why doing this will never prune the\ncorrect answer; because the rows are sorted from left-to-right, we know that\nevery value to the right of the current value is larger. Therefore, if the\ncurrent value is already larger than `target`, we know that every value to\nits right will also be too large. A very similar argument can be made for the\ncolumns, so this manner of search will always find `target` in the matrix (if\nit is present).\n\nCheck out some sample runs of the algorithm in the animation below:\n\n!?!../Documents/240_Search_a_2D_Matrix_II.json:1280,720!?!\n\n<iframe src=\"https://leetcode.com/playground/FezWLFH7/shared\" frameBorder=\"0\" width=\"100%\" height=\"463\" name=\"FezWLFH7\"></iframe>\n\n**Complexity Analysis**\n\n* Time complexity : $$\\mathcal{O}(n+m)$$\n\n    The key to the time complexity analysis is noticing that, on every\n    iteration (during which we do not return `true`) either `row` or `col` is\n    is decremented/incremented exactly once. Because `row` can only be\n    decremented $$m$$ times and `col` can only be incremented $$n$$ times\n    before causing the `while` loop to terminate, the loop cannot run for\n    more than $$n+m$$ iterations. Because all other work is constant, the\n    overall time complexity is linear in the sum of the dimensions of the\n    matrix.\n\n* Space complexity : $$\\mathcal{O}(1)$$\n\n    Because this approach only manipulates a few pointers, its memory\n    footprint is constant.\n<br />\n\nAnalysis and solutions written by: [@emptyset](https://leetcode.com/emptyset)\n\n\n#### Footnotes ####\n\n[^1]: This would work equally well with a pointer initialized to the\ntop-right. Neither of the other two corners would work, as pruning a\nrow/column might prevent us from achieving the correct answer.",
    "contentTypeId": "107",
    "rating": {
      "id": "336",
      "count": 42,
      "average": 4.69,
      "userRating": null
    }
  },
  "status": null,
  "sampleTestCase": "[[1,4,7,11,15],[2,5,8,12,19],[3,6,9,16,22],[10,13,14,17,24],[18,21,23,26,30]]\n5",
  "metaData": "{\n  \"name\": \"searchMatrix\",\n  \"params\": [\n    {\n      \"name\": \"matrix\",\n      \"type\": \"integer[][]\"\n    },\n    {\n      \"name\": \"target\",\n      \"type\": \"integer\"\n    }\n  ],\n  \"return\": {\n    \"type\": \"boolean\"\n  },\n  \"manual\": true\n}",
  "judgerAvailable": true,
  "judgeType": "large",
  "mysqlSchemas": [],
  "enableRunCode": true,
  "enableTestMode": false,
  "libraryUrl": null
}
