{
  "questionId": "250",
  "questionFrontendId": "250",
  "boundTopicId": null,
  "title": "Count Univalue Subtrees",
  "titleSlug": "count-univalue-subtrees",
  "categoryTitle": "Algorithms",
  "content": "<p>Given a binary tree, count the number of uni-value subtrees.</p>\r\n\r\n<p>A Uni-value subtree means all nodes of the subtree have the same value.</p>\r\n\r\n<p><b>Example :</b></p>\r\n\r\n<pre>\r\n<b>Input:</b>  root = [5,1,5,5,5,null,5]\r\n\r\n              5\r\n             / \\\r\n            1   5\r\n           / \\   \\\r\n          5   5   5\r\n\r\n<b>Output:</b> 4\r\n</pre>\r\n",
  "isPaidOnly": true,
  "difficulty": "Medium",
  "likes": 389,
  "dislikes": 91,
  "isLiked": null,
  "similarQuestions": "[{\"title\": \"Subtree of Another Tree\", \"titleSlug\": \"subtree-of-another-tree\", \"difficulty\": \"Easy\", \"translatedTitle\": null}, {\"title\": \"Longest Univalue Path\", \"titleSlug\": \"longest-univalue-path\", \"difficulty\": \"Easy\", \"translatedTitle\": null}]",
  "contributors": [],
  "topicTags": [
    {
      "name": "Tree",
      "slug": "tree"
    }
  ],
  "companyTagStats": "{\"1\": [{\"taggedByAdmin\": false, \"name\": \"Box\", \"slug\": \"box\", \"timesEncountered\": 4}, {\"taggedByAdmin\": false, \"name\": \"Bloomberg\", \"slug\": \"bloomberg\", \"timesEncountered\": 2}], \"2\": [{\"taggedByAdmin\": false, \"name\": \"Google\", \"slug\": \"google\", \"timesEncountered\": 4}, {\"taggedByAdmin\": false, \"name\": \"Amazon\", \"slug\": \"amazon\", \"timesEncountered\": 3}], \"3\": [{\"taggedByAdmin\": false, \"name\": \"Facebook\", \"slug\": \"facebook\", \"timesEncountered\": 2}]}",
  "codeSnippets": [
    {
      "lang": "C++",
      "code": "/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\n * };\n */\nclass Solution {\npublic:\n    int countUnivalSubtrees(TreeNode* root) {\n        \n    }\n};"
    },
    {
      "lang": "Java",
      "code": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode(int x) { val = x; }\n * }\n */\nclass Solution {\n    public int countUnivalSubtrees(TreeNode root) {\n        \n    }\n}"
    },
    {
      "lang": "Python",
      "code": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, x):\n#         self.val = x\n#         self.left = None\n#         self.right = None\n\nclass Solution(object):\n    def countUnivalSubtrees(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        "
    },
    {
      "lang": "Python3",
      "code": "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, x):\n#         self.val = x\n#         self.left = None\n#         self.right = None\n\nclass Solution:\n    def countUnivalSubtrees(self, root: TreeNode) -> int:\n        "
    },
    {
      "lang": "C",
      "code": "/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     struct TreeNode *left;\n *     struct TreeNode *right;\n * };\n */\n\n\nint countUnivalSubtrees(struct TreeNode* root){\n\n}\n\n"
    },
    {
      "lang": "C#",
      "code": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     public int val;\n *     public TreeNode left;\n *     public TreeNode right;\n *     public TreeNode(int x) { val = x; }\n * }\n */\npublic class Solution {\n    public int CountUnivalSubtrees(TreeNode root) {\n        \n    }\n}"
    },
    {
      "lang": "JavaScript",
      "code": "/**\n * Definition for a binary tree node.\n * function TreeNode(val) {\n *     this.val = val;\n *     this.left = this.right = null;\n * }\n */\n/**\n * @param {TreeNode} root\n * @return {number}\n */\nvar countUnivalSubtrees = function(root) {\n    \n};"
    },
    {
      "lang": "Ruby",
      "code": "# Definition for a binary tree node.\n# class TreeNode\n#     attr_accessor :val, :left, :right\n#     def initialize(val)\n#         @val = val\n#         @left, @right = nil, nil\n#     end\n# end\n\n# @param {TreeNode} root\n# @return {Integer}\ndef count_unival_subtrees(root)\n    \nend"
    },
    {
      "lang": "Swift",
      "code": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     public var val: Int\n *     public var left: TreeNode?\n *     public var right: TreeNode?\n *     public init(_ val: Int) {\n *         self.val = val\n *         self.left = nil\n *         self.right = nil\n *     }\n * }\n */\nclass Solution {\n    func countUnivalSubtrees(_ root: TreeNode?) -> Int {\n        \n    }\n}"
    },
    {
      "lang": "Go",
      "code": "/**\n * Definition for a binary tree node.\n * type TreeNode struct {\n *     Val int\n *     Left *TreeNode\n *     Right *TreeNode\n * }\n */\nfunc countUnivalSubtrees(root *TreeNode) int {\n    \n}"
    },
    {
      "lang": "Scala",
      "code": "/**\n * Definition for a binary tree node.\n * class TreeNode(var _value: Int) {\n *   var value: Int = _value\n *   var left: TreeNode = null\n *   var right: TreeNode = null\n * }\n */\nobject Solution {\n    def countUnivalSubtrees(root: TreeNode): Int = {\n        \n    }\n}"
    },
    {
      "lang": "Kotlin",
      "code": "/**\n * Example:\n * var ti = TreeNode(5)\n * var v = ti.`val`\n * Definition for a binary tree node.\n * class TreeNode(var `val`: Int) {\n *     var left: TreeNode? = null\n *     var right: TreeNode? = null\n * }\n */\nclass Solution {\n    fun countUnivalSubtrees(root: TreeNode?): Int {\n        \n    }\n}"
    },
    {
      "lang": "Rust",
      "code": "// Definition for a binary tree node.\n// #[derive(Debug, PartialEq, Eq)]\n// pub struct TreeNode {\n//   pub val: i32,\n//   pub left: Option<Rc<RefCell<TreeNode>>>,\n//   pub right: Option<Rc<RefCell<TreeNode>>>,\n// }\n// \n// impl TreeNode {\n//   #[inline]\n//   pub fn new(val: i32) -> Self {\n//     TreeNode {\n//       val,\n//       left: None,\n//       right: None\n//     }\n//   }\n// }\nuse std::rc::Rc;\nuse std::cell::RefCell;\nimpl Solution {\n    pub fn count_unival_subtrees(root: Option<Rc<RefCell<TreeNode>>>) -> i32 {\n        \n    }\n}"
    },
    {
      "lang": "PHP",
      "code": "/**\n * Definition for a binary tree node.\n * class TreeNode {\n *     public $val = null;\n *     public $left = null;\n *     public $right = null;\n *     function __construct($value) { $this->val = $value; }\n * }\n */\nclass Solution {\n\n    /**\n     * @param TreeNode $root\n     * @return Integer\n     */\n    function countUnivalSubtrees($root) {\n        \n    }\n}"
    }
  ],
  "stats": "{\"totalAccepted\": \"50.8K\", \"totalSubmission\": \"100K\", \"totalAcceptedRaw\": 50758, \"totalSubmissionRaw\": 99953, \"acRate\": \"50.8%\"}",
  "hints": [],
  "solution": {
    "id": "703",
    "canSeeDetail": true,
    "url": "/articles/count-univalue-subtrees/",
    "content": "[TOC]\n\n## Solution\n\n---\n\n#### Approach 1: Depth First Search\n\n**Intuition**\n\nGiven a node in our tree, we know that it is a univalue subtree if it meets one of the following criteria:\n\n   1. The node has no children (base case)\n   2. All of the node's children are univalue subtrees, and the node and its children all have the same value\n\nWith this in mind we can perform a depth-first-search on our tree, and test if each subtree is uni-value in a bottom-up manner.\n\n\n!?!../Documents/250_Count_Univalue_SUbtrees.json:1000,518!?!\n\n**Algorithm**\n\n<iframe src=\"https://leetcode.com/playground/dN5bMg4Z/shared\" frameBorder=\"0\" width=\"100%\" height=\"500\" name=\"dN5bMg4Z\"></iframe>\n\n**Complexity Analysis**\n\n* Time complexity : $$O(n)$$.\n\n    Due to the algorithm's depth-first nature, the `is_uni` status of each node is computed from bottom up. When given the `is_uni` status of its children, computing the `is_uni` status of a node occurs in $$O(1)$$\n\n    This gives us $$O(1)$$ time for each node in the tree with $$O(N)$$ total nodes for a time complexity of $$O(N)$$\n\n* Space complexity : $$O(H)$$, with `H` being the height of the tree. Each recursive call of `is_uni` requires stack space. Since we fully process `is_uni(node.left)` before calling `is_uni(node.right)`, the recursive stack is bound by the longest path from the root to a leaf - in other words the height of the tree.\n<br />\n<br />\n\n---\n\n#### Approach 2: Depth First Search - Pass Parent Values\n\n**Algorithm**\n\nWe can use the intuition from approach one to further simplify our algorithm. Instead of checking if a node has no children, we treat `null` values as univalue subtrees that we don't add to the count.\n\nIn this manner, if a node has a `null` child, that child is automatically considered to a valid subtree, which results in the algorithm only checking if other children are invalid.\n\nFinally, the helper function checks if the current node is a valid subtree but returns a boolean indicating if it is a valid component for its parent. This is done by passing in the value of the parent node.\n\n\n<iframe src=\"https://leetcode.com/playground/KkbW68w3/shared\" frameBorder=\"0\" width=\"100%\" height=\"446\" name=\"KkbW68w3\"></iframe>\n\nThe above code is a commented version of the code [here](https://leetcode.com/problems/count-univalue-subtrees/discuss/67602/Java-11-lines-added), originally written by [Stefan Pochmann](https://leetcode.com/stefanpochmann/).\n\n\n**Complexity Analysis**\n\n* Time complexity : $$O(N)$$. Same as the previous approach.\n\n* Space complexity : $$O(H)$$, with `H` being the height of the tree. Same as the previous approach.\n\n<br />\n\n---\n\nWritten by [@alwinpeng](https://leetcode.com/alwinpeng/).",
    "contentTypeId": "107",
    "rating": {
      "id": "688",
      "count": 16,
      "average": 4.125,
      "userRating": null
    }
  },
  "status": null,
  "sampleTestCase": "[5,1,5,5,5,null,5]",
  "metaData": "{\r\n  \"name\": \"countUnivalSubtrees\",\r\n  \"params\": [\r\n    {\r\n      \"name\": \"root\",\r\n      \"type\": \"TreeNode\"\r\n    }\r\n  ],\r\n  \"return\": {\r\n    \"type\": \"integer\"\r\n  }\r\n}",
  "judgerAvailable": true,
  "judgeType": "large",
  "mysqlSchemas": [],
  "enableRunCode": true,
  "enableTestMode": false,
  "libraryUrl": null
}
