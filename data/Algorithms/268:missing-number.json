{
  "questionId": "268",
  "questionFrontendId": "268",
  "boundTopicId": null,
  "title": "Missing Number",
  "titleSlug": "missing-number",
  "categoryTitle": "Algorithms",
  "content": "<p>Given an array containing <i>n</i> distinct numbers taken from <code>0, 1, 2, ..., n</code>, find the one that is missing from the array.</p>\r\n\r\n<p><b>Example 1:</b></p>\r\n\r\n<pre>\r\n<b>Input:</b> [3,0,1]\r\n<b>Output:</b> 2\r\n</pre>\r\n\r\n<p><b>Example 2:</b></p>\r\n\r\n<pre>\r\n<b>Input:</b> [9,6,4,2,3,5,7,0,1]\r\n<b>Output:</b> 8\r\n</pre>\r\n\r\n<p><b>Note</b>:<br />\r\nYour algorithm should run in linear runtime complexity. Could you implement it using only constant extra space complexity?</p>",
  "isPaidOnly": false,
  "difficulty": "Easy",
  "likes": 1240,
  "dislikes": 1645,
  "isLiked": null,
  "similarQuestions": "[{\"title\": \"First Missing Positive\", \"titleSlug\": \"first-missing-positive\", \"difficulty\": \"Hard\", \"translatedTitle\": null}, {\"title\": \"Single Number\", \"titleSlug\": \"single-number\", \"difficulty\": \"Easy\", \"translatedTitle\": null}, {\"title\": \"Find the Duplicate Number\", \"titleSlug\": \"find-the-duplicate-number\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Couples Holding Hands\", \"titleSlug\": \"couples-holding-hands\", \"difficulty\": \"Hard\", \"translatedTitle\": null}]",
  "contributors": [
    {
      "username": "jianchao-li",
      "profileUrl": "/jianchao-li/",
      "avatarUrl": "https://assets.leetcode.com/users/jianchaolifighter/avatar_1529298385.png"
    }
  ],
  "topicTags": [
    {
      "name": "Array",
      "slug": "array"
    },
    {
      "name": "Math",
      "slug": "math"
    },
    {
      "name": "Bit Manipulation",
      "slug": "bit-manipulation"
    }
  ],
  "companyTagStats": "{\"1\": [{\"taggedByAdmin\": true, \"name\": \"Microsoft\", \"slug\": \"microsoft\", \"timesEncountered\": 5}, {\"taggedByAdmin\": false, \"name\": \"Amazon\", \"slug\": \"amazon\", \"timesEncountered\": 3}, {\"taggedByAdmin\": true, \"name\": \"Bloomberg\", \"slug\": \"bloomberg\", \"timesEncountered\": 2}, {\"taggedByAdmin\": false, \"name\": \"Apple\", \"slug\": \"apple\", \"timesEncountered\": 2}], \"3\": [{\"taggedByAdmin\": false, \"name\": \"Zillow\", \"slug\": \"zillow\", \"timesEncountered\": 3}, {\"taggedByAdmin\": false, \"name\": \"Goldman Sachs\", \"slug\": \"goldman-sachs\", \"timesEncountered\": 2}, {\"taggedByAdmin\": false, \"name\": \"Adobe\", \"slug\": \"adobe\", \"timesEncountered\": 2}, {\"taggedByAdmin\": false, \"name\": \"Oracle\", \"slug\": \"oracle\", \"timesEncountered\": 2}, {\"taggedByAdmin\": false, \"name\": \"IBM\", \"slug\": \"ibm\", \"timesEncountered\": 2}, {\"taggedByAdmin\": true, \"name\": \"Facebook\", \"slug\": \"facebook\", \"timesEncountered\": 0}], \"2\": [{\"taggedByAdmin\": false, \"name\": \"Google\", \"slug\": \"google\", \"timesEncountered\": 5}, {\"taggedByAdmin\": false, \"name\": \"Arista Networks\", \"slug\": \"arista-networks\", \"timesEncountered\": 2}, {\"taggedByAdmin\": false, \"name\": \"VMware\", \"slug\": \"vmware\", \"timesEncountered\": 2}]}",
  "codeSnippets": [
    {
      "lang": "C++",
      "code": "class Solution {\npublic:\n    int missingNumber(vector<int>& nums) {\n        \n    }\n};"
    },
    {
      "lang": "Java",
      "code": "class Solution {\n    public int missingNumber(int[] nums) {\n        \n    }\n}"
    },
    {
      "lang": "Python",
      "code": "class Solution(object):\n    def missingNumber(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        "
    },
    {
      "lang": "Python3",
      "code": "class Solution:\n    def missingNumber(self, nums: List[int]) -> int:\n        "
    },
    {
      "lang": "C",
      "code": "\n\nint missingNumber(int* nums, int numsSize){\n\n}\n\n"
    },
    {
      "lang": "C#",
      "code": "public class Solution {\n    public int MissingNumber(int[] nums) {\n        \n    }\n}"
    },
    {
      "lang": "JavaScript",
      "code": "/**\n * @param {number[]} nums\n * @return {number}\n */\nvar missingNumber = function(nums) {\n    \n};"
    },
    {
      "lang": "Ruby",
      "code": "# @param {Integer[]} nums\n# @return {Integer}\ndef missing_number(nums)\n    \nend"
    },
    {
      "lang": "Swift",
      "code": "class Solution {\n    func missingNumber(_ nums: [Int]) -> Int {\n        \n    }\n}"
    },
    {
      "lang": "Go",
      "code": "func missingNumber(nums []int) int {\n    \n}"
    },
    {
      "lang": "Scala",
      "code": "object Solution {\n    def missingNumber(nums: Array[Int]): Int = {\n        \n    }\n}"
    },
    {
      "lang": "Kotlin",
      "code": "class Solution {\n    fun missingNumber(nums: IntArray): Int {\n        \n    }\n}"
    },
    {
      "lang": "Rust",
      "code": "impl Solution {\n    pub fn missing_number(nums: Vec<i32>) -> i32 {\n        \n    }\n}"
    },
    {
      "lang": "PHP",
      "code": "class Solution {\n\n    /**\n     * @param Integer[] $nums\n     * @return Integer\n     */\n    function missingNumber($nums) {\n        \n    }\n}"
    }
  ],
  "stats": "{\"totalAccepted\": \"354.4K\", \"totalSubmission\": \"711.9K\", \"totalAcceptedRaw\": 354416, \"totalSubmissionRaw\": 711923, \"acRate\": \"49.8%\"}",
  "hints": [],
  "solution": {
    "id": "288",
    "canSeeDetail": true,
    "url": "/articles/missing-number/",
    "content": "[TOC]\n\n#### Approach #1 Sorting [Accepted]\n\n**Intuition**\n\nIf `nums` were in order, it would be easy to see which number is missing.\n\n**Algorithm**\n\nFirst, we sort `nums`. Then, we check the two special cases that can be\nhandled in constant time - ensuring that 0 is at the beginning and that $$n$$\nis at the end. Given that those assumptions hold, the missing number must\nsomewhere between (but not including) 0 and $$n$$. To find it, we ensure that\nthe number we expect to be at each index is indeed there. Because we handled\nthe edge cases, this is simply the previous number plus 1. Thus, as soon as\nwe find an unexpected number, we can simply return the expected number.\n\n<iframe src=\"https://leetcode.com/playground/BpPhWC2o/shared\" frameBorder=\"0\" width=\"100%\" height=\"480\" name=\"BpPhWC2o\"></iframe>\n\n**Complexity Analysis**\n\n* Time complexity : $$\\mathcal{O}(nlgn)$$\n\n    The only elements of the algorithm that have asymptotically nonconstant\n    time complexity are the main `for` loop (which runs in $$\\mathcal{O}(n)$$ time), and\n    the `sort` invocation (which runs in $$\\mathcal{O}(nlgn)$$ time for Python and Java).\n    Therefore, the runtime is dominated by `sort`, and the entire runtime is\n    $$\\mathcal{O}(nlgn)$$.\n\n* Space complexity : $$\\mathcal{O}(1)$$ (or $$\\mathcal{O}(n)$$)\n\n    In the sample code, we sorted `nums` in place, allowing us to avoid\n    allocating additional space. If modifying `nums` is forbidden, we can\n    allocate an $$\\mathcal{O}(n)$$ size copy and sort that instead.\n\n---\n\n#### Approach #2 HashSet [Accepted]\n\n**Intuition**\n\nA brute force method for solving this problem would be to simply check for\nthe presence of each number that we expect to be present. The naive\nimplementation might use a linear scan of the array to check for containment,\nbut we can use a `HashSet` to get constant time containment queries and\noverall linear runtime.\n\n**Algorithm**\n\nThis algorithm is almost identical to the brute force approach, except we\nfirst insert each element of `nums` into a set, allowing us to later query\nfor containment in $$\\mathcal{O}(1)$$ time.\n\n<iframe src=\"https://leetcode.com/playground/UBNtYrmj/shared\" frameBorder=\"0\" width=\"100%\" height=\"293\" name=\"UBNtYrmj\"></iframe>\n\n**Complexity Analysis**\n\n* Time complexity : $$\\mathcal{O}(n)$$\n\n    Because the set allows for $$\\mathcal{O}(1)$$ containment queries, the main loop\n    runs in $$\\mathcal{O}(n)$$ time. Creating `num_set` costs $$\\mathcal{O}(n)$$ time, as each set insertion\n    runs in amortized $$\\mathcal{O}(1)$$ time, so the overall runtime is $$\\mathcal{O}(n + n) = \\mathcal{O}(n)$$.\n\n* Space complexity : $$\\mathcal{O}(n)$$\n\n    `nums` contains $$n-1$$ distinct elements, so it costs $$\\mathcal{O}(n)$$ space to\n    store a set containing all of them.\n\n---\n\n#### Approach #3 Bit Manipulation [Accepted]\n\n**Intuition**\n\nWe can harness the fact that XOR is its own inverse to find the missing\nelement in linear time.\n\n**Algorithm**\n\nBecause we know that `nums` contains $$n$$ numbers and that it is missing\nexactly one number on the range $$[0..n-1]$$, we know that $$n$$ definitely\nreplaces the missing number in `nums`. Therefore, if we initialize an integer\nto $$n$$ and XOR it with every index and value, we will be left with the\nmissing number. Consider the following example (the values have been sorted\nfor intuitive convenience, but need not be):\n\n <table>\n  <tr>\n    <th>Index</th>\n    <td>0</td>\n    <td>1</td>\n    <td>2</td>\n    <td>3</td>\n  </tr>\n  <tr>\n    <th>Value</th>\n    <td>0</td>\n    <td>1</td>\n    <td>3</td>\n    <td>4</td>\n  </tr>\n</table> \n\n\n\n$$\n\\begin{align}\n    missing &= 4 \\wedge (0 \\wedge 0) \\wedge (1 \\wedge 1) \\wedge (2 \\wedge 3) \\wedge (3 \\wedge 4) \\\\\n            &= (4 \\wedge 4) \\wedge (0 \\wedge 0) \\wedge (1 \\wedge 1) \\wedge (3 \\wedge 3) \\wedge 2 \\\\\n            &= 0 \\wedge 0 \\wedge 0 \\wedge 0 \\wedge 2 \\\\ \n            &= 2\n\\end{align}\n$$\n\n<iframe src=\"https://leetcode.com/playground/SFZgajWR/shared\" frameBorder=\"0\" width=\"100%\" height=\"208\" name=\"SFZgajWR\"></iframe>\n\n**Complexity Analysis**\n\n* Time complexity : $$\\mathcal{O}(n)$$\n\n    Assuming that XOR is a constant-time operation, this algorithm does\n    constant work on $$n$$ iterations, so the runtime is overall linear.\n\n* Space complexity : $$\\mathcal{O}(1)$$\n\n    This algorithm allocates only constant additional space.\n\n---\n\n\n#### Approach #4 Gauss' Formula [Accepted]\n\n**Intuition**\n\nOne of the most well-known stories in mathematics is of a young Gauss, forced\nto find the sum of the first 100 natural numbers by a lazy teacher. Rather\nthan add the numbers by hand, he deduced a [closed-form\nexpression](https://brilliant.org/wiki/sum-of-n-n2-or-n3/) for the sum, or so\nthe story goes. You can see the formula below:\n\n$$\n    \\sum_{i=0}^{n}i = \\frac{n(n+1)}{2}\n$$\n\n**Algorithm**\n\nWe can compute the sum of `nums` in linear time, and by Gauss' formula, we\ncan compute the sum of the first $$n$$ natural numbers in constant time. Therefore,\nthe number that is missing is simply the result of Gauss' formula minus the sum of `nums`,\nas `nums` consists of the first $$n$$ natural numbers minus some number.\n\n<iframe src=\"https://leetcode.com/playground/3NM3eQvx/shared\" frameBorder=\"0\" width=\"100%\" height=\"191\" name=\"3NM3eQvx\"></iframe>\n\n**Complexity Analysis**\n\n* Time complexity : $$\\mathcal{O}(n)$$\n\n    Although Gauss' formula can be computed in $$\\mathcal{O}(1)$$ time, summing `nums`\n    costs us $$\\mathcal{O}(n)$$ time, so the algorithm is overall linear. Because we have\n    no information about _which_ number is missing, an adversary could always\n    design an input for which any algorithm that examines fewer than $$n$$\n    numbers fails. Therefore, this solution is asymptotically optimal.\n\n* Space complexity : $$\\mathcal{O}(1)$$\n\n    This approach only pushes a few integers around, so it has constant\n    memory usage.\n\n---\n\nAnalysis written by: [@emptyset](https://leetcode.com/emptyset)",
    "contentTypeId": "107",
    "rating": {
      "id": "283",
      "count": 50,
      "average": 4.6,
      "userRating": null
    }
  },
  "status": null,
  "sampleTestCase": "[3,0,1]",
  "metaData": "{\r\n  \"name\": \"missingNumber\",\r\n  \"params\": [\r\n    {\r\n      \"name\": \"nums\",\r\n      \"type\": \"integer[]\"\r\n    }\r\n  ],\r\n  \"return\": {\r\n    \"type\": \"integer\"\r\n  }\r\n}",
  "judgerAvailable": true,
  "judgeType": "large",
  "mysqlSchemas": [],
  "enableRunCode": true,
  "enableTestMode": false,
  "libraryUrl": null
}
