{
  "questionId": "270",
  "questionFrontendId": "270",
  "boundTopicId": null,
  "title": "Closest Binary Search Tree Value",
  "titleSlug": "closest-binary-search-tree-value",
  "categoryTitle": "Algorithms",
  "content": "<p>Given a non-empty binary search tree and a target value, find the value in the BST that is closest to the target.</p>\r\n\r\n<p><b>Note:</b></p>\r\n\r\n<ul>\r\n\t<li>Given target value is a floating point.</li>\r\n\t<li>You are guaranteed to have only one unique value in the BST that is closest to the target.</li>\r\n</ul>\r\n\r\n<p><strong>Example:</strong></p>\r\n\r\n<pre>\r\n<strong>Input:</strong> root = [4,2,5,1,3], target = 3.714286\r\n\r\n    4\r\n   / \\\r\n  2   5\r\n / \\\r\n1   3\r\n\r\n<strong>Output:</strong> 4\r\n</pre>\r\n",
  "isPaidOnly": true,
  "difficulty": "Easy",
  "likes": 532,
  "dislikes": 39,
  "isLiked": null,
  "similarQuestions": "[{\"title\": \"Count Complete Tree Nodes\", \"titleSlug\": \"count-complete-tree-nodes\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Closest Binary Search Tree Value II\", \"titleSlug\": \"closest-binary-search-tree-value-ii\", \"difficulty\": \"Hard\", \"translatedTitle\": null}, {\"title\": \"Search in a Binary Search Tree\", \"titleSlug\": \"search-in-a-binary-search-tree\", \"difficulty\": \"Easy\", \"translatedTitle\": null}]",
  "contributors": [],
  "topicTags": [
    {
      "name": "Binary Search",
      "slug": "binary-search"
    },
    {
      "name": "Tree",
      "slug": "tree"
    }
  ],
  "companyTagStats": "{\"1\": [{\"taggedByAdmin\": false, \"name\": \"Facebook\", \"slug\": \"facebook\", \"timesEncountered\": 10}, {\"taggedByAdmin\": false, \"name\": \"Amazon\", \"slug\": \"amazon\", \"timesEncountered\": 4}], \"2\": [{\"taggedByAdmin\": false, \"name\": \"Bloomberg\", \"slug\": \"bloomberg\", \"timesEncountered\": 3}, {\"taggedByAdmin\": true, \"name\": \"Microsoft\", \"slug\": \"microsoft\", \"timesEncountered\": 2}], \"3\": [{\"taggedByAdmin\": false, \"name\": \"LinkedIn\", \"slug\": \"linkedin\", \"timesEncountered\": 3}, {\"taggedByAdmin\": true, \"name\": \"Google\", \"slug\": \"google\", \"timesEncountered\": 0}, {\"taggedByAdmin\": true, \"name\": \"Snapchat\", \"slug\": \"snapchat\", \"timesEncountered\": 0}]}",
  "codeSnippets": [
    {
      "lang": "C++",
      "code": "/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\n * };\n */\nclass Solution {\npublic:\n    int closestValue(TreeNode* root, double target) {\n        \n    }\n};"
    },
    {
      "lang": "Java",
      "code": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode(int x) { val = x; }\n * }\n */\nclass Solution {\n    public int closestValue(TreeNode root, double target) {\n        \n    }\n}"
    },
    {
      "lang": "Python",
      "code": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, x):\n#         self.val = x\n#         self.left = None\n#         self.right = None\n\nclass Solution(object):\n    def closestValue(self, root, target):\n        \"\"\"\n        :type root: TreeNode\n        :type target: float\n        :rtype: int\n        \"\"\"\n        "
    },
    {
      "lang": "Python3",
      "code": "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, x):\n#         self.val = x\n#         self.left = None\n#         self.right = None\n\nclass Solution:\n    def closestValue(self, root: TreeNode, target: float) -> int:\n        "
    },
    {
      "lang": "C",
      "code": "/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     struct TreeNode *left;\n *     struct TreeNode *right;\n * };\n */\n\n\nint closestValue(struct TreeNode* root, double target){\n\n}\n\n"
    },
    {
      "lang": "C#",
      "code": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     public int val;\n *     public TreeNode left;\n *     public TreeNode right;\n *     public TreeNode(int x) { val = x; }\n * }\n */\npublic class Solution {\n    public int ClosestValue(TreeNode root, double target) {\n        \n    }\n}"
    },
    {
      "lang": "JavaScript",
      "code": "/**\n * Definition for a binary tree node.\n * function TreeNode(val) {\n *     this.val = val;\n *     this.left = this.right = null;\n * }\n */\n/**\n * @param {TreeNode} root\n * @param {number} target\n * @return {number}\n */\nvar closestValue = function(root, target) {\n    \n};"
    },
    {
      "lang": "Ruby",
      "code": "# Definition for a binary tree node.\n# class TreeNode\n#     attr_accessor :val, :left, :right\n#     def initialize(val)\n#         @val = val\n#         @left, @right = nil, nil\n#     end\n# end\n\n# @param {TreeNode} root\n# @param {Float} target\n# @return {Integer}\ndef closest_value(root, target)\n    \nend"
    },
    {
      "lang": "Swift",
      "code": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     public var val: Int\n *     public var left: TreeNode?\n *     public var right: TreeNode?\n *     public init(_ val: Int) {\n *         self.val = val\n *         self.left = nil\n *         self.right = nil\n *     }\n * }\n */\nclass Solution {\n    func closestValue(_ root: TreeNode?, _ target: Double) -> Int {\n        \n    }\n}"
    },
    {
      "lang": "Go",
      "code": "/**\n * Definition for a binary tree node.\n * type TreeNode struct {\n *     Val int\n *     Left *TreeNode\n *     Right *TreeNode\n * }\n */\nfunc closestValue(root *TreeNode, target float64) int {\n    \n}"
    },
    {
      "lang": "Scala",
      "code": "/**\n * Definition for a binary tree node.\n * class TreeNode(var _value: Int) {\n *   var value: Int = _value\n *   var left: TreeNode = null\n *   var right: TreeNode = null\n * }\n */\nobject Solution {\n    def closestValue(root: TreeNode, target: Double): Int = {\n        \n    }\n}"
    },
    {
      "lang": "Kotlin",
      "code": "/**\n * Example:\n * var ti = TreeNode(5)\n * var v = ti.`val`\n * Definition for a binary tree node.\n * class TreeNode(var `val`: Int) {\n *     var left: TreeNode? = null\n *     var right: TreeNode? = null\n * }\n */\nclass Solution {\n    fun closestValue(root: TreeNode?, target: Double): Int {\n        \n    }\n}"
    },
    {
      "lang": "Rust",
      "code": "// Definition for a binary tree node.\n// #[derive(Debug, PartialEq, Eq)]\n// pub struct TreeNode {\n//   pub val: i32,\n//   pub left: Option<Rc<RefCell<TreeNode>>>,\n//   pub right: Option<Rc<RefCell<TreeNode>>>,\n// }\n// \n// impl TreeNode {\n//   #[inline]\n//   pub fn new(val: i32) -> Self {\n//     TreeNode {\n//       val,\n//       left: None,\n//       right: None\n//     }\n//   }\n// }\nuse std::rc::Rc;\nuse std::cell::RefCell;\nimpl Solution {\n    pub fn closest_value(root: Option<Rc<RefCell<TreeNode>>>, target: f64) -> i32 {\n        \n    }\n}"
    },
    {
      "lang": "PHP",
      "code": "/**\n * Definition for a binary tree node.\n * class TreeNode {\n *     public $val = null;\n *     public $left = null;\n *     public $right = null;\n *     function __construct($value) { $this->val = $value; }\n * }\n */\nclass Solution {\n\n    /**\n     * @param TreeNode $root\n     * @param Float $target\n     * @return Integer\n     */\n    function closestValue($root, $target) {\n        \n    }\n}"
    }
  ],
  "stats": "{\"totalAccepted\": \"106.2K\", \"totalSubmission\": \"232.9K\", \"totalAcceptedRaw\": 106233, \"totalSubmissionRaw\": 232896, \"acRate\": \"45.6%\"}",
  "hints": [],
  "solution": {
    "id": "749",
    "canSeeDetail": true,
    "url": "/articles/closest-bst-value/",
    "content": "[TOC]\r\n\r\n## Solution\r\n\r\n--- \r\n\r\n#### Approach 1: Recursive Inorder + Linear search, O(N) time\r\n\r\n**Intuition**\r\n\r\nThe simplest approach (3 lines in Python) is to build inorder traversal\r\nand then find the closest element in a sorted array with built-in \r\nfunction `min`.  \r\n\r\n![pic](../Figures/270/dummy.png)\r\n\r\nThis approach is simple stupid, and serves to identify the subproblems.\r\n\r\n**Algorithm**\r\n\r\n- Build an inorder traversal array.\r\n\r\n- Find the closest to target element in that array.\r\n\r\n**Implementation**\r\n\r\n<iframe src=\"https://leetcode.com/playground/VAh2FLh5/shared\" frameBorder=\"0\" width=\"100%\" height=\"378\" name=\"VAh2FLh5\"></iframe>\r\n\r\n**Complexity Analysis**\r\n\r\n* Time complexity : $$\\mathcal{O}(N)$$ because to build inorder traversal\r\nand then to perform linear search takes linear time.\r\n* Space complexity : $$\\mathcal{O}(N)$$ to keep inorder traversal.\r\n<br /> \r\n<br />\r\n\r\n\r\n---\r\n#### Approach 2: Iterative Inorder, O(k) time\r\n\r\n**Intuition**\r\n\r\nLet's optimise Approach 1 in the case when index k of the closest \r\nelement is much smaller than the tree heigh H.\r\n\r\nFirst, one could merge both steps by traversing the tree and \r\nsearching the closest value at the same time.  \r\n\r\nSecond, one could stop just after identifying the closest value, there \r\nis no need to traverse the whole tree. \r\nThe closest value is found if the target value is \r\nin-between of two inorder array elements \r\n`nums[i] <= target < nums[i + 1]`. Then the closest value\r\nis one of these elements.\r\n\r\n![pic](../Figures/270/iteration.png)\r\n\r\n**Algorithm**\r\n\r\n- Initiate stack as an empty array and predecessor value as a very small \r\nnumber.\r\n\r\n- While root is not null:\r\n\r\n    - To build an inorder traversal iteratively, \r\n    go left as far as you can and add all nodes on the way into stack.\r\n    \r\n    - Pop the last element from stack `root = stack.pop()`. \r\n\r\n    - If target is in-between of `pred` and `root.val`, return \r\n    the closest between these two elements.\r\n    \r\n    - Set predecessor value to be equal to `root.val` and go one\r\n    step right: `root = root.right`.\r\n    \r\n- We're here because during the loop one couldn't \r\nidentify the closest value. That means that the closest value is\r\nthe last value in the inorder traversal, \r\ni.e. current predecessor value. Return it. \r\n\r\n**Implementation**\r\n\r\n<iframe src=\"https://leetcode.com/playground/m7P2sc4S/shared\" frameBorder=\"0\" width=\"100%\" height=\"412\" name=\"m7P2sc4S\"></iframe>\r\n\r\n**Complexity Analysis**\r\n\r\n* Time complexity : $$\\mathcal{O}(k)$$ in the average case and \r\n$$\\mathcal{O}(H + k)$$ in the worst case, \r\nwhere k is an index of closest element. \r\nIt's known that [average case is a balanced tree](https://pages.cpsc.ucalgary.ca/~jacobs/Courses/cpsc331/F08/notes/lecture17.pdf),\r\nin that case stack always contains a few elements, and hence \r\none does $$2k$$ operations to go to kth element in \r\ninorder traversal (k times to push into stack and \r\nthen k times to pop out of stack). That results in\r\n$$\\mathcal{O}(k)$$ time complexity.\r\nThe worst case is a completely unbalanced tree, then you \r\nfirst push H elements into stack and then pop out k elements,\r\nthat results in $$\\mathcal{O}(H + k)$$ time complexity.\r\n\r\n![pic](../Figures/270/unbalanced.png)\r\n\r\n* Space complexity : up to $$\\mathcal{O}(H)$$ to keep the stack\r\nin the case of non-balanced tree.\r\n<br /> \r\n<br />\r\n\r\n\r\n---\r\n#### Approach 3: Binary Search, O(H) time \r\n\r\n**Intuition**\r\n\r\nApproach 2 works fine when index k of closest element \r\nis much smaller than the tree height H.  \r\n\r\nLet's now consider another limit and optimise Approach 1 in the \r\ncase of relatively large k, comparable with N. \r\n\r\nThen it makes sense to use a binary search: \r\ngo left if target is smaller than current root value,\r\nand go right otherwise. Choose the closest to target value at each step.\r\n\r\n![pic](../Figures/270/binary.png)\r\n\r\nKudos for this solution go to @[stefanpochmann](https://leetcode.com/stefanpochmann/).  \r\n\r\n**Implementation**\r\n\r\n<iframe src=\"https://leetcode.com/playground/nXxS778P/shared\" frameBorder=\"0\" width=\"100%\" height=\"242\" name=\"nXxS778P\"></iframe>\r\n\r\n**Complexity Analysis**\r\n\r\n* Time complexity : $$\\mathcal{O}(H)$$ since here one goes from \r\nroot down to a leaf.\r\n\r\n* Space complexity : $$\\mathcal{O}(1)$$.\r\n    \r\nAnalysis written by @[liaison](https://leetcode.com/liaison/)\r\nand @[andvary](https://leetcode.com/andvary/)",
    "contentTypeId": "107",
    "rating": {
      "id": "734",
      "count": 9,
      "average": 4.778,
      "userRating": null
    }
  },
  "status": null,
  "sampleTestCase": "[4,2,5,1,3]\n3.714286",
  "metaData": "{\r\n  \"name\": \"closestValue\",\r\n  \"params\": [\r\n    {\r\n      \"name\": \"root\",\r\n      \"type\": \"TreeNode\"\r\n    },\r\n    {\r\n      \"name\": \"target\",\r\n      \"type\": \"double\"\r\n    }\r\n  ],\r\n  \"return\": {\r\n    \"type\": \"integer\"\r\n  }\r\n}",
  "judgerAvailable": true,
  "judgeType": "large",
  "mysqlSchemas": [],
  "enableRunCode": true,
  "enableTestMode": false,
  "libraryUrl": null
}
