{
  "questionId": "282",
  "questionFrontendId": "282",
  "boundTopicId": null,
  "title": "Expression Add Operators",
  "titleSlug": "expression-add-operators",
  "categoryTitle": "Algorithms",
  "content": "<p>Given a string that contains only digits <code>0-9</code> and a target value, return all possibilities to add <b>binary</b> operators (not unary) <code>+</code>, <code>-</code>, or <code>*</code> between the digits so they evaluate to the target value.</p>\r\n\r\n<p><b>Example 1:</b></p>\r\n\r\n<pre>\r\n<b>Input:</b> <code><em>num</em> = </code>&quot;123&quot;, <em>target</em> = 6\r\n<b>Output: </b>[&quot;1+2+3&quot;, &quot;1*2*3&quot;] \r\n</pre>\r\n\r\n<p><b>Example 2:</b></p>\r\n\r\n<pre>\r\n<b>Input:</b> <code><em>num</em> = </code>&quot;232&quot;, <em>target</em> = 8\r\n<b>Output: </b>[&quot;2*3+2&quot;, &quot;2+3*2&quot;]</pre>\r\n\r\n<p><b>Example 3:</b></p>\r\n\r\n<pre>\r\n<b>Input:</b> <code><em>num</em> = </code>&quot;105&quot;, <em>target</em> = 5\r\n<b>Output: </b>[&quot;1*0+5&quot;,&quot;10-5&quot;]</pre>\r\n\r\n<p><b>Example 4:</b></p>\r\n\r\n<pre>\r\n<b>Input:</b> <code><em>num</em> = </code>&quot;00&quot;, <em>target</em> = 0\r\n<b>Output: </b>[&quot;0+0&quot;, &quot;0-0&quot;, &quot;0*0&quot;]\r\n</pre>\r\n\r\n<p><b>Example 5:</b></p>\r\n\r\n<pre>\r\n<b>Input:</b> <code><em>num</em> = </code>&quot;3456237490&quot;, <em>target</em> = 9191\r\n<b>Output: </b>[]\r\n</pre>\r\n",
  "isPaidOnly": false,
  "difficulty": "Hard",
  "likes": 907,
  "dislikes": 135,
  "isLiked": null,
  "similarQuestions": "[{\"title\": \"Evaluate Reverse Polish Notation\", \"titleSlug\": \"evaluate-reverse-polish-notation\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Basic Calculator\", \"titleSlug\": \"basic-calculator\", \"difficulty\": \"Hard\", \"translatedTitle\": null}, {\"title\": \"Basic Calculator II\", \"titleSlug\": \"basic-calculator-ii\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Different Ways to Add Parentheses\", \"titleSlug\": \"different-ways-to-add-parentheses\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Target Sum\", \"titleSlug\": \"target-sum\", \"difficulty\": \"Medium\", \"translatedTitle\": null}]",
  "contributors": [
    {
      "username": "davidtan1890",
      "profileUrl": "/davidtan1890/",
      "avatarUrl": "https://www.gravatar.com/avatar/ea94775da7c5583cbc7481b39d873c32.png?s=200"
    }
  ],
  "topicTags": [
    {
      "name": "Divide and Conquer",
      "slug": "divide-and-conquer"
    }
  ],
  "companyTagStats": "{\"1\": [{\"taggedByAdmin\": true, \"name\": \"Facebook\", \"slug\": \"facebook\", \"timesEncountered\": 18}], \"3\": [{\"taggedByAdmin\": false, \"name\": \"LinkedIn\", \"slug\": \"linkedin\", \"timesEncountered\": 5}, {\"taggedByAdmin\": false, \"name\": \"Microsoft\", \"slug\": \"microsoft\", \"timesEncountered\": 2}], \"2\": [{\"taggedByAdmin\": true, \"name\": \"Google\", \"slug\": \"google\", \"timesEncountered\": 3}, {\"taggedByAdmin\": false, \"name\": \"Apple\", \"slug\": \"apple\", \"timesEncountered\": 2}, {\"taggedByAdmin\": false, \"name\": \"Snapchat\", \"slug\": \"snapchat\", \"timesEncountered\": 2}]}",
  "codeSnippets": [
    {
      "lang": "C++",
      "code": "class Solution {\npublic:\n    vector<string> addOperators(string num, int target) {\n        \n    }\n};"
    },
    {
      "lang": "Java",
      "code": "class Solution {\n    public List<String> addOperators(String num, int target) {\n        \n    }\n}"
    },
    {
      "lang": "Python",
      "code": "class Solution(object):\n    def addOperators(self, num, target):\n        \"\"\"\n        :type num: str\n        :type target: int\n        :rtype: List[str]\n        \"\"\"\n        "
    },
    {
      "lang": "Python3",
      "code": "class Solution:\n    def addOperators(self, num: str, target: int) -> List[str]:\n        "
    },
    {
      "lang": "C",
      "code": "\n\n/**\n * Note: The returned array must be malloced, assume caller calls free().\n */\nchar ** addOperators(char * num, int target, int* returnSize){\n\n}\n\n"
    },
    {
      "lang": "C#",
      "code": "public class Solution {\n    public IList<string> AddOperators(string num, int target) {\n        \n    }\n}"
    },
    {
      "lang": "JavaScript",
      "code": "/**\n * @param {string} num\n * @param {number} target\n * @return {string[]}\n */\nvar addOperators = function(num, target) {\n    \n};"
    },
    {
      "lang": "Ruby",
      "code": "# @param {String} num\n# @param {Integer} target\n# @return {String[]}\ndef add_operators(num, target)\n    \nend"
    },
    {
      "lang": "Swift",
      "code": "class Solution {\n    func addOperators(_ num: String, _ target: Int) -> [String] {\n        \n    }\n}"
    },
    {
      "lang": "Go",
      "code": "func addOperators(num string, target int) []string {\n    \n}"
    },
    {
      "lang": "Scala",
      "code": "object Solution {\n    def addOperators(num: String, target: Int): List[String] = {\n        \n    }\n}"
    },
    {
      "lang": "Kotlin",
      "code": "class Solution {\n    fun addOperators(num: String, target: Int): List<String> {\n        \n    }\n}"
    },
    {
      "lang": "Rust",
      "code": "impl Solution {\n    pub fn add_operators(num: String, target: i32) -> Vec<String> {\n        \n    }\n}"
    },
    {
      "lang": "PHP",
      "code": "class Solution {\n\n    /**\n     * @param String $num\n     * @param Integer $target\n     * @return String[]\n     */\n    function addOperators($num, $target) {\n        \n    }\n}"
    }
  ],
  "stats": "{\"totalAccepted\": \"84.2K\", \"totalSubmission\": \"245.3K\", \"totalAcceptedRaw\": 84169, \"totalSubmissionRaw\": 245327, \"acRate\": \"34.3%\"}",
  "hints": [
    "Note that a number can contain multiple digits.",
    "Since the question asks us to find <b>all</b> of the valid expressions, we need a way to iterate over all of them. (<b>Hint:</b> Recursion!)",
    "We can keep track of the expression string and evaluate it at the very end. But that would take a lot of time. Can we keep track of the expression's value as well so as to avoid the evaluation at the very end of recursion?",
    "Think carefully about the multiply operator. It has a higher precedence than the addition and subtraction operators. \r\n\r\n<br> 1 + 2 = 3  <br>\r\n1 + 2 - 4 --> 3 - 4 --> -1 <br>\r\n1 + 2 - 4 * 12 --> -1 * 12 --> -12 (WRONG!) <br>\r\n1 + 2 - 4 * 12 --> -1 - (-4) + (-4 * 12) --> 3 + (-48) --> -45 (CORRECT!)",
    "We simply need to keep track of the last operand in our expression and reverse it's effect on the expression's value while considering the multiply operator."
  ],
  "solution": {
    "id": "548",
    "canSeeDetail": true,
    "url": "/articles/expression-add-operators/",
    "content": "[TOC]\n\n## Solution\n---\n\n#### Approach 1: Backtracking\n\n**Intuition**\n\nLet us first look at what the question asks us to do before getting at the approach to solve it. So, we are given a string of numbers and 3 different operators:\n\n* `+` Addition,\n* `-` Subtraction or\n* `*` Multiplication\n\nWe have to find all possible combinations of binary operators between the digits so that the overall value of the resulting expression becomes equal to a given target value. Let us look at a few possibilities of what it means exactly to *place the operators between digits* so that the question becomes clearer.\n\nLet's say we are given the following set of digits `\"123456789\"` and the target value given to us is `45`. Let us see some of the possible resulting expressions that we can get by placing the operators in different locations.\n\n<pre>\n1 + 2 + 3 + 4 + 5 + 6 + 7 + 8 + 9 = 45\n1 + 2 - 3 + 4 - 5 + 6 - 7 + 8 - 9 = -3\n1 + 2 * 3 - 4 + 5 + 6 - 7 * 8 - 9 = -51\n1 + 2 + 3 + 4 + 5 - 6 * 7 + 8 * 9 = 45\n</pre>\n\nThese are just 4 of the many resulting expressions that are possible by using the given string of digits and the three operators.\n\nBy looking at the above examples we can't really figure out any specific pattern among the resulting expressions that tells us which of them will give us the resulting target.\n\nSince the question explicitly states that we are given binary operators, this means that each of the operator would require two operands.\n\n> We can consider each of our digits as an operand.\n\nThis means that between every pair of digits we can have any of the three operators i.e. $$+$$, $$-$$ or $$\\times$$.\n\nIf you've looked at the question's statement and the examples that are given in the question, you would realize that there is an example where the digits are `\"105\"` and the target value is `5`. For this particular example, there are two expressions given to us and they are `1*0+5` and `10-5`.\n\nThe second expression is something that you need to look out for before getting to solve this question because this complicates things a bit.\n\nIt would have been an easier question to solve if we just had to consider those expressions that simply had *digits as operands*.\n\nBut, in this question, we can have all sorts of digits getting together and forming a bigger number that becomes a part of the expression. Let us look at some example expressions for the digits `\"123456\"` and target `30`.\n\n<pre>\n1 * 23 - 4 + 5 + 6 = 30\n12 - 3 * 4 + 5 * 6 = 30\n1 - 23 - 4 + 56 = 30\n</pre>\n\nSo this means that although the number of operators are defined for us i.e. 3 different binary operators, but the number of operands are **not really well defined for us**.\n\nThis is a big portion of the original problem that we need to address in our solution.\n\nSince we are asked to find out all of the valid expressions whose value equals the given target and we don't really know what specific operator between two operands would eventually give us a valid expression,\n\n> We try out all of the options.\n\nThis means once we have defined what the operands are for our given expression, we would have three possible choices of operators between each consecutive pair of operands.\n\nFrom an implementation perspective, what would an operand imply with respect to our original string?\n\n> An operand would be an integer formed from a substring of our original string.\n\nLet's look at two different array partitions for the given string `\"123456789\"`\n\n<center>\n<img src=\"../Figures/282/282_Expression_Add_Operators_Diag_1.png\" height=\"300\"></center>\n\nSince we are required to return all of the valid expressions that evaluate to a given target value, we have to try all possible partitions of the given array thereby considering all of the possible operands that can be formed from the digits.\n\nThere is a very simple way of incorporating this into our algorithm. Right now, at every point in the algorithm, we have three different choices corresponding to the three different operators.\n\n>The way we incorporate these partitions is by considering a 4th operator as well which simply moves one step forward and extends the current operand by one digit. Essentially, going from 12 --> 123 is a NO OP operand in our implementation. (12 * 10) + 3.\n\nNow we have 4 different recursion paths in our algorithm and we have to try out all of them to see which ones lead to a potential solution.\n\nThis `try out everything` hints at a backtracking solution and that is exactly what we are going to look at here.\n\n**Algorithm**\n\nLet's quickly look at the steps involved in our backtracking algorithm before looking at the pseudo-code.\n\n1. As discussed above, we have multiple choices of what operators to use and what the operands can be and hence, we have to look at all the possibilities to find ***all*** valid expressions.\n2. Our recursive call will have an `index` which represents the current digit we're looking at in the original `nums` string and also the expression string built till now.\n3. At every step, we have exactly 4 different recursive calls. The `NO OP` call simply extends the `current_operand` by the current digit and moves ahead. Rest of the recursive calls correspond to `+`, `-`, and `*`.\n4. We keep on building our expression like this and eventually, the entire `nums` string would be processed. At that time we check if the expression we built till now is a valid expression or not and we record it if it is a valid one.\n\n<pre>\n1. procedure recurse(digits, index, expression):\n2.     if we have reached the end of the string:\n3.         if the expression evaluates to the target:\n4.             Valid Expression found!\n5.     else:\n6.         try out operator 'NO OP' and recurse\n7.         try out operator * and recurse\n8.         try out operator + and recurse\n9.         try out operator - and recurse\n</pre>\n\nThe algorithm now looks pretty straightforward. However, the implementation is something that needs more thought and there are some things that we need to address before actually looking at the implementation.\n\nWhen we are done building an expression out of all of the digits in our original string i.e. the base case, then we check if the expression is a valid expression or not. Right ?\n\n> How do we actually check if an expression is a valid one or not if all we have is a string representing the expression and not the integer value for the same?\n\nWell, one way to go about this is to write a custom `eval` function that takes in a string and returns the value of that expression. If you do that (Python people can use the inbuilt function `eval` for this), you will get a TLE i.e. time limit exceeded error.\n\n<br/>\n\n**Can't we keep track of the expression's value on the fly?**\n\nWell yes. That's the idea we will go with. Instead of just keeping track of what the expression string is, we will also keep track of it's value along the way so that when the recursion hits the base case, we can check in $$O(1)$$ time if the expression's value equals the target value or not.\n\nThe implementation would have been straightforward had it just been `+` and `-` operators involved. This is because both these operators have an equal precedence. That means that we can continue to evaluate the expression on the fly without any problems. Have a look at the following example.\n\n<center>\n<img src=\"../Figures/282/282_Expression_Add_Operators_Diag_2.png\" width=\"550\"></center>\n\nSo far so good. Now let us add the `*` operator as well and see how building the expression on the fly like this breaks.\n\n<center>\n<img src=\"../Figures/282/282_Expression_Add_Operators_Diag_3.png\" width=\"550\"></center>\n\nWhat we mean by building the expression on the fly is that we keep track of the expression's value till now and we simply consider that value as one of the two operands for our operators. As we can see from the two examples above, this would have worked had it just been `+` and `-` operators.\n\nBut, this approach is bound to fail because the `*` operator takes precedence over `+` and `-`. The `*` operator would require the ***actual*** previous operand in our expression rather than the current value of the expression. i.e. In the above example, the `*` operator needed `2` rather than `12` to get us the correct value of `18`.\n\n<br/>\n\n**How to handle this?**\n\nThe idea on how to handle this problem springs from the discussion above. We simply need to keep track of the last operand in our expression and how it modified the expression's value overall so that when we consider the `*` operator, we can **reverse** the effects of the previous operand and consider it for multiplication. Let's take a look at the example that was breaking before.\n\n<center>\n<img src=\"../Figures/282/282_Expression_Add_Operators_Diag_4.png\" width=\"550\"></center>\n\nNow we can look at the actual implementation of this algorithm.\n\n<iframe src=\"https://leetcode.com/playground/BFyUVxwz/shared\" frameBorder=\"0\" width=\"100%\" height=\"500\" name=\"BFyUVxwz\"></iframe>\n\n**Complexity Analysis**\n\n* Time Complexity:\n    * At every step along the way, we consider exactly 4 different choices or 4 different recursive paths. The base case is when the value of `index` reaches $$N$$ i.e. the length of the `nums` array. Hence, our complexity would be $$O(4^N)$$.\n    * For the base case we use a `StringBuilder::toString` operation in Java and `.join()` operation in Python and that takes $$O(N)$$ time. Here $$N$$ represents the length of our expression. In the worst case, each digit would be an operand and we would have $$N$$ digits and $$N - 1$$ operators. So $$O(N)$$. This is for one expression. In the worst case, we can have $$O(4^N)$$ valid expressions.\n    * Overall time complexity = $$O(N \\times 4^N)$$.\n\n* Space Complexity:\n    * For both Python and Java implementations we have a list data structure that we update on the fly and only for valid expressions do we create a new string and add to our `answers` array. So, the space occupied by the intermediate list would be $$O(N)$$ since in the worst case the expression would be built out of all the digits as operands.\n    * Additionally, the space used up by the recursion stack would also be $$O(N)$$ since the size of recursion stack is determined by the value of `index` and it goes from $$0$$ all the way to $$N$$.\n    * We don't consider the space occupied by the `answers` array since that is a part of the question's requirement and we can't reduce that in any way\n\n**EDIT:**\nThe previous implementation of the algorithm, although correct, lead me to write an incorrect complexity analysis section. I've re-written the algorithm from scratch and corrected the complexity analysis as well. Sorry for the inconvenience to all the readers. The core idea of the algorithm is still the same. That hasn't changed.\n\nSpecial thanks to [@ufarooqi](https://leetcode.com/ufarooqi/), [@vortexwolf](https://leetcode.com/vortexwolf) for providing correct complexity analysis in the discussion forum leading to corrections in the article. Pardon me if I've missed out on any other names :)\n\n<br />\n\n---\n\nAnalysis written by: [@sachinmalhotra1993](https://leetcode.com/sachinmalhotra1993).",
    "contentTypeId": "107",
    "rating": {
      "id": "539",
      "count": 47,
      "average": 3.979,
      "userRating": null
    }
  },
  "status": null,
  "sampleTestCase": "\"123\"\n6",
  "metaData": "{\r\n    \"name\":\"addOperators\",\r\n    \"params\":[\r\n        {\r\n            \"name\":\"num\",\r\n            \"type\":\"string\"\r\n        },\r\n        {\r\n            \"name\":\"target\",\r\n            \"type\":\"integer\"\r\n        }\r\n    ],\r\n    \"return\":{\r\n        \"type\":\"list<string>\"\r\n    }\r\n}",
  "judgerAvailable": true,
  "judgeType": "large",
  "mysqlSchemas": [],
  "enableRunCode": true,
  "enableTestMode": false,
  "libraryUrl": null
}
