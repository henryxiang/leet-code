{
  "questionId": "285",
  "questionFrontendId": "285",
  "boundTopicId": null,
  "title": "Inorder Successor in BST",
  "titleSlug": "inorder-successor-in-bst",
  "categoryTitle": "Algorithms",
  "content": "<p>Given a binary search tree and a node in it, find the in-order successor of that node in the BST.</p>\r\n\r\n<p>The successor of a node&nbsp;<code>p</code>&nbsp;is the node with the smallest key greater than&nbsp;<code>p.val</code>.</p>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p><strong>Example 1:</strong></p>\r\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2019/01/23/285_example_1.PNG\" style=\"width: 122px; height: 117px;\" />\r\n<pre>\r\n<strong>Input: </strong>root = <span id=\"example-input-1-1\">[2,1,3]</span>, p = <span id=\"example-input-1-2\">1</span>\r\n<strong>Output: </strong><span id=\"example-output-1\">2</span>\r\n<strong>Explanation: </strong>1&#39;s in-order successor node is 2. Note that both p and the return value is of TreeNode type.\r\n</pre>\r\n\r\n<p><strong>Example 2:</strong></p>\r\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2019/01/23/285_example_2.PNG\" style=\"width: 246px; height: 229px;\" />\r\n<pre>\r\n<strong>Input: </strong>root = <span id=\"example-input-2-1\">[5,3,6,2,4,null,null,1]</span>, p = <span id=\"example-input-2-2\">6</span>\r\n<strong>Output: </strong><span id=\"example-output-2\">null</span>\r\n<strong>Explanation: </strong>There is no in-order successor of the current node, so the answer is <code>null</code>.\r\n</pre>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p><strong>Note:</strong></p>\r\n\r\n<ol>\r\n\t<li>If the given node has no in-order successor in the tree, return <code>null</code>.</li>\r\n\t<li>It&#39;s guaranteed that the values of the tree are unique.</li>\r\n</ol>\r\n",
  "isPaidOnly": true,
  "difficulty": "Medium",
  "likes": 888,
  "dislikes": 55,
  "isLiked": null,
  "similarQuestions": "[{\"title\": \"Binary Tree Inorder Traversal\", \"titleSlug\": \"binary-tree-inorder-traversal\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Binary Search Tree Iterator\", \"titleSlug\": \"binary-search-tree-iterator\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Inorder Successor in BST II\", \"titleSlug\": \"inorder-successor-in-bst-ii\", \"difficulty\": \"Medium\", \"translatedTitle\": null}]",
  "contributors": [],
  "topicTags": [
    {
      "name": "Tree",
      "slug": "tree"
    }
  ],
  "companyTagStats": "{\"2\": [{\"taggedByAdmin\": true, \"name\": \"Microsoft\", \"slug\": \"microsoft\", \"timesEncountered\": 5}, {\"taggedByAdmin\": true, \"name\": \"Facebook\", \"slug\": \"facebook\", \"timesEncountered\": 4}, {\"taggedByAdmin\": false, \"name\": \"Amazon\", \"slug\": \"amazon\", \"timesEncountered\": 3}], \"1\": [{\"taggedByAdmin\": false, \"name\": \"Google\", \"slug\": \"google\", \"timesEncountered\": 2}, {\"taggedByAdmin\": false, \"name\": \"Quip (Salesforce)\", \"slug\": \"quip\", \"timesEncountered\": 2}], \"3\": [{\"taggedByAdmin\": false, \"name\": \"Palantir Technologies\", \"slug\": \"palantir-technologies\", \"timesEncountered\": 3}, {\"taggedByAdmin\": true, \"name\": \"Pocket Gems\", \"slug\": \"pocket-gems\", \"timesEncountered\": 0}]}",
  "codeSnippets": [
    {
      "lang": "C++",
      "code": "/**\r\n * Definition for a binary tree node.\r\n * struct TreeNode {\r\n *     int val;\r\n *     TreeNode *left;\r\n *     TreeNode *right;\r\n *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\r\n * };\r\n */\r\nclass Solution {\r\npublic:\r\n    TreeNode* inorderSuccessor(TreeNode* root, TreeNode* p) {\r\n        \r\n    }\r\n};"
    },
    {
      "lang": "Java",
      "code": "/**\r\n * Definition for a binary tree node.\r\n * public class TreeNode {\r\n *     int val;\r\n *     TreeNode left;\r\n *     TreeNode right;\r\n *     TreeNode(int x) { val = x; }\r\n * }\r\n */\r\nclass Solution {\r\n    public TreeNode inorderSuccessor(TreeNode root, TreeNode p) {\r\n        \r\n    }\r\n}"
    },
    {
      "lang": "Python",
      "code": "# Definition for a binary tree node.\r\n# class TreeNode(object):\r\n#     def __init__(self, x):\r\n#         self.val = x\r\n#         self.left = None\r\n#         self.right = None\r\n\r\nclass Solution(object):\r\n    def inorderSuccessor(self, root, p):\r\n        \"\"\"\r\n        :type root: TreeNode\r\n        :type p: TreeNode\r\n        :rtype: TreeNode\r\n        \"\"\"\r\n        "
    },
    {
      "lang": "Python3",
      "code": "# Definition for a binary tree node.\r\n# class TreeNode:\r\n#     def __init__(self, x):\r\n#         self.val = x\r\n#         self.left = None\r\n#         self.right = None\r\n\r\nclass Solution:\r\n    def inorderSuccessor(self, root: 'TreeNode', p: 'TreeNode') -> 'TreeNode':\r\n        "
    },
    {
      "lang": "C",
      "code": "/**\r\n * Definition for a binary tree node.\r\n * struct TreeNode {\r\n *     int val;\r\n *     struct TreeNode *left;\r\n *     struct TreeNode *right;\r\n * };\r\n */\r\nstruct TreeNode* inorderSuccessor(struct TreeNode* root, struct TreeNode* p) {\r\n    \r\n}"
    },
    {
      "lang": "C#",
      "code": "/**\r\n * Definition for a binary tree node.\r\n * public class TreeNode {\r\n *     public int val;\r\n *     public TreeNode left;\r\n *     public TreeNode right;\r\n *     public TreeNode(int x) { val = x; }\r\n * }\r\n */\r\npublic class Solution {\r\n    public TreeNode InorderSuccessor(TreeNode root, TreeNode p) {\r\n        \r\n    }\r\n}"
    },
    {
      "lang": "JavaScript",
      "code": "/**\r\n * Definition for a binary tree node.\r\n * function TreeNode(val) {\r\n *     this.val = val;\r\n *     this.left = this.right = null;\r\n * }\r\n */\r\n/**\r\n * @param {TreeNode} root\r\n * @param {TreeNode} p\r\n * @return {TreeNode}\r\n */\r\nvar inorderSuccessor = function(root, p) {\r\n    \r\n};"
    },
    {
      "lang": "Ruby",
      "code": "# Definition for a binary tree node.\r\n# class TreeNode\r\n#     attr_accessor :val, :left, :right\r\n#     def initialize(val)\r\n#         @val = val\r\n#         @left, @right = nil, nil\r\n#     end\r\n# end\r\n\r\n# @param {TreeNode} root\r\n# @param {TreeNode} p\r\n# @return {TreeNode}\r\ndef inorder_successor(root, p)\r\n    \r\nend"
    },
    {
      "lang": "Go",
      "code": "/**\r\n * Definition for a binary tree node.\r\n * type TreeNode struct {\r\n *     Val int\r\n *     Left *TreeNode\r\n *     Right *TreeNode\r\n * }\r\n */\r\nfunc inorderSuccessor(root *TreeNode, p *TreeNode) *TreeNode {\r\n    \r\n}"
    }
  ],
  "stats": "{\"totalAccepted\": \"127.3K\", \"totalSubmission\": \"340.1K\", \"totalAcceptedRaw\": 127293, \"totalSubmissionRaw\": 340111, \"acRate\": \"37.4%\"}",
  "hints": [],
  "solution": {
    "id": "759",
    "canSeeDetail": true,
    "url": "/articles/inorder-successor-in-bst/",
    "content": "[TOC]\r\n\r\n## Solution\r\n\r\n--- \r\n\r\n#### Approach 1: Iterative Inorder Traversal\r\n\r\n[Inorder traversal of BST \r\nis an array sorted in the ascending order](https://leetcode.com/articles/delete-node-in-a-bst/). \r\n\r\n> Successor is the smallest node in the inorder traversal \r\n_after_ the current one. \r\n\r\nThere could be two situations :\r\n\r\n1. If the node has a right child, the successor is somewhere lower\r\nin the tree, see red nodes on the Fig. below.\r\n\r\n2. Otherwise, the successor is somewhere upper in the tree,\r\nsee blue nodes on the Fig.\r\n\r\n![img](../Figures/285/succ.png)\r\n\r\nLet's first check the simple case 1.\r\nTo find a successor, go one step right \r\nand then left till you can. \r\n\r\n![pic](../Figures/285/right.png)\r\n\r\nThis approach has $$\\mathcal{O}(H_p)$$ time complexity,\r\nwhere $$H_p$$ is a height of the node $$p$$.\r\n\r\nNow let's consider the case 2. \r\nThere is no access to the parent nodes here,\r\nand hence one has to traverse the \r\ntree starting from the root and _not_ from the node. \r\n\r\n[Inorder traversal could be implemented in three \r\ndifferent ways: recursive, iterative and Morris](https://leetcode.com/articles/recover-binary-search-tree/).\r\nHere it's better to choose the iterative traversal \r\nin order to optimise the performance and minimize the space\r\nat the same time. \r\n\r\n> Iterative inorder traversal is simple: \r\ngo left till you can, and then one step right. \r\nRepeat till the end of nodes in the tree.\r\n\r\nThe idea is to keep just one previous node during the \r\ninorder traversal. If that previous node is equal to `p`,\r\nthen the current node is a successor of `p`.  \r\n\r\n![pac](../Figures/285/case2.png)\r\n\r\nThis approach has $$\\mathcal{O}(H)$$ time complexity,\r\nwhere $$H$$ is a tree height. Basically, this \r\napproach is universal and could be used for the case 1 as well. \r\nWe simply don't do that because the approach 1 is faster. \r\n\r\n**Algorithm**\r\n\r\n- If the node has a right child, \r\ngo one step right and then left till you can.\r\nReturn the successor.\r\n\r\n- Otherwise, implement iterative inorder traversal. \r\nWhile there are still nodes in the tree or in the stack:\r\n    \r\n    - Go left till you can, adding nodes in stack. \r\n    \r\n    - Pop out the last node. \r\n    If its predecessor is equal to `p`, return that last node.\r\n    Otherwise, save that node to be the predecessor\r\n    in the next turn of the loop.\r\n    \r\n    - Go one step right.\r\n    \r\n- If we're here that means the successor doesn't exit.\r\nReturn null. \r\n\r\n**Implementation**\r\n\r\n<iframe src=\"https://leetcode.com/playground/hmCctmx9/shared\" frameBorder=\"0\" width=\"100%\" height=\"500\" name=\"hmCctmx9\"></iframe>\r\n\r\n**Complexity Analysis**\r\n\r\n* Time complexity : $$\\mathcal{O}(H_p)$$ in the best case,\r\nwhen node `p` has a right child. Here $$H_p$$ is a height of node `p`.\r\n$$\\mathcal{O}(H)$$ in the worst case of no right child. \r\nHere $$H$$ is a tree height.\r\n\r\n* Space complexity : $$\\mathcal{O}(1)$$ in the best case,\r\nwhen node `p` has a right child. Otherwise, up to $$\\mathcal{O}(H)$$ \r\nto keep the stack.\r\n\r\nAnalysis written by @[liaison](https://leetcode.com/liaison/)\r\nand @[andvary](https://leetcode.com/andvary/)",
    "contentTypeId": "107",
    "rating": {
      "id": "744",
      "count": 13,
      "average": 4.077,
      "userRating": null
    }
  },
  "status": null,
  "sampleTestCase": "[2,1,3]\n1",
  "metaData": "{\n  \"name\": \"inorderSuccessor\",\n  \"params\": [\n    {\n      \"name\": \"root\",\n      \"type\": \"TreeNode\"\n    },\n    {\n      \"name\": \"p\",\n      \"type\": \"TreeNode\",\n      \"dealloc\": false,\n      \"deserialize\": false\n    }\n  ],\n  \"return\": {\n    \"type\": \"TreeNode\",\n    \"serializevalue\": true\n  },\n  \"languages\": [\n    \"cpp\",\n    \"java\",\n    \"python\",\n    \"c\",\n    \"csharp\",\n    \"javascript\",\n    \"ruby\",\n    \"golang\",\n    \"python3\"\n  ],\n  \"manual\": true\n}",
  "judgerAvailable": true,
  "judgeType": "large",
  "mysqlSchemas": [],
  "enableRunCode": true,
  "enableTestMode": false,
  "libraryUrl": null
}
