{
  "questionId": "287",
  "questionFrontendId": "287",
  "boundTopicId": null,
  "title": "Find the Duplicate Number",
  "titleSlug": "find-the-duplicate-number",
  "categoryTitle": "Algorithms",
  "content": "<p>Given an array <i>nums</i> containing <i>n</i> + 1 integers where each integer is between 1 and <i>n</i> (inclusive), prove that at least one duplicate number must exist. Assume that there is only one duplicate number, find the duplicate one.</p>\r\n\r\n<p><b>Example 1:</b></p>\r\n\r\n<pre>\r\n<b>Input:</b> <code>[1,3,4,2,2]</code>\r\n<b>Output:</b> 2\r\n</pre>\r\n\r\n<p><b>Example 2:</b></p>\r\n\r\n<pre>\r\n<b>Input:</b> [3,1,3,4,2]\r\n<b>Output:</b> 3</pre>\r\n\r\n<p><b>Note:</b></p>\r\n\r\n<ol>\r\n\t<li>You <b>must not</b> modify the array (assume the array is read only).</li>\r\n\t<li>You must use only constant, <i>O</i>(1) extra space.</li>\r\n\t<li>Your runtime complexity should be less than <em>O</em>(<em>n</em><sup>2</sup>).</li>\r\n\t<li>There is only one duplicate number in the array, but it could be repeated more than once.</li>\r\n</ol>\r\n",
  "isPaidOnly": false,
  "difficulty": "Medium",
  "likes": 3223,
  "dislikes": 390,
  "isLiked": null,
  "similarQuestions": "[{\"title\": \"First Missing Positive\", \"titleSlug\": \"first-missing-positive\", \"difficulty\": \"Hard\", \"translatedTitle\": null}, {\"title\": \"Single Number\", \"titleSlug\": \"single-number\", \"difficulty\": \"Easy\", \"translatedTitle\": null}, {\"title\": \"Linked List Cycle II\", \"titleSlug\": \"linked-list-cycle-ii\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Missing Number\", \"titleSlug\": \"missing-number\", \"difficulty\": \"Easy\", \"translatedTitle\": null}, {\"title\": \"Set Mismatch\", \"titleSlug\": \"set-mismatch\", \"difficulty\": \"Easy\", \"translatedTitle\": null}]",
  "contributors": [
    {
      "username": "jianchao-li",
      "profileUrl": "/jianchao-li/",
      "avatarUrl": "https://assets.leetcode.com/users/jianchaolifighter/avatar_1529298385.png"
    }
  ],
  "topicTags": [
    {
      "name": "Array",
      "slug": "array"
    },
    {
      "name": "Two Pointers",
      "slug": "two-pointers"
    },
    {
      "name": "Binary Search",
      "slug": "binary-search"
    }
  ],
  "companyTagStats": "{\"3\": [{\"taggedByAdmin\": false, \"name\": \"Yahoo\", \"slug\": \"yahoo\", \"timesEncountered\": 2}, {\"taggedByAdmin\": false, \"name\": \"Morgan Stanley\", \"slug\": \"morgan-stanley\", \"timesEncountered\": 2}, {\"taggedByAdmin\": false, \"name\": \"Facebook\", \"slug\": \"facebook\", \"timesEncountered\": 2}, {\"taggedByAdmin\": false, \"name\": \"Oracle\", \"slug\": \"oracle\", \"timesEncountered\": 2}, {\"taggedByAdmin\": false, \"name\": \"Salesforce\", \"slug\": \"salesforce\", \"timesEncountered\": 2}, {\"taggedByAdmin\": false, \"name\": \"Tencent\", \"slug\": \"tencent\", \"timesEncountered\": 2}], \"1\": [{\"taggedByAdmin\": false, \"name\": \"Amazon\", \"slug\": \"amazon\", \"timesEncountered\": 6}, {\"taggedByAdmin\": false, \"name\": \"Microsoft\", \"slug\": \"microsoft\", \"timesEncountered\": 3}, {\"taggedByAdmin\": false, \"name\": \"Google\", \"slug\": \"google\", \"timesEncountered\": 2}], \"2\": [{\"taggedByAdmin\": true, \"name\": \"Bloomberg\", \"slug\": \"bloomberg\", \"timesEncountered\": 2}]}",
  "codeSnippets": [
    {
      "lang": "C++",
      "code": "class Solution {\npublic:\n    int findDuplicate(vector<int>& nums) {\n        \n    }\n};"
    },
    {
      "lang": "Java",
      "code": "class Solution {\n    public int findDuplicate(int[] nums) {\n        \n    }\n}"
    },
    {
      "lang": "Python",
      "code": "class Solution(object):\n    def findDuplicate(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        "
    },
    {
      "lang": "Python3",
      "code": "class Solution:\n    def findDuplicate(self, nums: List[int]) -> int:\n        "
    },
    {
      "lang": "C",
      "code": "\n\nint findDuplicate(int* nums, int numsSize){\n\n}\n\n"
    },
    {
      "lang": "C#",
      "code": "public class Solution {\n    public int FindDuplicate(int[] nums) {\n        \n    }\n}"
    },
    {
      "lang": "JavaScript",
      "code": "/**\n * @param {number[]} nums\n * @return {number}\n */\nvar findDuplicate = function(nums) {\n    \n};"
    },
    {
      "lang": "Ruby",
      "code": "# @param {Integer[]} nums\n# @return {Integer}\ndef find_duplicate(nums)\n    \nend"
    },
    {
      "lang": "Swift",
      "code": "class Solution {\n    func findDuplicate(_ nums: [Int]) -> Int {\n        \n    }\n}"
    },
    {
      "lang": "Go",
      "code": "func findDuplicate(nums []int) int {\n    \n}"
    },
    {
      "lang": "Scala",
      "code": "object Solution {\n    def findDuplicate(nums: Array[Int]): Int = {\n        \n    }\n}"
    },
    {
      "lang": "Kotlin",
      "code": "class Solution {\n    fun findDuplicate(nums: IntArray): Int {\n        \n    }\n}"
    },
    {
      "lang": "Rust",
      "code": "impl Solution {\n    pub fn find_duplicate(nums: Vec<i32>) -> i32 {\n        \n    }\n}"
    },
    {
      "lang": "PHP",
      "code": "class Solution {\n\n    /**\n     * @param Integer[] $nums\n     * @return Integer\n     */\n    function findDuplicate($nums) {\n        \n    }\n}"
    }
  ],
  "stats": "{\"totalAccepted\": \"243.8K\", \"totalSubmission\": \"469.8K\", \"totalAcceptedRaw\": 243831, \"totalSubmissionRaw\": 469802, \"acRate\": \"51.9%\"}",
  "hints": [],
  "solution": {
    "id": "338",
    "canSeeDetail": true,
    "url": "/articles/find-the-duplicate-number/",
    "content": "[TOC]\n\n#### Note #####\n\nThe first two approaches mentioned do not satisfy the constraints given in\nthe prompt, but they are solutions that you might be likely to come up with\nduring a technical interview. As an interviewer, I personally would _not_\nexpect someone to come up with the cycle detection solution unless they have\nheard it before.\n\n#### Proof ####\n\nProving that at least one duplicate must exist in `nums` is simple\napplication of the\n[pigeonhole principle](https://en.wikipedia.org/wiki/Pigeonhole_principle).\nHere, each number in `nums` is a \"pigeon\" and each distinct number that can\nappear in `nums` is a \"pigeonhole\". Because there are $$n+1$$ numbers are\n$$n$$ distinct possible numbers, the pigeonhole principle implies that at\nleast one of the numbers is duplicated.\n\n#### Approach #1 Sorting [Accepted]\n\n**Intuition**\n\nIf the numbers are sorted, then any duplicate numbers will be adjacent in the\nsorted array.\n\n**Algorithm**\n\nGiven the intuition, the algorithm follows fairly simply. First, we sort the\narray, and then we compare each element to the previous element. Because\nthere is exactly one duplicated element in the array, we know that the array\nis of at least length 2, and we can return the duplicate element as soon as\nwe find it.\n\n<iframe src=\"https://leetcode.com/playground/bQGYqfgj/shared\" frameBorder=\"0\" width=\"100%\" height=\"259\" name=\"bQGYqfgj\"></iframe>\n\n**Complexity Analysis**\n\n* Time complexity : $$O(nlgn)$$\n\n    The `sort` invocation costs $$O(nlgn)$$ time in Python and Java, so it\n    dominates the subsequent linear scan.\n\n* Space complexity : $$O(1)$$ (or $$O(n)$$)\n\n    Here, we sort `nums` in place, so the memory footprint is constant. If we\n    cannot modify the input array, then we must allocate linear space for a\n    copy of `nums` and sort that instead.\n\n---\n\n#### Approach #2 Set [Accepted]\n\n**Intuition**\n\nIf we store each element as we iterate over the array, we can simply check\neach element as we iterate over the array.\n\n**Algorithm**\n\nIn order to achieve linear time complexity, we need to be able to insert\nelements into a data structure (and look them up) in constant time. A `Set`\nsatisfies these constraints nicely, so we iterate over the array and insert\neach element into `seen`. Before inserting it, we check whether it is already\nthere. If it is, then we found our duplicate, so we return it.\n\n<iframe src=\"https://leetcode.com/playground/jP4YUkB7/shared\" frameBorder=\"0\" width=\"100%\" height=\"276\" name=\"jP4YUkB7\"></iframe>\n\n**Complexity Analysis**\n\n* Time complexity : $$O(n)$$\n\n    `Set` in both Python and Java rely on underlying hash tables, so\n    insertion and lookup have amortized constant time complexities. The\n    algorithm is therefore linear, as it consists of a `for` loop that\n    performs constant work $$n$$ times.\n\n* Space complexity : $$O(n)$$\n\n    In the worst case, the duplicate element appears twice, with one of its\n    appearances at array index $$n-1$$. In this case, `seen` will contain\n    $$n-1$$ distinct values, and will therefore occupy $$O(n)$$ space.\n\n---\n\n#### Approach #3 Floyd's Tortoise and Hare (Cycle Detection) [Accepted]\n\n**Intuition**\n\nIf we interpret `nums` such that for each pair of index $$i$$ and value\n$$v_i$$, the \"next\" value $$v_j$$ is at index $$v_i$$, we can reduce this\nproblem to cycle detection. See the solution to\n[Linked List Cycle II](https://leetcode.com/problems/linked-list-cycle-ii/solution/)\nfor more details.\n\n**Algorithm**\n\nFirst off, we can easily show that the constraints of the problem imply that\na cycle _must_ exist. Because each number in `nums` is between $$1$$ and\n$$n$$, it will necessarily point to an index that exists. Therefore, the list\ncan be traversed infinitely, which implies that there is a cycle.\nAdditionally, because $$0$$ cannot appear as a value in `nums`, `nums[0]`\ncannot be part of the cycle. Therefore, traversing the array in this manner\nfrom `nums[0]` is equivalent to traversing a cyclic linked list. Given this,\nthe problem can be solved just like\n[Linked List Cycle II](https://leetcode.com/problems/linked-list-cycle-ii/).\n\nTo see the algorithm in action, check out the animation below:\n\n!?!../Documents/287_Find_the_Duplicate_Number.json:1280,720!?!\n\n<iframe src=\"https://leetcode.com/playground/RMBz6AQR/shared\" frameBorder=\"0\" width=\"100%\" height=\"412\" name=\"RMBz6AQR\"></iframe>\n\n**Complexity Analysis**\n\n* Time complexity : $$O(n)$$\n\n    For detailed analysis, refer to \n    [Linked List Cycle II](https://leetcode.com/problems/linked-list-cycle-ii/solution/#approach-2-floyds-tortoise-and-hare-accepted).\n    \n\n* Space complexity : $$O(1)$$\n\n    For detailed analysis, refer to \n    [Linked List Cycle II](https://leetcode.com/problems/linked-list-cycle-ii/solution/#approach-2-floyds-tortoise-and-hare-accepted).\n    \n\n---\n\nAnalysis and solutions written by: [@emptyset](https://leetcode.com/emptyset)",
    "contentTypeId": "107",
    "rating": {
      "id": "333",
      "count": 95,
      "average": 4.253,
      "userRating": null
    }
  },
  "status": null,
  "sampleTestCase": "[1,3,4,2,2]",
  "metaData": "{\r\n  \"name\": \"findDuplicate\",\r\n  \"params\": [\r\n    {\r\n      \"name\": \"nums\",\r\n      \"type\": \"integer[]\"\r\n    }\r\n  ],\r\n  \"return\": {\r\n    \"type\": \"integer\"\r\n  }\r\n}",
  "judgerAvailable": true,
  "judgeType": "large",
  "mysqlSchemas": [],
  "enableRunCode": true,
  "enableTestMode": false,
  "libraryUrl": null
}
