{
  "questionId": "298",
  "questionFrontendId": "298",
  "boundTopicId": null,
  "title": "Binary Tree Longest Consecutive Sequence",
  "titleSlug": "binary-tree-longest-consecutive-sequence",
  "categoryTitle": "Algorithms",
  "content": "<p>Given a binary tree, find the length of the longest consecutive sequence path.</p>\r\n\r\n<p>The path refers to any sequence of nodes from some starting node to any node in the tree along the parent-child connections. The longest consecutive path need to be from parent to child (cannot be the reverse).</p>\r\n\r\n<p><strong>Example 1:</strong></p>\r\n\r\n<pre>\r\n<strong>Input:</strong>\r\n\r\n   1\r\n    \\\r\n     3\r\n    / \\\r\n   2   4\r\n        \\\r\n         5\r\n\r\n<strong>Output:</strong> <code>3</code>\r\n\r\n<strong>Explanation: </strong>Longest consecutive sequence path is <code>3-4-5</code><span style=\"font-family: sans-serif, Arial, Verdana, &quot;Trebuchet MS&quot;;\">, so return </span><code>3</code><span style=\"font-family: sans-serif, Arial, Verdana, &quot;Trebuchet MS&quot;;\">.</span></pre>\r\n\r\n<p><strong>Example 2:</strong></p>\r\n\r\n<pre>\r\n<strong>Input:\r\n\r\n</strong>   2\r\n    \\\r\n     3\r\n    / \r\n   2    \r\n  / \r\n 1\r\n\r\n<strong>Output: 2 \r\n\r\nExplanation: </strong>Longest consecutive sequence path is <code>2-3</code><span style=\"font-family: sans-serif, Arial, Verdana, &quot;Trebuchet MS&quot;;\">, not </span><code>3-2-1</code><span style=\"font-family: sans-serif, Arial, Verdana, &quot;Trebuchet MS&quot;;\">, so return </span><code>2</code><span style=\"font-family: sans-serif, Arial, Verdana, &quot;Trebuchet MS&quot;;\">.</span></pre>",
  "isPaidOnly": true,
  "difficulty": "Medium",
  "likes": 400,
  "dislikes": 100,
  "isLiked": null,
  "similarQuestions": "[{\"title\": \"Longest Consecutive Sequence\", \"titleSlug\": \"longest-consecutive-sequence\", \"difficulty\": \"Hard\", \"translatedTitle\": null}, {\"title\": \"Binary Tree Longest Consecutive Sequence II\", \"titleSlug\": \"binary-tree-longest-consecutive-sequence-ii\", \"difficulty\": \"Medium\", \"translatedTitle\": null}]",
  "contributors": [
    {
      "username": "jeantimex",
      "profileUrl": "/jeantimex/",
      "avatarUrl": "https://www.gravatar.com/avatar/647f6db67906ba406fe92b62782d401e.png?s=200"
    }
  ],
  "topicTags": [
    {
      "name": "Tree",
      "slug": "tree"
    }
  ],
  "companyTagStats": "{\"2\": [{\"taggedByAdmin\": false, \"name\": \"Amazon\", \"slug\": \"amazon\", \"timesEncountered\": 4}, {\"taggedByAdmin\": false, \"name\": \"Uber\", \"slug\": \"uber\", \"timesEncountered\": 2}], \"1\": [{\"taggedByAdmin\": true, \"name\": \"Google\", \"slug\": \"google\", \"timesEncountered\": 4}, {\"taggedByAdmin\": false, \"name\": \"Facebook\", \"slug\": \"facebook\", \"timesEncountered\": 2}], \"3\": []}",
  "codeSnippets": [
    {
      "lang": "C++",
      "code": "/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\n * };\n */\nclass Solution {\npublic:\n    int longestConsecutive(TreeNode* root) {\n        \n    }\n};"
    },
    {
      "lang": "Java",
      "code": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode(int x) { val = x; }\n * }\n */\nclass Solution {\n    public int longestConsecutive(TreeNode root) {\n        \n    }\n}"
    },
    {
      "lang": "Python",
      "code": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, x):\n#         self.val = x\n#         self.left = None\n#         self.right = None\n\nclass Solution(object):\n    def longestConsecutive(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        "
    },
    {
      "lang": "Python3",
      "code": "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, x):\n#         self.val = x\n#         self.left = None\n#         self.right = None\n\nclass Solution:\n    def longestConsecutive(self, root: TreeNode) -> int:\n        "
    },
    {
      "lang": "C",
      "code": "/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     struct TreeNode *left;\n *     struct TreeNode *right;\n * };\n */\n\n\nint longestConsecutive(struct TreeNode* root){\n\n}\n\n"
    },
    {
      "lang": "C#",
      "code": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     public int val;\n *     public TreeNode left;\n *     public TreeNode right;\n *     public TreeNode(int x) { val = x; }\n * }\n */\npublic class Solution {\n    public int LongestConsecutive(TreeNode root) {\n        \n    }\n}"
    },
    {
      "lang": "JavaScript",
      "code": "/**\n * Definition for a binary tree node.\n * function TreeNode(val) {\n *     this.val = val;\n *     this.left = this.right = null;\n * }\n */\n/**\n * @param {TreeNode} root\n * @return {number}\n */\nvar longestConsecutive = function(root) {\n    \n};"
    },
    {
      "lang": "Ruby",
      "code": "# Definition for a binary tree node.\n# class TreeNode\n#     attr_accessor :val, :left, :right\n#     def initialize(val)\n#         @val = val\n#         @left, @right = nil, nil\n#     end\n# end\n\n# @param {TreeNode} root\n# @return {Integer}\ndef longest_consecutive(root)\n    \nend"
    },
    {
      "lang": "Swift",
      "code": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     public var val: Int\n *     public var left: TreeNode?\n *     public var right: TreeNode?\n *     public init(_ val: Int) {\n *         self.val = val\n *         self.left = nil\n *         self.right = nil\n *     }\n * }\n */\nclass Solution {\n    func longestConsecutive(_ root: TreeNode?) -> Int {\n        \n    }\n}"
    },
    {
      "lang": "Go",
      "code": "/**\n * Definition for a binary tree node.\n * type TreeNode struct {\n *     Val int\n *     Left *TreeNode\n *     Right *TreeNode\n * }\n */\nfunc longestConsecutive(root *TreeNode) int {\n    \n}"
    },
    {
      "lang": "Scala",
      "code": "/**\n * Definition for a binary tree node.\n * class TreeNode(var _value: Int) {\n *   var value: Int = _value\n *   var left: TreeNode = null\n *   var right: TreeNode = null\n * }\n */\nobject Solution {\n    def longestConsecutive(root: TreeNode): Int = {\n        \n    }\n}"
    },
    {
      "lang": "Kotlin",
      "code": "/**\n * Example:\n * var ti = TreeNode(5)\n * var v = ti.`val`\n * Definition for a binary tree node.\n * class TreeNode(var `val`: Int) {\n *     var left: TreeNode? = null\n *     var right: TreeNode? = null\n * }\n */\nclass Solution {\n    fun longestConsecutive(root: TreeNode?): Int {\n        \n    }\n}"
    },
    {
      "lang": "Rust",
      "code": "// Definition for a binary tree node.\n// #[derive(Debug, PartialEq, Eq)]\n// pub struct TreeNode {\n//   pub val: i32,\n//   pub left: Option<Rc<RefCell<TreeNode>>>,\n//   pub right: Option<Rc<RefCell<TreeNode>>>,\n// }\n// \n// impl TreeNode {\n//   #[inline]\n//   pub fn new(val: i32) -> Self {\n//     TreeNode {\n//       val,\n//       left: None,\n//       right: None\n//     }\n//   }\n// }\nuse std::rc::Rc;\nuse std::cell::RefCell;\nimpl Solution {\n    pub fn longest_consecutive(root: Option<Rc<RefCell<TreeNode>>>) -> i32 {\n        \n    }\n}"
    },
    {
      "lang": "PHP",
      "code": "/**\n * Definition for a binary tree node.\n * class TreeNode {\n *     public $val = null;\n *     public $left = null;\n *     public $right = null;\n *     function __construct($value) { $this->val = $value; }\n * }\n */\nclass Solution {\n\n    /**\n     * @param TreeNode $root\n     * @return Integer\n     */\n    function longestConsecutive($root) {\n        \n    }\n}"
    }
  ],
  "stats": "{\"totalAccepted\": \"71.5K\", \"totalSubmission\": \"157K\", \"totalAcceptedRaw\": 71500, \"totalSubmissionRaw\": 156980, \"acRate\": \"45.5%\"}",
  "hints": [],
  "solution": {
    "id": "14",
    "canSeeDetail": true,
    "url": "/articles/binary-tree-longest-consecutive-sequence/",
    "content": "[TOC]\r\n\r\n## Solution\r\n---\r\n#### Approach #1 (Top Down Depth-first Search) [Accepted]\r\n\r\n**Algorithm**\r\n\r\nA top down approach is similar to an in-order traversal. We use a variable `length` to store the current consecutive path length and pass it down the tree. As we traverse, we compare the current node with its parent node to determine if it is consecutive. If not, we reset the length.\r\n\r\n```java\r\nprivate int maxLength = 0;\r\npublic int longestConsecutive(TreeNode root) {\r\n    dfs(root, null, 0);\r\n    return maxLength;\r\n}\r\n\r\nprivate void dfs(TreeNode p, TreeNode parent, int length) {\r\n    if (p == null) return;\r\n    length = (parent != null && p.val == parent.val + 1) ? length + 1 : 1;\r\n    maxLength = Math.max(maxLength, length);\r\n    dfs(p.left, p, length);\r\n    dfs(p.right, p, length);\r\n}\r\n```\r\n\r\n@lightmark presents [a neat approach](https://leetcode.com/discuss/66486/short-and-simple-c-solution) without storing the maxLength as a global variable.\r\n\r\n```java\r\npublic int longestConsecutive(TreeNode root) {\r\n    return dfs(root, null, 0);\r\n}\r\n\r\nprivate int dfs(TreeNode p, TreeNode parent, int length) {\r\n    if (p == null) return length;\r\n    length = (parent != null && p.val == parent.val + 1) ? length + 1 : 1;\r\n    return Math.max(length, Math.max(dfs(p.left, p, length),\r\n                                     dfs(p.right, p, length)));\r\n}\r\n```\r\n\r\n**Complexity analysis**\r\n\r\n* Time complexity : $$O(n)$$.\r\nThe time complexity is the same as an in-order traversal of a binary tree with $$n$$ nodes.\r\n\r\n* Space complexity : $$O(n)$$.\r\nThe extra space comes from implicit stack space due to recursion. For a skewed binary tree, the recursion could go up to $$n$$ levels deep.\r\n\r\n---\r\n#### Approach #2 (Bottom Up Depth-first Search) [Accepted]\r\n\r\n**Algorithm**\r\n\r\nThe bottom-up approach is similar to a post-order traversal. We return the consecutive path length starting at current node to its parent. Then its parent can examine if its node value can be included in this consecutive path.\r\n\r\n```java\r\nprivate int maxLength = 0;\r\npublic int longestConsecutive(TreeNode root) {\r\n    dfs(root);\r\n    return maxLength;\r\n}\r\n\r\nprivate int dfs(TreeNode p) {\r\n    if (p == null) return 0;\r\n    int L = dfs(p.left) + 1;\r\n    int R = dfs(p.right) + 1;\r\n    if (p.left != null && p.val + 1 != p.left.val) {\r\n        L = 1;\r\n    }\r\n    if (p.right != null && p.val + 1 != p.right.val) {\r\n        R = 1;\r\n    }\r\n    int length = Math.max(L, R);\r\n    maxLength = Math.max(maxLength, length);\r\n    return length;\r\n}\r\n```\r\n\r\n**Complexity analysis**\r\n\r\n* Time complexity : $$O(n)$$.\r\nThe time complexity is the same as a post-order traversal in a binary tree, which is $$O(n)$$.\r\n\r\n* Space complexity : $$O(n)$$.\r\nThe extra space comes from implicit stack space due to recursion. For a skewed binary tree, the recursion could go up to $$n$$ levels deep.",
    "contentTypeId": "107",
    "rating": {
      "id": "7",
      "count": 18,
      "average": 4.667,
      "userRating": null
    }
  },
  "status": null,
  "sampleTestCase": "[1,null,3,2,4,null,null,null,5]",
  "metaData": "{\r\n  \"name\": \"longestConsecutive\",\r\n  \"params\": [\r\n    {\r\n      \"name\": \"root\",\r\n      \"type\": \"TreeNode\"\r\n    }\r\n  ],\r\n  \"return\": {\r\n    \"type\": \"integer\"\r\n  }\r\n}",
  "judgerAvailable": true,
  "judgeType": "large",
  "mysqlSchemas": [],
  "enableRunCode": true,
  "enableTestMode": false,
  "libraryUrl": null
}
