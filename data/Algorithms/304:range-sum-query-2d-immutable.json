{
  "questionId": "304",
  "questionFrontendId": "304",
  "boundTopicId": null,
  "title": "Range Sum Query 2D - Immutable",
  "titleSlug": "range-sum-query-2d-immutable",
  "categoryTitle": "Algorithms",
  "content": "<p>Given a 2D matrix <i>matrix</i>, find the sum of the elements inside the rectangle defined by its upper left corner (<i>row</i>1, <i>col</i>1) and lower right corner (<i>row</i>2, <i>col</i>2).</p>\r\n\r\n<p>\r\n<img src=\"/static/images/courses/range_sum_query_2d.png\" border=\"0\" alt=\"Range Sum Query 2D\" /><br />\r\n<small>The above rectangle (with the red border) is defined by (row1, col1) = <b>(2, 1)</b> and (row2, col2) = <b>(4, 3)</b>, which contains sum = <b>8</b>.</small>\r\n</p>\r\n\r\n<p><b>Example:</b><br>\r\n<pre>\r\nGiven matrix = [\r\n  [3, 0, 1, 4, 2],\r\n  [5, 6, 3, 2, 1],\r\n  [1, 2, 0, 1, 5],\r\n  [4, 1, 0, 1, 7],\r\n  [1, 0, 3, 0, 5]\r\n]\r\n\r\nsumRegion(2, 1, 4, 3) -> 8\r\nsumRegion(1, 1, 2, 2) -> 11\r\nsumRegion(1, 2, 2, 4) -> 12\r\n</pre>\r\n</p>\r\n\r\n<p><b>Note:</b><br>\r\n<ol>\r\n<li>You may assume that the matrix does not change.</li>\r\n<li>There are many calls to <i>sumRegion</i> function.</li>\r\n<li>You may assume that <i>row</i>1 &le; <i>row</i>2 and <i>col</i>1 &le; <i>col</i>2.</li>\r\n</ol>\r\n</p>",
  "isPaidOnly": false,
  "difficulty": "Medium",
  "likes": 650,
  "dislikes": 152,
  "isLiked": null,
  "similarQuestions": "[{\"title\": \"Range Sum Query - Immutable\", \"titleSlug\": \"range-sum-query-immutable\", \"difficulty\": \"Easy\", \"translatedTitle\": null}, {\"title\": \"Range Sum Query 2D - Mutable\", \"titleSlug\": \"range-sum-query-2d-mutable\", \"difficulty\": \"Hard\", \"translatedTitle\": null}]",
  "contributors": [],
  "topicTags": [
    {
      "name": "Dynamic Programming",
      "slug": "dynamic-programming"
    }
  ],
  "companyTagStats": "{\"1\": [{\"taggedByAdmin\": false, \"name\": \"Facebook\", \"slug\": \"facebook\", \"timesEncountered\": 12}, {\"taggedByAdmin\": false, \"name\": \"Google\", \"slug\": \"google\", \"timesEncountered\": 5}, {\"taggedByAdmin\": false, \"name\": \"Apple\", \"slug\": \"apple\", \"timesEncountered\": 3}, {\"taggedByAdmin\": false, \"name\": \"Houzz\", \"slug\": \"houzz\", \"timesEncountered\": 2}], \"2\": [{\"taggedByAdmin\": false, \"name\": \"Amazon\", \"slug\": \"amazon\", \"timesEncountered\": 3}, {\"taggedByAdmin\": false, \"name\": \"Microsoft\", \"slug\": \"microsoft\", \"timesEncountered\": 2}, {\"taggedByAdmin\": false, \"name\": \"VMware\", \"slug\": \"vmware\", \"timesEncountered\": 2}], \"3\": [{\"taggedByAdmin\": false, \"name\": \"Lyft\", \"slug\": \"lyft\", \"timesEncountered\": 2}]}",
  "codeSnippets": [
    {
      "lang": "C++",
      "code": "class NumMatrix {\npublic:\n    NumMatrix(vector<vector<int>>& matrix) {\n        \n    }\n    \n    int sumRegion(int row1, int col1, int row2, int col2) {\n        \n    }\n};\n\n/**\n * Your NumMatrix object will be instantiated and called as such:\n * NumMatrix* obj = new NumMatrix(matrix);\n * int param_1 = obj->sumRegion(row1,col1,row2,col2);\n */"
    },
    {
      "lang": "Java",
      "code": "class NumMatrix {\n\n    public NumMatrix(int[][] matrix) {\n        \n    }\n    \n    public int sumRegion(int row1, int col1, int row2, int col2) {\n        \n    }\n}\n\n/**\n * Your NumMatrix object will be instantiated and called as such:\n * NumMatrix obj = new NumMatrix(matrix);\n * int param_1 = obj.sumRegion(row1,col1,row2,col2);\n */"
    },
    {
      "lang": "Python",
      "code": "class NumMatrix(object):\n\n    def __init__(self, matrix):\n        \"\"\"\n        :type matrix: List[List[int]]\n        \"\"\"\n        \n\n    def sumRegion(self, row1, col1, row2, col2):\n        \"\"\"\n        :type row1: int\n        :type col1: int\n        :type row2: int\n        :type col2: int\n        :rtype: int\n        \"\"\"\n        \n\n\n# Your NumMatrix object will be instantiated and called as such:\n# obj = NumMatrix(matrix)\n# param_1 = obj.sumRegion(row1,col1,row2,col2)"
    },
    {
      "lang": "Python3",
      "code": "class NumMatrix:\n\n    def __init__(self, matrix: List[List[int]]):\n        \n\n    def sumRegion(self, row1: int, col1: int, row2: int, col2: int) -> int:\n        \n\n\n# Your NumMatrix object will be instantiated and called as such:\n# obj = NumMatrix(matrix)\n# param_1 = obj.sumRegion(row1,col1,row2,col2)"
    },
    {
      "lang": "C",
      "code": "\n\n\ntypedef struct {\n    \n} NumMatrix;\n\n\nNumMatrix* numMatrixCreate(int** matrix, int matrixSize, int* matrixColSize) {\n    \n}\n\nint numMatrixSumRegion(NumMatrix* obj, int row1, int col1, int row2, int col2) {\n  \n}\n\nvoid numMatrixFree(NumMatrix* obj) {\n    \n}\n\n/**\n * Your NumMatrix struct will be instantiated and called as such:\n * NumMatrix* obj = numMatrixCreate(matrix, matrixSize, matrixColSize);\n * int param_1 = numMatrixSumRegion(obj, row1, col1, row2, col2);\n \n * numMatrixFree(obj);\n*/"
    },
    {
      "lang": "C#",
      "code": "public class NumMatrix {\n\n    public NumMatrix(int[][] matrix) {\n        \n    }\n    \n    public int SumRegion(int row1, int col1, int row2, int col2) {\n        \n    }\n}\n\n/**\n * Your NumMatrix object will be instantiated and called as such:\n * NumMatrix obj = new NumMatrix(matrix);\n * int param_1 = obj.SumRegion(row1,col1,row2,col2);\n */"
    },
    {
      "lang": "JavaScript",
      "code": "/**\n * @param {number[][]} matrix\n */\nvar NumMatrix = function(matrix) {\n    \n};\n\n/** \n * @param {number} row1 \n * @param {number} col1 \n * @param {number} row2 \n * @param {number} col2\n * @return {number}\n */\nNumMatrix.prototype.sumRegion = function(row1, col1, row2, col2) {\n    \n};\n\n/** \n * Your NumMatrix object will be instantiated and called as such:\n * var obj = new NumMatrix(matrix)\n * var param_1 = obj.sumRegion(row1,col1,row2,col2)\n */"
    },
    {
      "lang": "Ruby",
      "code": "class NumMatrix\n\n=begin\n    :type matrix: Integer[][]\n=end\n    def initialize(matrix)\n        \n    end\n\n\n=begin\n    :type row1: Integer\n    :type col1: Integer\n    :type row2: Integer\n    :type col2: Integer\n    :rtype: Integer\n=end\n    def sum_region(row1, col1, row2, col2)\n        \n    end\n\n\nend\n\n# Your NumMatrix object will be instantiated and called as such:\n# obj = NumMatrix.new(matrix)\n# param_1 = obj.sum_region(row1, col1, row2, col2)"
    },
    {
      "lang": "Swift",
      "code": "\nclass NumMatrix {\n\n    init(_ matrix: [[Int]]) {\n        \n    }\n    \n    func sumRegion(_ row1: Int, _ col1: Int, _ row2: Int, _ col2: Int) -> Int {\n        \n    }\n}\n\n/**\n * Your NumMatrix object will be instantiated and called as such:\n * let obj = NumMatrix(matrix)\n * let ret_1: Int = obj.sumRegion(row1, col1, row2, col2)\n */"
    },
    {
      "lang": "Go",
      "code": "type NumMatrix struct {\n    \n}\n\n\nfunc Constructor(matrix [][]int) NumMatrix {\n    \n}\n\n\nfunc (this *NumMatrix) SumRegion(row1 int, col1 int, row2 int, col2 int) int {\n    \n}\n\n\n/**\n * Your NumMatrix object will be instantiated and called as such:\n * obj := Constructor(matrix);\n * param_1 := obj.SumRegion(row1,col1,row2,col2);\n */"
    },
    {
      "lang": "Scala",
      "code": "class NumMatrix(_matrix: Array[Array[Int]]) {\n\n    def sumRegion(row1: Int, col1: Int, row2: Int, col2: Int): Int = {\n        \n    }\n\n}\n\n/**\n * Your NumMatrix object will be instantiated and called as such:\n * var obj = new NumMatrix(matrix)\n * var param_1 = obj.sumRegion(row1,col1,row2,col2)\n */"
    },
    {
      "lang": "Kotlin",
      "code": "class NumMatrix(matrix: Array<IntArray>) {\n\n    fun sumRegion(row1: Int, col1: Int, row2: Int, col2: Int): Int {\n        \n    }\n\n}\n\n/**\n * Your NumMatrix object will be instantiated and called as such:\n * var obj = NumMatrix(matrix)\n * var param_1 = obj.sumRegion(row1,col1,row2,col2)\n */"
    },
    {
      "lang": "Rust",
      "code": "struct NumMatrix {\n\n}\n\n\n/** \n * `&self` means the method takes an immutable reference.\n * If you need a mutable reference, change it to `&mut self` instead.\n */\nimpl NumMatrix {\n\n    fn new(matrix: Vec<Vec<i32>>) -> Self {\n        \n    }\n    \n    fn sum_region(&self, row1: i32, col1: i32, row2: i32, col2: i32) -> i32 {\n        \n    }\n}\n\n/**\n * Your NumMatrix object will be instantiated and called as such:\n * let obj = NumMatrix::new(matrix);\n * let ret_1: i32 = obj.sum_region(row1, col1, row2, col2);\n */"
    },
    {
      "lang": "PHP",
      "code": "class NumMatrix {\n    /**\n     * @param Integer[][] $matrix\n     */\n    function __construct($matrix) {\n        \n    }\n  \n    /**\n     * @param Integer $row1\n     * @param Integer $col1\n     * @param Integer $row2\n     * @param Integer $col2\n     * @return Integer\n     */\n    function sumRegion($row1, $col1, $row2, $col2) {\n        \n    }\n}\n\n/**\n * Your NumMatrix object will be instantiated and called as such:\n * $obj = NumMatrix($matrix);\n * $ret_1 = $obj->sumRegion($row1, $col1, $row2, $col2);\n */"
    }
  ],
  "stats": "{\"totalAccepted\": \"90.7K\", \"totalSubmission\": \"256.1K\", \"totalAcceptedRaw\": 90684, \"totalSubmissionRaw\": 256069, \"acRate\": \"35.4%\"}",
  "hints": [],
  "solution": {
    "id": "10",
    "canSeeDetail": true,
    "url": "/articles/range-sum-query-2d-immutable/",
    "content": "[TOC]\r\n\r\n## Solution\r\n\r\n---\r\n#### Approach #1 (Brute Force) [Time Limit Exceeded]\r\n\r\n**Algorithm**\r\n\r\nEach time *sumRegion* is called, we use a double for loop to sum all elements from $$(row1, col1) \\rightarrow (row2, col2)$$.\r\n\r\n```java\r\nprivate int[][] data;\r\n\r\npublic NumMatrix(int[][] matrix) {\r\n    data = matrix;\r\n}\r\n\r\npublic int sumRegion(int row1, int col1, int row2, int col2) {\r\n    int sum = 0;\r\n    for (int r = row1; r <= row2; r++) {\r\n        for (int c = col1; c <= col2; c++) {\r\n            sum += data[r][c];\r\n        }\r\n    }\r\n    return sum;\r\n}\r\n```\r\n\r\n**Complexity analysis**\r\n\r\n* Time complexity : $$O(mn)$$ time per query.\r\nAssume that $$m$$ and $$n$$ represents the number of rows and columns respectively, each *sumRegion* query can go through at most $$m \\times n$$ elements.\r\n\r\n* Space complexity : $$O(1)$$. Note that `data` is a *reference* to `matrix` and is not a copy of it.\r\n\r\n---\r\n#### Approach #2 (Caching) [Memory Limit Exceeded]\r\n\r\n**Intuition**\r\n\r\nSince *sumRegion* could be called many times, we definitely need to do some pre-processing.\r\n\r\n**Algorithm**\r\n\r\nWe could trade in extra space for speed by pre-calculating all possible rectangular region sum and store them in a hash table. Each *sumRegion* query now takes only constant time complexity.\r\n\r\n**Complexity analysis**\r\n\r\n* Time complexity : $$O(1)$$ time per query, $$O(m^2n^2)$$ time pre-computation.\r\nEach *sumRegion* query takes $$O(1)$$ time as the hash table lookup's time complexity is constant. The pre-computation will take $$O(m^2n^2)$$ time as there are a total of $$m^2 \\times n^2$$ possibilities need to be cached.\r\n\r\n* Space complexity : $$O(m^2n^2)$$.\r\nSince there are $$mn$$ different possibilities for both top left and bottom right points of the rectangular region, the extra space required is $$O(m^2n^2)$$.\r\n\r\n---\r\n#### Approach #3 (Caching Rows) [Accepted]\r\n\r\n**Intuition**\r\n\r\nRemember from the [1D version](https://leetcode.com/course/chapters/leetcode-101/range-sum-query-immutable/) where we used a cumulative sum array? Could we apply that directly to solve this 2D version?\r\n\r\n**Algorithm**\r\n\r\nTry to see the 2D matrix as $$m$$ rows of 1D arrays. To find the region sum, we just accumulate the sum in the region row by row.\r\n\r\n```java\r\nprivate int[][] dp;\r\n\r\npublic NumMatrix(int[][] matrix) {\r\n    if (matrix.length == 0 || matrix[0].length == 0) return;\r\n    dp = new int[matrix.length][matrix[0].length + 1];\r\n    for (int r = 0; r < matrix.length; r++) {\r\n        for (int c = 0; c < matrix[0].length; c++) {\r\n            dp[r][c + 1] = dp[r][c] + matrix[r][c];\r\n        }\r\n    }\r\n}\r\n\r\npublic int sumRegion(int row1, int col1, int row2, int col2) {\r\n    int sum = 0;\r\n    for (int row = row1; row <= row2; row++) {\r\n        sum += dp[row][col2 + 1] - dp[row][col1];\r\n    }\r\n    return sum;\r\n}\r\n```\r\n\r\n**Complexity analysis**\r\n\r\n* Time complexity : $$O(m)$$ time per query, $$O(mn)$$ time pre-computation.\r\nThe pre-computation in the constructor takes $$O(mn)$$ time. The *sumRegion* query takes $$O(m)$$ time.\r\n\r\n* Space complexity : $$O(mn)$$.\r\nThe algorithm uses $$O(mn)$$ space to store the cumulative sum of all rows.\r\n\r\n---\r\n#### Approach #4 (Caching Smarter) [Accepted]\r\n\r\n**Algorithm**\r\n\r\nWe used a cumulative sum array in the [1D version](https://leetcode.com/course/chapters/leetcode-101/range-sum-query-immutable/). We notice that the cumulative sum is computed with respect to the origin at index 0. Extending this analogy to the 2D case, we could pre-compute a cumulative region sum with respect to the origin at $$(0, 0)$$.\r\n\r\n![Sum OD](https://leetcode.com/static/images/courses/sum_od.png)  \r\n<small>Sum(OD) is the cumulative region sum with respect to the origin at (0, 0).</small>\r\n\r\nHow do we derive $$Sum(ABCD)$$ using the pre-computed cumulative region sum?\r\n\r\n![Sum OB](https://leetcode.com/static/images/courses/sum_ob.png)  \r\n<small>Sum(OB) is the cumulative region sum on top of the rectangle.</small>\r\n\r\n![Sum OC](https://leetcode.com/static/images/courses/sum_oc.png)  \r\n<small>Sum(OC) is the cumulative region sum to the left of the rectangle.</small>\r\n\r\n![Sum OA](https://leetcode.com/static/images/courses/sum_oa.png)  \r\n<small>Sum(OA) is the cumulative region sum to the top left corner of the rectangle.</small>\r\n\r\nNote that the region $$Sum(OA)$$ is covered twice by both $$Sum(OB)$$ and $$Sum(OC)$$. We could use the principle of inclusion-exclusion to calculate $$Sum(ABCD)$$ as following:\r\n\r\n$$\r\nSum(ABCD) = Sum(OD) - Sum(OB) - Sum(OC) + Sum(OA)\r\n$$\r\n\r\n```java\r\nprivate int[][] dp;\r\n\r\npublic NumMatrix(int[][] matrix) {\r\n    if (matrix.length == 0 || matrix[0].length == 0) return;\r\n    dp = new int[matrix.length + 1][matrix[0].length + 1];\r\n    for (int r = 0; r < matrix.length; r++) {\r\n        for (int c = 0; c < matrix[0].length; c++) {\r\n            dp[r + 1][c + 1] = dp[r + 1][c] + dp[r][c + 1] + matrix[r][c] - dp[r][c];\r\n        }\r\n    }\r\n}\r\n\r\npublic int sumRegion(int row1, int col1, int row2, int col2) {\r\n    return dp[row2 + 1][col2 + 1] - dp[row1][col2 + 1] - dp[row2 + 1][col1] + dp[row1][col1];\r\n}\r\n```\r\n\r\n**Complexity analysis**\r\n\r\n* Time complexity : $$O(1)$$ time per query, $$O(mn)$$ time pre-computation.\r\nThe pre-computation in the constructor takes $$O(mn)$$ time. Each *sumRegion* query takes $$O(1)$$ time.\r\n\r\n* Space complexity : $$O(mn)$$.\r\nThe algorithm uses $$O(mn)$$ space to store the cumulative region sum.",
    "contentTypeId": "107",
    "rating": {
      "id": "8",
      "count": 71,
      "average": 4.93,
      "userRating": null
    }
  },
  "status": null,
  "sampleTestCase": "[\"NumMatrix\",\"sumRegion\",\"sumRegion\",\"sumRegion\"]\n[[[[3,0,1,4,2],[5,6,3,2,1],[1,2,0,1,5],[4,1,0,1,7],[1,0,3,0,5]]],[2,1,4,3],[1,1,2,2],[1,2,2,4]]",
  "metaData": "{\r\n    \"classname\": \"NumMatrix\",\r\n    \"maxbytesperline\": 150000,\r\n    \"constructor\": {\r\n        \"params\": [\r\n            {\r\n                \"type\": \"integer[][]\",\r\n                \"name\": \"matrix\"\r\n            },\r\n            {\r\n                \"type\": \"integer\",\r\n                \"name\": \"matrixRowSize\",\r\n                \"lang\": \"c\",\r\n                \"value\": \"size_1\"\r\n            },\r\n            {\r\n                \"type\": \"integer\",\r\n                \"name\": \"matrixColSize\",\r\n                \"lang\": \"c\",\r\n                \"value\": \"col_size_1\"\r\n            }\r\n        ]\r\n    },\r\n    \"methods\": [\r\n        {\r\n            \"name\" : \"sumRegion\",\r\n            \"params\": [\r\n                {\r\n                    \"type\": \"integer\",\r\n                    \"name\": \"row1\"\r\n                },\r\n                {\r\n                    \"type\": \"integer\",\r\n                    \"name\": \"col1\"\r\n                },\r\n                {\r\n                    \"type\": \"integer\",\r\n                    \"name\": \"row2\"\r\n                },\r\n                {\r\n                    \"type\": \"integer\",\r\n                    \"name\": \"col2\"\r\n                }\r\n            ],\r\n            \"return\": {\r\n                \"type\": \"integer\"\r\n            }\r\n        }\r\n    ],\r\n    \"systemdesign\": true,\r\n    \"params\": [\r\n        {\r\n            \"name\": \"inputs\",\r\n            \"type\": \"integer[]\"\r\n        },\r\n        {\r\n            \"name\": \"inputs\",\r\n            \"type\": \"integer[]\"\r\n        }\r\n    ],\r\n    \"return\": {\r\n        \"type\": \"list<String>\",\r\n        \"dealloc\": true\r\n    }\r\n}",
  "judgerAvailable": true,
  "judgeType": "large",
  "mysqlSchemas": [],
  "enableRunCode": true,
  "enableTestMode": false,
  "libraryUrl": null
}
