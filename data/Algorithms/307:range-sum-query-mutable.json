{
  "questionId": "307",
  "questionFrontendId": "307",
  "boundTopicId": null,
  "title": "Range Sum Query - Mutable",
  "titleSlug": "range-sum-query-mutable",
  "categoryTitle": "Algorithms",
  "content": "<p>Given an integer array <i>nums</i>, find the sum of the elements between indices <i>i</i> and <i>j</i> (<i>i</i> &le; <i>j</i>), inclusive.</p>\r\n\r\n<p>The <i>update(i, val)</i> function modifies <i>nums</i> by updating the element at index <i>i</i> to <i>val</i>.</p>\r\n\r\n<p><b>Example:</b></p>\r\n\r\n<pre>\r\nGiven nums = [1, 3, 5]\r\n\r\nsumRange(0, 2) -&gt; 9\r\nupdate(1, 2)\r\nsumRange(0, 2) -&gt; 8\r\n</pre>\r\n\r\n<p><b>Note:</b></p>\r\n\r\n<ol>\r\n\t<li>The array is only modifiable by the <i>update</i> function.</li>\r\n\t<li>You may assume the number of calls to <i>update</i> and <i>sumRange</i> function is distributed evenly.</li>\r\n</ol>\r\n",
  "isPaidOnly": false,
  "difficulty": "Medium",
  "likes": 943,
  "dislikes": 70,
  "isLiked": null,
  "similarQuestions": "[{\"title\": \"Range Sum Query - Immutable\", \"titleSlug\": \"range-sum-query-immutable\", \"difficulty\": \"Easy\", \"translatedTitle\": null}, {\"title\": \"Range Sum Query 2D - Mutable\", \"titleSlug\": \"range-sum-query-2d-mutable\", \"difficulty\": \"Hard\", \"translatedTitle\": null}]",
  "contributors": [],
  "topicTags": [
    {
      "name": "Binary Indexed Tree",
      "slug": "binary-indexed-tree"
    },
    {
      "name": "Segment Tree",
      "slug": "segment-tree"
    }
  ],
  "companyTagStats": "{\"1\": [{\"taggedByAdmin\": false, \"name\": \"Twitter\", \"slug\": \"twitter\", \"timesEncountered\": 3}, {\"taggedByAdmin\": false, \"name\": \"Amazon\", \"slug\": \"amazon\", \"timesEncountered\": 3}, {\"taggedByAdmin\": false, \"name\": \"Google\", \"slug\": \"google\", \"timesEncountered\": 2}], \"3\": [{\"taggedByAdmin\": false, \"name\": \"Facebook\", \"slug\": \"facebook\", \"timesEncountered\": 3}], \"2\": []}",
  "codeSnippets": [
    {
      "lang": "C++",
      "code": "class NumArray {\npublic:\n    NumArray(vector<int>& nums) {\n        \n    }\n    \n    void update(int i, int val) {\n        \n    }\n    \n    int sumRange(int i, int j) {\n        \n    }\n};\n\n/**\n * Your NumArray object will be instantiated and called as such:\n * NumArray* obj = new NumArray(nums);\n * obj->update(i,val);\n * int param_2 = obj->sumRange(i,j);\n */"
    },
    {
      "lang": "Java",
      "code": "class NumArray {\n\n    public NumArray(int[] nums) {\n        \n    }\n    \n    public void update(int i, int val) {\n        \n    }\n    \n    public int sumRange(int i, int j) {\n        \n    }\n}\n\n/**\n * Your NumArray object will be instantiated and called as such:\n * NumArray obj = new NumArray(nums);\n * obj.update(i,val);\n * int param_2 = obj.sumRange(i,j);\n */"
    },
    {
      "lang": "Python",
      "code": "class NumArray(object):\n\n    def __init__(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        \"\"\"\n        \n\n    def update(self, i, val):\n        \"\"\"\n        :type i: int\n        :type val: int\n        :rtype: None\n        \"\"\"\n        \n\n    def sumRange(self, i, j):\n        \"\"\"\n        :type i: int\n        :type j: int\n        :rtype: int\n        \"\"\"\n        \n\n\n# Your NumArray object will be instantiated and called as such:\n# obj = NumArray(nums)\n# obj.update(i,val)\n# param_2 = obj.sumRange(i,j)"
    },
    {
      "lang": "Python3",
      "code": "class NumArray:\n\n    def __init__(self, nums: List[int]):\n        \n\n    def update(self, i: int, val: int) -> None:\n        \n\n    def sumRange(self, i: int, j: int) -> int:\n        \n\n\n# Your NumArray object will be instantiated and called as such:\n# obj = NumArray(nums)\n# obj.update(i,val)\n# param_2 = obj.sumRange(i,j)"
    },
    {
      "lang": "C",
      "code": "\n\n\ntypedef struct {\n    \n} NumArray;\n\n\nNumArray* numArrayCreate(int* nums, int numsSize) {\n    \n}\n\nvoid numArrayUpdate(NumArray* obj, int i, int val) {\n  \n}\n\nint numArraySumRange(NumArray* obj, int i, int j) {\n  \n}\n\nvoid numArrayFree(NumArray* obj) {\n    \n}\n\n/**\n * Your NumArray struct will be instantiated and called as such:\n * NumArray* obj = numArrayCreate(nums, numsSize);\n * numArrayUpdate(obj, i, val);\n \n * int param_2 = numArraySumRange(obj, i, j);\n \n * numArrayFree(obj);\n*/"
    },
    {
      "lang": "C#",
      "code": "public class NumArray {\n\n    public NumArray(int[] nums) {\n        \n    }\n    \n    public void Update(int i, int val) {\n        \n    }\n    \n    public int SumRange(int i, int j) {\n        \n    }\n}\n\n/**\n * Your NumArray object will be instantiated and called as such:\n * NumArray obj = new NumArray(nums);\n * obj.Update(i,val);\n * int param_2 = obj.SumRange(i,j);\n */"
    },
    {
      "lang": "JavaScript",
      "code": "/**\n * @param {number[]} nums\n */\nvar NumArray = function(nums) {\n    \n};\n\n/** \n * @param {number} i \n * @param {number} val\n * @return {void}\n */\nNumArray.prototype.update = function(i, val) {\n    \n};\n\n/** \n * @param {number} i \n * @param {number} j\n * @return {number}\n */\nNumArray.prototype.sumRange = function(i, j) {\n    \n};\n\n/** \n * Your NumArray object will be instantiated and called as such:\n * var obj = new NumArray(nums)\n * obj.update(i,val)\n * var param_2 = obj.sumRange(i,j)\n */"
    },
    {
      "lang": "Ruby",
      "code": "class NumArray\n\n=begin\n    :type nums: Integer[]\n=end\n    def initialize(nums)\n        \n    end\n\n\n=begin\n    :type i: Integer\n    :type val: Integer\n    :rtype: Void\n=end\n    def update(i, val)\n        \n    end\n\n\n=begin\n    :type i: Integer\n    :type j: Integer\n    :rtype: Integer\n=end\n    def sum_range(i, j)\n        \n    end\n\n\nend\n\n# Your NumArray object will be instantiated and called as such:\n# obj = NumArray.new(nums)\n# obj.update(i, val)\n# param_2 = obj.sum_range(i, j)"
    },
    {
      "lang": "Swift",
      "code": "\nclass NumArray {\n\n    init(_ nums: [Int]) {\n        \n    }\n    \n    func update(_ i: Int, _ val: Int) {\n        \n    }\n    \n    func sumRange(_ i: Int, _ j: Int) -> Int {\n        \n    }\n}\n\n/**\n * Your NumArray object will be instantiated and called as such:\n * let obj = NumArray(nums)\n * obj.update(i, val)\n * let ret_2: Int = obj.sumRange(i, j)\n */"
    },
    {
      "lang": "Go",
      "code": "type NumArray struct {\n    \n}\n\n\nfunc Constructor(nums []int) NumArray {\n    \n}\n\n\nfunc (this *NumArray) Update(i int, val int)  {\n    \n}\n\n\nfunc (this *NumArray) SumRange(i int, j int) int {\n    \n}\n\n\n/**\n * Your NumArray object will be instantiated and called as such:\n * obj := Constructor(nums);\n * obj.Update(i,val);\n * param_2 := obj.SumRange(i,j);\n */"
    },
    {
      "lang": "Scala",
      "code": "class NumArray(_nums: Array[Int]) {\n\n    def update(i: Int, `val`: Int) {\n        \n    }\n\n    def sumRange(i: Int, j: Int): Int = {\n        \n    }\n\n}\n\n/**\n * Your NumArray object will be instantiated and called as such:\n * var obj = new NumArray(nums)\n * obj.update(i,`val`)\n * var param_2 = obj.sumRange(i,j)\n */"
    },
    {
      "lang": "Kotlin",
      "code": "class NumArray(nums: IntArray) {\n\n    fun update(i: Int, `val`: Int) {\n        \n    }\n\n    fun sumRange(i: Int, j: Int): Int {\n        \n    }\n\n}\n\n/**\n * Your NumArray object will be instantiated and called as such:\n * var obj = NumArray(nums)\n * obj.update(i,`val`)\n * var param_2 = obj.sumRange(i,j)\n */"
    },
    {
      "lang": "Rust",
      "code": "struct NumArray {\n\n}\n\n\n/** \n * `&self` means the method takes an immutable reference.\n * If you need a mutable reference, change it to `&mut self` instead.\n */\nimpl NumArray {\n\n    fn new(nums: Vec<i32>) -> Self {\n        \n    }\n    \n    fn update(&self, i: i32, val: i32) {\n        \n    }\n    \n    fn sum_range(&self, i: i32, j: i32) -> i32 {\n        \n    }\n}\n\n/**\n * Your NumArray object will be instantiated and called as such:\n * let obj = NumArray::new(nums);\n * obj.update(i, val);\n * let ret_2: i32 = obj.sum_range(i, j);\n */"
    },
    {
      "lang": "PHP",
      "code": "class NumArray {\n    /**\n     * @param Integer[] $nums\n     */\n    function __construct($nums) {\n        \n    }\n  \n    /**\n     * @param Integer $i\n     * @param Integer $val\n     * @return NULL\n     */\n    function update($i, $val) {\n        \n    }\n  \n    /**\n     * @param Integer $i\n     * @param Integer $j\n     * @return Integer\n     */\n    function sumRange($i, $j) {\n        \n    }\n}\n\n/**\n * Your NumArray object will be instantiated and called as such:\n * $obj = NumArray($nums);\n * $obj->update($i, $val);\n * $ret_2 = $obj->sumRange($i, $j);\n */"
    }
  ],
  "stats": "{\"totalAccepted\": \"88.1K\", \"totalSubmission\": \"280.4K\", \"totalAcceptedRaw\": 88100, \"totalSubmissionRaw\": 280403, \"acRate\": \"31.4%\"}",
  "hints": [],
  "solution": {
    "id": "29",
    "canSeeDetail": true,
    "url": "/articles/range-sum-query-mutable/",
    "content": "[TOC]\n\n## Summary\nThis article is for intermediate level readers. It introduces the following concepts:\nRange sum query, Sqrt decomposition, Segment tree.\n\n## Solution\n\n---\n#### Approach 1: Naive\n\n**Algorithm**\n\nA trivial solution for Range Sum Query - `RSQ(i, j)` is to iterate the array from index $$i$$ to $$j$$ and sum each element.\n\n\n<iframe src=\"https://leetcode.com/playground/nzt96HJe/shared\" frameBorder=\"0\" width=\"100%\" height=\"276\" name=\"nzt96HJe\"></iframe>\n\n**Complexity Analysis**\n\n* Time complexity : $$O(n)$$ - range sum query, $$O(1)$$ - update query\n\n    For range sum query we access each element from the array for constant time and in the worst case we access $$n$$ elements. Therefore time complexity is $$O(n)$$. Time complexity of update query is $$O(1)$$.\n\n* Space complexity : $$O(1)$$.\n<br />\n<br />\n---\n#### Approach 2: Sqrt Decomposition\n\n**Intuition**\n\nThe idea is to  split the array in blocks with length of $$\\sqrt{n}$$. Then we calculate the sum of each block and store it in auxiliary memory `b`.\nTo query `RSQ(i, j)`, we will add the sums of all the blocks lying inside and those that partially overlap with range $$[i \\ldots j]$$.\n\n**Algorithm**\n\n![Range sum query using SQRT decomposition](https://leetcode.com/media/original_images/307_RSQ_Sqrt.png){:width=\"539px\"}\n{:align=\"center\"}\n\n*Figure 1. Range sum query using SQRT decomposition.*\n{:align=\"center\"}\n\nIn the example above, the array `nums`'s length is `9`, which is split into blocks of size $$\\sqrt{9}$$. To get `RSQ(1, 7)` we add `b[1]`.  It stores the sum of `range [3, 5]` and partially sums from `block 0`  and `block 2`, which are overlapping boundary blocks.\n\n\n<iframe src=\"https://leetcode.com/playground/MViGYc5D/shared\" frameBorder=\"0\" width=\"100%\" height=\"500\" name=\"MViGYc5D\"></iframe>\n\n**Complexity Analysis**\n\n* Time complexity : $$O(n)$$ - preprocessing, $$O(\\sqrt{n})$$ - range sum query, $$O(1)$$ - update query\n\n    For range sum query in the worst-case scenario we have to sum approximately $$3 \\sqrt{n}$$ elements. In this case the range includes $$\\sqrt{n} - 2$$ blocks, which total sum costs $$\\sqrt{n} - 2$$ operations. In addition to this we have to add the sum of the two boundary blocks. This takes another $$2 (\\sqrt{n} - 1)$$ operations. The total amount of operations is around $$3 \\sqrt{n}$$.\n\n* Space complexity : $$O(\\sqrt{n})$$.\n\n    We need additional $$\\sqrt{n}$$ memory to store all block sums.\n<br />\n<br />\n---\n#### Approach 3: Segment Tree\n\n**Algorithm**\n\nSegment tree is a very flexible data structure, because it is used to solve numerous range query problems like finding minimum, maximum, sum, greatest common divisor, least common denominator in array in logarithmic time.\n\n![Illustration of Segment tree](https://leetcode.com/media/original_images/307_RSQ_SegmentTree.png){:width=\"539px\"}\n{:align=\"center\"}\n\n*Figure 2. Illustration of Segment tree.*\n{:align=\"center\"}\n\nThe segment tree for array $$a[0, 1, \\ldots ,n-1]$$ is a binary tree in which each node contains **aggregate** information (min, max, sum, etc.) for a subrange $$[i \\ldots j]$$ of the array, as its left and right child hold information for range $$[i \\ldots \\frac{i+j}{2}]$$ and $$[\\frac{i + j}{2} + 1, j]$$.\n\nSegment tree could be implemented using either an array or a tree. For an array implementation, if the element at index $$i$$ is not a leaf, its left and right child are stored at index $$2i$$ and $$2i + 1$$ respectively.\n\nIn the example above (Figure 2), every leaf node contains the initial array elements `{2,4,5,7,8,9}`. The internal nodes contain the sum of the corresponding elements in range - `(11)` for the elements from index 0 to index 2. The root `(35)` being the sum  of its children `(6)`;`(29)`, holds the total sum of the entire array.\n\nSegment Tree can be broken down to the three following steps:\n\n1. Pre-processing step which builds the segment tree from a given array.\n2. Update the segment tree when an element is modified.\n3. Calculate the Range Sum Query using the segment tree.\n\n##### 1. Build segment tree\n\nWe will use a very effective bottom-up approach to build segment tree. We already know from the above that if some node $$p$$ holds the sum of $$[i \\ldots j]$$ range, its left and right children hold the sum for range $$[i \\ldots \\frac{i + j}{2}]$$ and $$[\\frac{i + j}{2} + 1, j]$$ respectively.\n\nTherefore to find the sum of node $$p$$, we need to calculate the sum of its right and left child in advance.\n\nWe begin from the leaves, initialize them with input array elements $$a[0, 1, \\ldots, n-1]$$. Then we move upward to the higher level to calculate the parents' sum till we get to the root of the segment tree.\n\n\n<iframe src=\"https://leetcode.com/playground/EnAGDmuY/shared\" frameBorder=\"0\" width=\"100%\" height=\"310\" name=\"EnAGDmuY\"></iframe>\n\n**Complexity Analysis**\n\n* Time complexity : $$O(n)$$\n\n    Time complexity is  $$O(n)$$, because we calculate the sum of one node during each iteration of the for loop. There are approximately $$2n$$ nodes in a segment tree.\n\n    This could be proved in the following way: Segmented tree for array with $$n$$ elements has $$n$$ leaves (the array elements itself). The number of nodes in each level is half the number in the level below.\n\n    So if we sum the number by level we will get:\n\n    $$\n    n + n/2  + n/4 + n/8 + \\ldots + 1 \\approx 2n\n    $$\n\n* Space complexity : $$O(n)$$.\n\n    We used $$2n$$ extra space to store the segment tree.\n\n##### 2. Update segment tree\n\nWhen we update the array at some index $$i$$ we need to rebuild the segment tree, because there are tree nodes which contain the sum of the modified element. Again we will use a bottom-up approach. We update the leaf node that stores $$a[i]$$. From there we will follow the path up to the root updating the value of each parent as a sum of its children values.\n\n\n<iframe src=\"https://leetcode.com/playground/SyzW2D6T/shared\" frameBorder=\"0\" width=\"100%\" height=\"327\" name=\"SyzW2D6T\"></iframe>\n\n**Complexity Analysis**\n\n* Time complexity : $$O(\\log n)$$.\n\n    Algorithm  has $$O(\\log n)$$ time complexity, because there are a few tree nodes with range that include  $$i$$th array element, one on each level. There are $$\\log(n)$$  levels.\n\n* Space complexity : $$O(1)$$.\n\n##### 3. Range Sum Query\n\nWe can find range sum query  $$[L, R]$$ using segment tree in the following way:\n\nAlgorithm hold loop invariant:\n\n$$l \\le r$$ and sum of $$[L \\ldots l]$$ and $$[r \\ldots R]$$ has been calculated, where $$l$$ and $$r$$ are the left and right boundary of calculated sum.\nInitially we set $$l$$ with left leaf $$L$$ and $$r$$ with right leaf $$R$$.\nRange $$[l, r]$$ shrinks on each iteration till range borders meets after approximately $$\\log n$$ iterations of the algorithm\n\n* Loop till $$l \\le r$$\n    * Check if $$l$$ is right child of its parent $$P$$\n        * $$l$$ is right child of $$P$$. Then $$P$$ contains sum of range of $$l$$ and another  child which is outside the range $$[l, r]$$ and we don't need parent $$P$$ sum. Add $$l$$ to $$sum$$ without its parent $$P$$ and set $$l$$ to point to the right of $$P$$ on the upper level.\n        * $$l$$ is not right child of $$P$$. Then parent $$P$$ contains sum of range which lies in $$[l, r]$$. Add $$P$$ to $$sum$$ and set $$l$$ to point to the parent of $$P$$\n    * Check if $$r$$ is left child of its parent $$P$$\n        * $$r$$ is left child of $$P$$. Then $$P$$ contains sum of range of $$r$$ and another  child which is outside the range $$[l, r]$$ and we don't need parent $$P$$ sum. Add $$r$$  to $$sum$$ without its parent $$P$$ and set $$r$$ to point to the left of $$P$$ on the upper level.\n        * $$r$$ is not left child of $$P$$. Then parent $$P$$ contains sum of range which lies in $$[l, r]$$. Add $$P$$ to $$sum$$ and set $$r$$ to point to the parent of $$P$$\n\n\n<iframe src=\"https://leetcode.com/playground/Vfdts4QK/shared\" frameBorder=\"0\" width=\"100%\" height=\"395\" name=\"Vfdts4QK\"></iframe>\n\n**Complexity Analysis**\n\n* Time complexity : $$O(\\log n)$$\n\n    Time complexity is $$O(\\log n)$$ because on each iteration of the algorithm we move one level up, either to the parent of the  current node or to the next sibling of parent to the left or right direction till the two boundaries meet. In the worst-case scenario this happens at the root after $$\\log n$$ iterations of the algorithm.\n\n* Space complexity : $$O(1)$$.\n\n## Further Thoughts\n\nThe iterative version of Segment Trees was introduced in this article. A more intuitive, recursive version of Segment Trees to solve this problem is discussed [here](https://leetcode.com/articles/a-recursive-approach-to-segment-trees-range-sum-queries-lazy-propagation/). The concept of Lazy Propagation is also introduced there.\n\nThere is an alternative solution of the problem using Binary Indexed Tree. It is faster and simpler to code.\nYou can find it [here](https://leetcode.com/problems/range-sum-query-mutable/discuss/75753/Java-using-Binary-Indexed-Tree-with-clear-explanation).\n\n\nAnalysis written by: @elmirap.",
    "contentTypeId": "107",
    "rating": {
      "id": "27",
      "count": 81,
      "average": 4.778,
      "userRating": null
    }
  },
  "status": null,
  "sampleTestCase": "[\"NumArray\",\"sumRange\",\"update\",\"sumRange\"]\n[[[1,3,5]],[0,2],[1,2],[0,2]]",
  "metaData": "{\r\n    \"classname\": \"NumArray\",\r\n    \"maxbytesperline\": 170000,\r\n    \"constructor\": {\r\n        \"params\": [\r\n            {\r\n                \"type\": \"integer[]\",\r\n                \"name\": \"nums\"\r\n            },\r\n            {\r\n                \"type\": \"integer\",\r\n                \"name\": \"numsSize\",\r\n                \"lang\": \"c\",\r\n                \"value\": \"size_1\"\r\n            }\r\n        ]\r\n    },\r\n    \"methods\": [\r\n        {\r\n            \"name\" : \"update\",\r\n            \"params\": [\r\n                {\r\n                    \"type\": \"integer\",\r\n                    \"name\": \"i\"\r\n                },\r\n                {\r\n                    \"type\": \"integer\",\r\n                    \"name\": \"val\"\r\n                }\r\n            ],\r\n            \"return\": {\r\n                \"type\": \"void\"\r\n            }\r\n        },\r\n        {\r\n            \"name\" : \"sumRange\",\r\n            \"params\": [\r\n                {\r\n                    \"type\": \"integer\",\r\n                    \"name\": \"i\"\r\n                },\r\n                {\r\n                    \"type\": \"integer\",\r\n                    \"name\": \"j\"\r\n                }\r\n            ],\r\n            \"return\": {\r\n                \"type\": \"integer\"\r\n            }\r\n        }\r\n    ],\r\n    \"systemdesign\": true,\r\n    \"params\": [\r\n        {\r\n            \"name\": \"inputs\",\r\n            \"type\": \"integer[]\"\r\n        },\r\n        {\r\n            \"name\": \"inputs\",\r\n            \"type\": \"integer[]\"\r\n        }\r\n    ],\r\n    \"return\": {\r\n        \"type\": \"list<String>\",\r\n        \"dealloc\": true\r\n    }\r\n}",
  "judgerAvailable": true,
  "judgeType": "large",
  "mysqlSchemas": [],
  "enableRunCode": true,
  "enableTestMode": false,
  "libraryUrl": null
}
