{
  "questionId": "384",
  "questionFrontendId": "384",
  "boundTopicId": null,
  "title": "Shuffle an Array",
  "titleSlug": "shuffle-an-array",
  "categoryTitle": "Algorithms",
  "content": "<p>Shuffle a set of numbers without duplicates.\r\n</p>\r\n\r\n<p><b>Example:</b>\r\n<pre>\r\n// Init an array with set 1, 2, and 3.\r\nint[] nums = {1,2,3};\r\nSolution solution = new Solution(nums);\r\n\r\n// Shuffle the array [1,2,3] and return its result. Any permutation of [1,2,3] must equally likely to be returned.\r\nsolution.shuffle();\r\n\r\n// Resets the array back to its original configuration [1,2,3].\r\nsolution.reset();\r\n\r\n// Returns the random shuffling of array [1,2,3].\r\nsolution.shuffle();\r\n</pre>\r\n</p>",
  "isPaidOnly": false,
  "difficulty": "Medium",
  "likes": 361,
  "dislikes": 822,
  "isLiked": null,
  "similarQuestions": "[]",
  "contributors": [],
  "topicTags": [],
  "companyTagStats": "{\"1\": [{\"taggedByAdmin\": false, \"name\": \"Amazon\", \"slug\": \"amazon\", \"timesEncountered\": 4}, {\"taggedByAdmin\": false, \"name\": \"Yahoo\", \"slug\": \"yahoo\", \"timesEncountered\": 3}, {\"taggedByAdmin\": false, \"name\": \"Microsoft\", \"slug\": \"microsoft\", \"timesEncountered\": 2}, {\"taggedByAdmin\": false, \"name\": \"Bloomberg\", \"slug\": \"bloomberg\", \"timesEncountered\": 2}, {\"taggedByAdmin\": false, \"name\": \"Apple\", \"slug\": \"apple\", \"timesEncountered\": 2}], \"3\": [{\"taggedByAdmin\": false, \"name\": \"Cisco\", \"slug\": \"cisco\", \"timesEncountered\": 3}, {\"taggedByAdmin\": false, \"name\": \"Google\", \"slug\": \"google\", \"timesEncountered\": 3}, {\"taggedByAdmin\": false, \"name\": \"Salesforce\", \"slug\": \"salesforce\", \"timesEncountered\": 3}, {\"taggedByAdmin\": false, \"name\": \"LinkedIn\", \"slug\": \"linkedin\", \"timesEncountered\": 2}], \"2\": [{\"taggedByAdmin\": false, \"name\": \"TripAdvisor\", \"slug\": \"tripadvisor\", \"timesEncountered\": 2}]}",
  "codeSnippets": [
    {
      "lang": "C++",
      "code": "class Solution {\npublic:\n    Solution(vector<int>& nums) {\n        \n    }\n    \n    /** Resets the array to its original configuration and return it. */\n    vector<int> reset() {\n        \n    }\n    \n    /** Returns a random shuffling of the array. */\n    vector<int> shuffle() {\n        \n    }\n};\n\n/**\n * Your Solution object will be instantiated and called as such:\n * Solution* obj = new Solution(nums);\n * vector<int> param_1 = obj->reset();\n * vector<int> param_2 = obj->shuffle();\n */"
    },
    {
      "lang": "Java",
      "code": "class Solution {\n\n    public Solution(int[] nums) {\n        \n    }\n    \n    /** Resets the array to its original configuration and return it. */\n    public int[] reset() {\n        \n    }\n    \n    /** Returns a random shuffling of the array. */\n    public int[] shuffle() {\n        \n    }\n}\n\n/**\n * Your Solution object will be instantiated and called as such:\n * Solution obj = new Solution(nums);\n * int[] param_1 = obj.reset();\n * int[] param_2 = obj.shuffle();\n */"
    },
    {
      "lang": "Python",
      "code": "class Solution(object):\n\n    def __init__(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        \"\"\"\n        \n\n    def reset(self):\n        \"\"\"\n        Resets the array to its original configuration and return it.\n        :rtype: List[int]\n        \"\"\"\n        \n\n    def shuffle(self):\n        \"\"\"\n        Returns a random shuffling of the array.\n        :rtype: List[int]\n        \"\"\"\n        \n\n\n# Your Solution object will be instantiated and called as such:\n# obj = Solution(nums)\n# param_1 = obj.reset()\n# param_2 = obj.shuffle()"
    },
    {
      "lang": "Python3",
      "code": "class Solution:\n\n    def __init__(self, nums: List[int]):\n        \n\n    def reset(self) -> List[int]:\n        \"\"\"\n        Resets the array to its original configuration and return it.\n        \"\"\"\n        \n\n    def shuffle(self) -> List[int]:\n        \"\"\"\n        Returns a random shuffling of the array.\n        \"\"\"\n        \n\n\n# Your Solution object will be instantiated and called as such:\n# obj = Solution(nums)\n# param_1 = obj.reset()\n# param_2 = obj.shuffle()"
    },
    {
      "lang": "C",
      "code": "\n\n\ntypedef struct {\n    \n} Solution;\n\n\nSolution* solutionCreate(int* nums, int numsSize) {\n    \n}\n\n/** Resets the array to its original configuration and return it. */\nint* solutionReset(Solution* obj, int* retSize) {\n  \n}\n\n/** Returns a random shuffling of the array. */\nint* solutionShuffle(Solution* obj, int* retSize) {\n  \n}\n\nvoid solutionFree(Solution* obj) {\n    \n}\n\n/**\n * Your Solution struct will be instantiated and called as such:\n * Solution* obj = solutionCreate(nums, numsSize);\n * int* param_1 = solutionReset(obj, retSize);\n \n * int* param_2 = solutionShuffle(obj, retSize);\n \n * solutionFree(obj);\n*/"
    },
    {
      "lang": "C#",
      "code": "public class Solution {\n\n    public Solution(int[] nums) {\n        \n    }\n    \n    /** Resets the array to its original configuration and return it. */\n    public int[] Reset() {\n        \n    }\n    \n    /** Returns a random shuffling of the array. */\n    public int[] Shuffle() {\n        \n    }\n}\n\n/**\n * Your Solution object will be instantiated and called as such:\n * Solution obj = new Solution(nums);\n * int[] param_1 = obj.Reset();\n * int[] param_2 = obj.Shuffle();\n */"
    },
    {
      "lang": "JavaScript",
      "code": "/**\n * @param {number[]} nums\n */\nvar Solution = function(nums) {\n    \n};\n\n/**\n * Resets the array to its original configuration and return it.\n * @return {number[]}\n */\nSolution.prototype.reset = function() {\n    \n};\n\n/**\n * Returns a random shuffling of the array.\n * @return {number[]}\n */\nSolution.prototype.shuffle = function() {\n    \n};\n\n/** \n * Your Solution object will be instantiated and called as such:\n * var obj = new Solution(nums)\n * var param_1 = obj.reset()\n * var param_2 = obj.shuffle()\n */"
    },
    {
      "lang": "Ruby",
      "code": "class Solution\n\n=begin\n    :type nums: Integer[]\n=end\n    def initialize(nums)\n        \n    end\n\n\n=begin\n    Resets the array to its original configuration and return it.\n    :rtype: Integer[]\n=end\n    def reset()\n        \n    end\n\n\n=begin\n    Returns a random shuffling of the array.\n    :rtype: Integer[]\n=end\n    def shuffle()\n        \n    end\n\n\nend\n\n# Your Solution object will be instantiated and called as such:\n# obj = Solution.new(nums)\n# param_1 = obj.reset()\n# param_2 = obj.shuffle()"
    },
    {
      "lang": "Swift",
      "code": "\nclass Solution {\n\n    init(_ nums: [Int]) {\n        \n    }\n    \n    /** Resets the array to its original configuration and return it. */\n    func reset() -> [Int] {\n        \n    }\n    \n    /** Returns a random shuffling of the array. */\n    func shuffle() -> [Int] {\n        \n    }\n}\n\n/**\n * Your Solution object will be instantiated and called as such:\n * let obj = Solution(nums)\n * let ret_1: [Int] = obj.reset()\n * let ret_2: [Int] = obj.shuffle()\n */"
    },
    {
      "lang": "Go",
      "code": "type Solution struct {\n    \n}\n\n\nfunc Constructor(nums []int) Solution {\n    \n}\n\n\n/** Resets the array to its original configuration and return it. */\nfunc (this *Solution) Reset() []int {\n    \n}\n\n\n/** Returns a random shuffling of the array. */\nfunc (this *Solution) Shuffle() []int {\n    \n}\n\n\n/**\n * Your Solution object will be instantiated and called as such:\n * obj := Constructor(nums);\n * param_1 := obj.Reset();\n * param_2 := obj.Shuffle();\n */"
    },
    {
      "lang": "Scala",
      "code": "class Solution(_nums: Array[Int]) {\n\n    /** Resets the array to its original configuration and return it. */\n    def reset(): Array[Int] = {\n        \n    }\n\n    /** Returns a random shuffling of the array. */\n    def shuffle(): Array[Int] = {\n        \n    }\n\n}\n\n/**\n * Your Solution object will be instantiated and called as such:\n * var obj = new Solution(nums)\n * var param_1 = obj.reset()\n * var param_2 = obj.shuffle()\n */"
    },
    {
      "lang": "Kotlin",
      "code": "class Solution(nums: IntArray) {\n\n    /** Resets the array to its original configuration and return it. */\n    fun reset(): IntArray {\n        \n    }\n\n    /** Returns a random shuffling of the array. */\n    fun shuffle(): IntArray {\n        \n    }\n\n}\n\n/**\n * Your Solution object will be instantiated and called as such:\n * var obj = Solution(nums)\n * var param_1 = obj.reset()\n * var param_2 = obj.shuffle()\n */"
    },
    {
      "lang": "Rust",
      "code": "struct Solution {\n\n}\n\n\n/** \n * `&self` means the method takes an immutable reference.\n * If you need a mutable reference, change it to `&mut self` instead.\n */\nimpl Solution {\n\n    fn new(nums: Vec<i32>) -> Self {\n        \n    }\n    \n    /** Resets the array to its original configuration and return it. */\n    fn reset(&self) -> Vec<i32> {\n        \n    }\n    \n    /** Returns a random shuffling of the array. */\n    fn shuffle(&self) -> Vec<i32> {\n        \n    }\n}\n\n/**\n * Your Solution object will be instantiated and called as such:\n * let obj = Solution::new(nums);\n * let ret_1: Vec<i32> = obj.reset();\n * let ret_2: Vec<i32> = obj.shuffle();\n */"
    },
    {
      "lang": "PHP",
      "code": "class Solution {\n    /**\n     * @param Integer[] $nums\n     */\n    function __construct($nums) {\n        \n    }\n  \n    /**\n     * Resets the array to its original configuration and return it.\n     * @return Integer[]\n     */\n    function reset() {\n        \n    }\n  \n    /**\n     * Returns a random shuffling of the array.\n     * @return Integer[]\n     */\n    function shuffle() {\n        \n    }\n}\n\n/**\n * Your Solution object will be instantiated and called as such:\n * $obj = Solution($nums);\n * $ret_1 = $obj->reset();\n * $ret_2 = $obj->shuffle();\n */"
    }
  ],
  "stats": "{\"totalAccepted\": \"98.8K\", \"totalSubmission\": \"192.1K\", \"totalAcceptedRaw\": 98834, \"totalSubmissionRaw\": 192130, \"acRate\": \"51.4%\"}",
  "hints": [
    "The solution expects that we always use the original array to shuffle() else some of the test cases fail. (Credits; @snehasingh31)"
  ],
  "solution": {
    "id": "287",
    "canSeeDetail": true,
    "url": "/articles/shuffle-an-array/",
    "content": "[TOC]\n\n#### Initial Thoughts\n\nNormally I would display more than two approaches, but shuffling is\ndeceptively easy to do _almost_ properly, and the Fisher-Yates algorithm is\nboth the canonical solution and asymptotically optimal.\n\nA few notes on randomness are necessary before beginning - both approaches\ndisplayed below assume that the languages' pseudorandom number generators\n(PRNGs) are sufficiently random. The sample code uses the simplest techniques\navailable for getting pseudorandom numbers, but for each possible permutation\nof the array to be truly equally likely, more care must be taken. For\nexample, an array of length $$n$$ has $$n!$$ distinct permutations. Therefore, in\norder to encode all permutations in an integer space, $$\\lceil lg(n!)\\rceil$$\nbits are necessary, which may not be guaranteed by the default PRNG.\n\n#### Approach #1 Brute Force [Accepted]\n\n**Intuition**\n\nIf we put each number in a \"hat\" and draw them out at random, the order in\nwhich we draw them will define a random ordering.\n\n**Algorithm**\n\nThe brute force algorithm essentially puts each number in the aforementioned\n\"hat\", and draws them at random (without replacement) until there are none\nleft. Mechanically, this is performed by copying the contents of `array` into\na second auxiliary array named `aux` before overwriting each element of\n`array` with a randomly selected one from `aux`. After selecting each random\nelement, it is removed from `aux` to prevent duplicate draws. The\nimplementation of `reset` is simple, as we just store the original state of\n`nums` on construction.\n\nThe correctness of the algorithm follows from the fact that an element\n(without loss of generality) is equally likely to be selected during all\niterations of the `for` loop. To prove this, observe that the probability of a\nparticular element $$e$$ being chosen on the $$k$$th iteration (indexed from 0)\nis simply $$P(e$$ being chosen during the $$k$$th iteration$$)\\cdot P(e$$ not being\nchosen before the $$k$$th iteration$$)$$. Given that the array to be shuffled has\n$$n$$ elements, this probability is more concretely stated as the following:\n\n$$\n   \\frac{1}{n-k} \\cdot \\prod_{i=1}^{k} \\frac{n-i}{n-i+1}\n$$\n\nWhen expanded (and rearranged), it looks like this (for sufficiently large\n$$k$$):\n\n$$\n   (\\frac{n-1}{n}\n   \\cdot \\frac{n-2}{n-1}\n   \\cdot (\\ldots)\n   \\cdot \\frac{n-k+1}{n-k+2}\n   \\cdot \\frac{n-k}{n-k+1})\n   \\cdot \\frac{1}{n-k}\n$$\n\nFor the base case ($$k = 0$$), it is trivial to see that\n$$\\frac{1}{n-k} = \\frac{1}{n}$$. For $$k > 0$$, the numerator of each fraction\ncan be cancelled with the denominator of the next, leaving the $$n$$ from the\n0th draw as the only uncancelled denominator. Therefore, no matter on which\ndraw an element is drawn, it is drawn with a $$\\frac{1}{n}$$ chance, so each\narray permutation is equally likely to arise.\n\n<iframe src=\"https://leetcode.com/playground/FWMsaXQ7/shared\" frameBorder=\"0\" width=\"100%\" height=\"500\" name=\"FWMsaXQ7\"></iframe>\n\n**Complexity Analysis**\n\n* Time complexity : $$O(n^2)$$\n\n    The quadratic time complexity arises from the calls to `list.remove` (or\n    `list.pop`), which run in linear time. $$n$$ linear list removals occur,\n    which results in a fairly easy quadratic analysis.\n\n* Space complexity : $$O(n)$$\n\n    Because the problem also asks us to implement `reset`, we must use linear\n    additional space to store the original array. Otherwise, it would be lost\n    upon the first call to `shuffle`.\n\n---\n\n#### Approach #2 Fisher-Yates Algorithm [Accepted]\n\n**Intuition**\n\nWe can cut down the time and space complexities of `shuffle` with a bit of\ncleverness - namely, by swapping elements around within the array itself, we\ncan avoid the linear space cost of the auxiliary array and the linear time\ncost of list modification.\n\n**Algorithm**\n\nThe Fisher-Yates algorithm is remarkably similar to the brute force solution.\nOn each iteration of the algorithm, we generate a random integer between the\ncurrent index and the last index of the array. Then, we swap the elements at\nthe current index and the chosen index - this simulates drawing (and\nremoving) the element from the hat, as the next range from which we select a\nrandom index will not include the most recently processed one. One small, yet important\ndetail is that it is possible to swap an element with itself - otherwise, some\narray permutations would be more likely than others. To see this illustrated more\nclearly, consider the animation below:\n\n!?!../Documents/384_Shuffle_an_Array.json:697,161!?!\n\n<iframe src=\"https://leetcode.com/playground/ftmztsv8/shared\" frameBorder=\"0\" width=\"100%\" height=\"500\" name=\"ftmztsv8\"></iframe>\n\n**Complexity Analysis**\n\n* Time complexity : $$O(n)$$\n\n    The Fisher-Yates algorithm runs in linear time, as generating a random\n    index and swapping two values can be done in constant time.\n\n* Space complexity : $$O(n)$$\n\n    Although we managed to avoid using linear space on the auxiliary array\n    from the brute force approach, we still need it for `reset`, so we're\n    stuck with linear space complexity.\n\n---\n\nAnalysis written by: [@emptyset](https://leetcode.com/emptyset)",
    "contentTypeId": "107",
    "rating": {
      "id": "282",
      "count": 23,
      "average": 4.783,
      "userRating": null
    }
  },
  "status": null,
  "sampleTestCase": "[\"Solution\",\"shuffle\",\"reset\",\"shuffle\"]\n[[[1,2,3]],[],[],[]]",
  "metaData": "{\r\n    \"classname\": \"Solution\",\r\n    \"maxbytesperline\": 180000,\r\n    \"constructor\": {\r\n        \"params\": [\r\n            {\r\n                \"type\": \"integer[]\",\r\n                \"name\": \"nums\"\r\n            },\r\n            {\r\n                \"type\": \"integer\",\r\n                \"name\": \"size\",\r\n                \"lang\": \"c\",\r\n                \"value\": \"size_1\"\r\n            }\r\n        ]\r\n    },\r\n    \"methods\": [\r\n        {\r\n            \"name\" : \"reset\",\r\n            \"params\": [\r\n            ],\r\n            \"return\": {\r\n                \"type\": \"integer[]\"\r\n            },\r\n            \"comment\": \"Resets the array to its original configuration and return it.\"\r\n        },\r\n        {\r\n            \"name\" : \"shuffle\",\r\n            \"params\": [\r\n            ],\r\n            \"return\": {\r\n                \"type\": \"integer[]\"\r\n            },\r\n            \"comment\": \"Returns a random shuffling of the array.\"\r\n        }\r\n    ],\r\n    \"systemdesign\": true,\r\n    \"params\": [\r\n        {\r\n            \"name\": \"inputs\",\r\n            \"type\": \"integer[]\"\r\n        },\r\n        {\r\n            \"name\": \"inputs\",\r\n            \"type\": \"integer[]\"\r\n        }\r\n    ],\r\n    \"return\": {\r\n        \"type\": \"list<String>\",\r\n        \"dealloc\": true\r\n    }\r\n}",
  "judgerAvailable": true,
  "judgeType": "large",
  "mysqlSchemas": [],
  "enableRunCode": true,
  "enableTestMode": false,
  "libraryUrl": null
}
