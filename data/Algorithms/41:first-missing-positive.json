{
  "questionId": "41",
  "questionFrontendId": "41",
  "boundTopicId": null,
  "title": "First Missing Positive",
  "titleSlug": "first-missing-positive",
  "categoryTitle": "Algorithms",
  "content": "<p>Given an unsorted integer array, find the smallest missing&nbsp;positive integer.</p>\r\n\r\n<p><strong>Example 1:</strong></p>\r\n\r\n<pre>\r\nInput: [1,2,0]\r\nOutput: 3\r\n</pre>\r\n\r\n<p><strong>Example 2:</strong></p>\r\n\r\n<pre>\r\nInput: [3,4,-1,1]\r\nOutput: 2\r\n</pre>\r\n\r\n<p><strong>Example 3:</strong></p>\r\n\r\n<pre>\r\nInput: [7,8,9,11,12]\r\nOutput: 1\r\n</pre>\r\n\r\n<p><strong>Note:</strong></p>\r\n\r\n<p>Your algorithm should run in <em>O</em>(<em>n</em>) time and uses constant extra space.</p>\r\n",
  "isPaidOnly": false,
  "difficulty": "Hard",
  "likes": 2395,
  "dislikes": 683,
  "isLiked": null,
  "similarQuestions": "[{\"title\": \"Missing Number\", \"titleSlug\": \"missing-number\", \"difficulty\": \"Easy\", \"translatedTitle\": null}, {\"title\": \"Find the Duplicate Number\", \"titleSlug\": \"find-the-duplicate-number\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Find All Numbers Disappeared in an Array\", \"titleSlug\": \"find-all-numbers-disappeared-in-an-array\", \"difficulty\": \"Easy\", \"translatedTitle\": null}, {\"title\": \"Couples Holding Hands\", \"titleSlug\": \"couples-holding-hands\", \"difficulty\": \"Hard\", \"translatedTitle\": null}]",
  "contributors": [],
  "topicTags": [
    {
      "name": "Array",
      "slug": "array"
    }
  ],
  "companyTagStats": "{\"3\": [{\"taggedByAdmin\": false, \"name\": \"Pocket Gems\", \"slug\": \"pocket-gems\", \"timesEncountered\": 2}, {\"taggedByAdmin\": false, \"name\": \"Airbnb\", \"slug\": \"airbnb\", \"timesEncountered\": 2}, {\"taggedByAdmin\": false, \"name\": \"SAP\", \"slug\": \"sap\", \"timesEncountered\": 2}, {\"taggedByAdmin\": false, \"name\": \"Grab\", \"slug\": \"grab\", \"timesEncountered\": 2}, {\"taggedByAdmin\": false, \"name\": \"Wayfair\", \"slug\": \"wayfair\", \"timesEncountered\": 2}], \"1\": [{\"taggedByAdmin\": false, \"name\": \"Google\", \"slug\": \"google\", \"timesEncountered\": 5}, {\"taggedByAdmin\": false, \"name\": \"Amazon\", \"slug\": \"amazon\", \"timesEncountered\": 4}, {\"taggedByAdmin\": false, \"name\": \"Databricks\", \"slug\": \"databricks\", \"timesEncountered\": 3}, {\"taggedByAdmin\": false, \"name\": \"Facebook\", \"slug\": \"facebook\", \"timesEncountered\": 3}, {\"taggedByAdmin\": false, \"name\": \"Bloomberg\", \"slug\": \"bloomberg\", \"timesEncountered\": 3}, {\"taggedByAdmin\": false, \"name\": \"Wish\", \"slug\": \"wish\", \"timesEncountered\": 3}, {\"taggedByAdmin\": false, \"name\": \"ByteDance\", \"slug\": \"bytedance\", \"timesEncountered\": 2}], \"2\": [{\"taggedByAdmin\": false, \"name\": \"Microsoft\", \"slug\": \"microsoft\", \"timesEncountered\": 7}, {\"taggedByAdmin\": false, \"name\": \"Adobe\", \"slug\": \"adobe\", \"timesEncountered\": 3}, {\"taggedByAdmin\": false, \"name\": \"Walmart Labs\", \"slug\": \"walmart-labs\", \"timesEncountered\": 3}, {\"taggedByAdmin\": false, \"name\": \"Uber\", \"slug\": \"uber\", \"timesEncountered\": 2}, {\"taggedByAdmin\": false, \"name\": \"Apple\", \"slug\": \"apple\", \"timesEncountered\": 2}]}",
  "codeSnippets": [
    {
      "lang": "C++",
      "code": "class Solution {\npublic:\n    int firstMissingPositive(vector<int>& nums) {\n        \n    }\n};"
    },
    {
      "lang": "Java",
      "code": "class Solution {\n    public int firstMissingPositive(int[] nums) {\n        \n    }\n}"
    },
    {
      "lang": "Python",
      "code": "class Solution(object):\n    def firstMissingPositive(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        "
    },
    {
      "lang": "Python3",
      "code": "class Solution:\n    def firstMissingPositive(self, nums: List[int]) -> int:\n        "
    },
    {
      "lang": "C",
      "code": "\n\nint firstMissingPositive(int* nums, int numsSize){\n\n}\n\n"
    },
    {
      "lang": "C#",
      "code": "public class Solution {\n    public int FirstMissingPositive(int[] nums) {\n        \n    }\n}"
    },
    {
      "lang": "JavaScript",
      "code": "/**\n * @param {number[]} nums\n * @return {number}\n */\nvar firstMissingPositive = function(nums) {\n    \n};"
    },
    {
      "lang": "Ruby",
      "code": "# @param {Integer[]} nums\n# @return {Integer}\ndef first_missing_positive(nums)\n    \nend"
    },
    {
      "lang": "Swift",
      "code": "class Solution {\n    func firstMissingPositive(_ nums: [Int]) -> Int {\n        \n    }\n}"
    },
    {
      "lang": "Go",
      "code": "func firstMissingPositive(nums []int) int {\n    \n}"
    },
    {
      "lang": "Scala",
      "code": "object Solution {\n    def firstMissingPositive(nums: Array[Int]): Int = {\n        \n    }\n}"
    },
    {
      "lang": "Kotlin",
      "code": "class Solution {\n    fun firstMissingPositive(nums: IntArray): Int {\n        \n    }\n}"
    },
    {
      "lang": "Rust",
      "code": "impl Solution {\n    pub fn first_missing_positive(nums: Vec<i32>) -> i32 {\n        \n    }\n}"
    },
    {
      "lang": "PHP",
      "code": "class Solution {\n\n    /**\n     * @param Integer[] $nums\n     * @return Integer\n     */\n    function firstMissingPositive($nums) {\n        \n    }\n}"
    }
  ],
  "stats": "{\"totalAccepted\": \"267.8K\", \"totalSubmission\": \"881.7K\", \"totalAcceptedRaw\": 267754, \"totalSubmissionRaw\": 881679, \"acRate\": \"30.4%\"}",
  "hints": [
    "Think about how you would solve the problem in non-constant space.  Can you apply that logic to the existing space?",
    "We don't care about duplicates or non-positive integers",
    "Remember that O(2n) = O(n)"
  ],
  "solution": {
    "id": "681",
    "canSeeDetail": true,
    "url": "/articles/first-missing-positive/",
    "content": "[TOC]\n\n## Solution\n\n---\n\n#### Approach 1: Index as a hash key.\n\n**Data clean up**\n\nFirst of all let's get rid of negative numbers and zeros since there is no\nneed of them. One could get rid of all numbers larger than `n` as well,\nsince the first missing positive is for sure smaller or equal to `n + 1`.\nThe case when the first missing positive is equal to `n + 1` will be\ntreated separately.  \n\n![max_first](../Figures/41/41_max_possible_first.png)\n\nWhat does it mean - to get rid of, if one has to keep $$\\mathcal{O}(N)$$\ntime complexity and hence could not pop unwanted elements out? \nLet's just replace all these by `1`s. \n\n![max_first](../Figures/41/41_replace.png)\n\nTo ensure that the first missing positive is not `1`, one has to verify \nthe presence of `1` before proceeding to this operation.\n\n**How to solve in-place**\n\nNow there we have an array which contains only positive numbers\nin a range from `1` to `n`,\nand the problem is to find a first missing positive in \n$$\\mathcal{O}(N)$$ time and constant space. \n\nThat would be simple, if one would be allowed to \nhave a hash-map `positive number -> its presence` for the array.\n\n![max_first](../Figures/41/41_missing.png)\n\nSort of \"dirty workaround\" solution would be to allocate a string `hash_str` \nwith `n` zeros, and use it as a sort of hash map by changing \n`hash_str[i]` to `1` each time one meets number `i` in the array. \n\n![max_first](../Figures/41/41_string.png)\n\nLet's not use this solution, but just take away a pretty nice idea _to use \nindex as a hash-key_ for a positive number.\n\nThe final idea is to _use index in nums as a hash key_ and _sign of \nthe element as a hash value_ which is presence detector.\n\n> For example, negative sign of `nums[2]` element means that \nnumber `2` is present in `nums`. The positive sign of `nums[3]` element\nmeans that number `3` is not present (missing) in `nums`.\n\nTo achieve that let's walk along the array (which after clean up contains \nonly positive numbers), check each element value `elem` \nand change the sign of element `nums[elem]` to negative to mark \nthat number `elem` is present in `nums`. Be careful \nwith duplicates and ensure that the sign was changed only once.\n\n![max_first](../Figures/41/41_true_solution.png)\n\n**Algorithm**\n\nNow everything is ready to write down the algorithm.\n\n* Check if `1` is present in the array. If not, you're done and `1`\nis the answer.\n* If `nums = [1]`, the answer is `2`.\n* Replace negative numbers, zeros, and numbers larger than `n` by `1`s.\n* Walk along the array. Change the sign of a-th element if you meet number `a`. \nBe careful with duplicates : do sign change only once.\nUse index `0` to save an information about presence of number `n` since \nindex `n` is not available.\n* Walk again along the array. Return the index of the first positive element.\n* If `nums[0] > 0` return `n`.\n* If on the previous step you didn't find the positive element in nums, that means\nthat the answer is `n + 1`.\n\n**Implementation**\n\n!?!../Documents/41_LIS.json:1000,589!?!\n\n<iframe src=\"https://leetcode.com/playground/sZuFyoyC/shared\" frameBorder=\"0\" width=\"100%\" height=\"500\" name=\"sZuFyoyC\"></iframe>\n\n**Complexity Analysis**\n\n* Time complexity : $$\\mathcal{O}(N)$$ since all we do here is four walks \nalong the array of length `N`.\n* Space complexity : $$\\mathcal{O}(1)$$ since this is a constant space solution.\n\nAnalysis written by @[liaison](https://leetcode.com/liaison/)\nand @[andvary](https://leetcode.com/andvary/)",
    "contentTypeId": "107",
    "rating": {
      "id": "666",
      "count": 32,
      "average": 4.531,
      "userRating": null
    }
  },
  "status": null,
  "sampleTestCase": "[1,2,0]",
  "metaData": "{\r\n  \"name\": \"firstMissingPositive\",\r\n  \"params\": [\r\n    {\r\n      \"name\": \"nums\",\r\n      \"type\": \"integer[]\"\r\n    }\r\n  ],\r\n  \"return\": {\r\n    \"type\": \"integer\"\r\n  }\r\n}",
  "judgerAvailable": true,
  "judgeType": "large",
  "mysqlSchemas": [],
  "enableRunCode": true,
  "enableTestMode": false,
  "libraryUrl": null
}
