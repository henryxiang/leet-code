{
  "questionId": "449",
  "questionFrontendId": "449",
  "boundTopicId": null,
  "title": "Serialize and Deserialize BST",
  "titleSlug": "serialize-and-deserialize-bst",
  "categoryTitle": "Algorithms",
  "content": "<p>Serialization is the process of converting a data structure or object into a sequence of bits so that it can be stored in a file or memory buffer, or transmitted across a network connection link to be reconstructed later in the same or another computer environment.</p>\r\n\r\n<p>Design an algorithm to serialize and deserialize a <b>binary search tree</b>. There is no restriction on how your serialization/deserialization algorithm should work. You just need to ensure that a binary search tree can be serialized to a string and this string can be deserialized to the original tree structure.</p>\r\n\r\n<p><b>The encoded string should be as compact as possible.</b></p>\r\n\r\n<p><b>Note:</b> Do not use class member/global/static variables to store states. Your serialize and deserialize algorithms should be stateless.</p>\r\n",
  "isPaidOnly": false,
  "difficulty": "Medium",
  "likes": 905,
  "dislikes": 58,
  "isLiked": null,
  "similarQuestions": "[{\"title\": \"Serialize and Deserialize Binary Tree\", \"titleSlug\": \"serialize-and-deserialize-binary-tree\", \"difficulty\": \"Hard\", \"translatedTitle\": null}, {\"title\": \"Find Duplicate Subtrees\", \"titleSlug\": \"find-duplicate-subtrees\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Serialize and Deserialize N-ary Tree\", \"titleSlug\": \"serialize-and-deserialize-n-ary-tree\", \"difficulty\": \"Hard\", \"translatedTitle\": null}]",
  "contributors": [
    {
      "username": "ben65",
      "profileUrl": "/ben65/",
      "avatarUrl": "https://www.gravatar.com/avatar/84d8aa1c37972fbdcbc698e402ba799d.png?s=200"
    }
  ],
  "topicTags": [
    {
      "name": "Tree",
      "slug": "tree"
    }
  ],
  "companyTagStats": "{\"3\": [{\"taggedByAdmin\": false, \"name\": \"Zillow\", \"slug\": \"zillow\", \"timesEncountered\": 4}, {\"taggedByAdmin\": false, \"name\": \"Apple\", \"slug\": \"apple\", \"timesEncountered\": 2}, {\"taggedByAdmin\": false, \"name\": \"eBay\", \"slug\": \"ebay\", \"timesEncountered\": 2}], \"1\": [{\"taggedByAdmin\": true, \"name\": \"Amazon\", \"slug\": \"amazon\", \"timesEncountered\": 8}, {\"taggedByAdmin\": false, \"name\": \"LinkedIn\", \"slug\": \"linkedin\", \"timesEncountered\": 3}, {\"taggedByAdmin\": false, \"name\": \"Microsoft\", \"slug\": \"microsoft\", \"timesEncountered\": 3}, {\"taggedByAdmin\": false, \"name\": \"Facebook\", \"slug\": \"facebook\", \"timesEncountered\": 2}, {\"taggedByAdmin\": false, \"name\": \"Uber\", \"slug\": \"uber\", \"timesEncountered\": 2}], \"2\": [{\"taggedByAdmin\": false, \"name\": \"Qualtrics\", \"slug\": \"qualtrics\", \"timesEncountered\": 3}, {\"taggedByAdmin\": false, \"name\": \"Google\", \"slug\": \"google\", \"timesEncountered\": 2}, {\"taggedByAdmin\": false, \"name\": \"Yandex\", \"slug\": \"yandex\", \"timesEncountered\": 2}]}",
  "codeSnippets": [
    {
      "lang": "C++",
      "code": "/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\n * };\n */\nclass Codec {\npublic:\n\n    // Encodes a tree to a single string.\n    string serialize(TreeNode* root) {\n        \n    }\n\n    // Decodes your encoded data to tree.\n    TreeNode* deserialize(string data) {\n        \n    }\n};\n\n// Your Codec object will be instantiated and called as such:\n// Codec codec;\n// codec.deserialize(codec.serialize(root));"
    },
    {
      "lang": "Java",
      "code": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode(int x) { val = x; }\n * }\n */\npublic class Codec {\n\n    // Encodes a tree to a single string.\n    public String serialize(TreeNode root) {\n        \n    }\n\n    // Decodes your encoded data to tree.\n    public TreeNode deserialize(String data) {\n        \n    }\n}\n\n// Your Codec object will be instantiated and called as such:\n// Codec codec = new Codec();\n// codec.deserialize(codec.serialize(root));"
    },
    {
      "lang": "Python",
      "code": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, x):\n#         self.val = x\n#         self.left = None\n#         self.right = None\n\nclass Codec:\n\n    def serialize(self, root):\n        \"\"\"Encodes a tree to a single string.\n        \n        :type root: TreeNode\n        :rtype: str\n        \"\"\"\n        \n\n    def deserialize(self, data):\n        \"\"\"Decodes your encoded data to tree.\n        \n        :type data: str\n        :rtype: TreeNode\n        \"\"\"\n        \n\n# Your Codec object will be instantiated and called as such:\n# codec = Codec()\n# codec.deserialize(codec.serialize(root))"
    },
    {
      "lang": "Python3",
      "code": "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, x):\n#         self.val = x\n#         self.left = None\n#         self.right = None\n\nclass Codec:\n\n    def serialize(self, root: TreeNode) -> str:\n        \"\"\"Encodes a tree to a single string.\n        \"\"\"\n        \n\n    def deserialize(self, data: str) -> TreeNode:\n        \"\"\"Decodes your encoded data to tree.\n        \"\"\"\n        \n\n# Your Codec object will be instantiated and called as such:\n# codec = Codec()\n# codec.deserialize(codec.serialize(root))"
    },
    {
      "lang": "C",
      "code": "/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     struct TreeNode *left;\n *     struct TreeNode *right;\n * };\n */\n/** Encodes a tree to a single string. */\nchar* serialize(struct TreeNode* root) {\n    \n}\n\n/** Decodes your encoded data to tree. */\nstruct TreeNode* deserialize(char* data) {\n    \n}\n\n// Your functions will be called as such:\n// char* data = serialize(root);\n// deserialize(data);"
    },
    {
      "lang": "C#",
      "code": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     public int val;\n *     public TreeNode left;\n *     public TreeNode right;\n *     public TreeNode(int x) { val = x; }\n * }\n */\npublic class Codec {\n\n    // Encodes a tree to a single string.\n    public string serialize(TreeNode root) {\n        \n    }\n\n    // Decodes your encoded data to tree.\n    public TreeNode deserialize(string data) {\n        \n    }\n}\n\n// Your Codec object will be instantiated and called as such:\n// Codec codec = new Codec();\n// codec.deserialize(codec.serialize(root));"
    },
    {
      "lang": "JavaScript",
      "code": "/**\n * Definition for a binary tree node.\n * function TreeNode(val) {\n *     this.val = val;\n *     this.left = this.right = null;\n * }\n */\n\n/**\n * Encodes a tree to a single string.\n *\n * @param {TreeNode} root\n * @return {string}\n */\nvar serialize = function(root) {\n    \n};\n\n/**\n * Decodes your encoded data to tree.\n *\n * @param {string} data\n * @return {TreeNode}\n */\nvar deserialize = function(data) {\n    \n};\n\n/**\n * Your functions will be called as such:\n * deserialize(serialize(root));\n */"
    },
    {
      "lang": "Ruby",
      "code": "# Definition for a binary tree node.\n# class TreeNode\n#     attr_accessor :val, :left, :right\n#     def initialize(val)\n#         @val = val\n#         @left, @right = nil, nil\n#     end\n# end\n\n# Encodes a tree to a single string.\n#\n# @param {TreeNode} root\n# @return {string}\ndef serialize(root)\n    \nend\n\n# Decodes your encoded data to tree.\n#\n# @param {string} data\n# @return {TreeNode}\ndef deserialize(data)\n    \nend\n\n\n# Your functions will be called as such:\n# deserialize(serialize(data))"
    }
  ],
  "stats": "{\"totalAccepted\": \"80K\", \"totalSubmission\": \"160.8K\", \"totalAcceptedRaw\": 80038, \"totalSubmissionRaw\": 160786, \"acRate\": \"49.8%\"}",
  "hints": [],
  "solution": {
    "id": "733",
    "canSeeDetail": true,
    "url": "/articles/serialize-and-deserialize-bst/",
    "content": "[TOC]\n\n## Solution\n\n--- \n\n#### How to make the encoded string as compact as possible\n\nThis question is similar to the [Google interview question discussed last week](https://leetcode.com/discuss/interview-experience/297576/google-onsite-interview-sde1-new-grad-mountain-view-ca).\n\n[To serialize](https://en.wikipedia.org/wiki/Serialization) \na binary tree means to \n\n- Encode tree structure. \n\n- Encode node values. \n\n- Choose delimiters to separate the values in the encoded string.\n\n![bla](../Figures/449/tree_struct.png)\n\nHence there are three axes of optimisation here.\n<br /> \n<br />\n\n\n---\n#### Approach 1: Postorder traversal to optimise space for the tree structure.\n\n**Intuition**\n\nLet's use here the fact that BST could be constructed from\npreorder or postorder traversal only. \nPlease [check this article](https://leetcode.com/problems/construct-binary-search-tree-from-preorder-traversal/solution/)\nfor the detailed discussion.\nIn brief, it's a consequence of two facts:\n\n- [Binary tree could be constructed from preorder/postorder and inorder traversal](https://leetcode.com/articles/construct-binary-tree-from-postorder-and-inorder-t/).\n\n- [Inorder traversal of BST is an array sorted in the ascending order: \n`inorder = sorted(preorder)`](https://leetcode.com/articles/delete-node-in-a-bst/).\n\nThat means that BST structure is already encoded in the preorder or\npostorder traversal and hence they are both suitable for the \ncompact serialization. \n\nSerialization could be easily implemented with both strategies,\nbut for optimal deserialization better to choose the postorder traversal because member/global/static variables\nare not allowed here. \n\n![pic](../Figures/449/approach1.png)\n\n**Implementation**\n\n<iframe src=\"https://leetcode.com/playground/FrvwhLiD/shared\" frameBorder=\"0\" width=\"100%\" height=\"500\" name=\"FrvwhLiD\"></iframe>\n\n**Complexity Analysis**\n\n* Time complexity : $$\\mathcal{O}(N)$$ both for serialization\nand deserialization. Let's compute the solution with the help of \n[master theorem](https://en.wikipedia.org/wiki/Master_theorem_(analysis_of_algorithms)) \n$$T(N) = aT\\left(\\frac{b}{N}\\right) + \\Theta(N^d)$$.\nThe equation represents dividing the problem \nup into $$a$$ subproblems of size $$\\frac{N}{b}$$ in $$\\Theta(N^d)$$ time. \nHere one divides the problem in two subproblemes `a = 2`, the size of each subproblem \n(to compute left and right subtree) is a half of initial problem `b = 2`, \nand all this happens in a constant time `d = 0`.\nThat means that $$\\log_b(a) > d$$ and hence we're dealing with \n[case 1](https://en.wikipedia.org/wiki/Master_theorem_(analysis_of_algorithms)#Case_1_example)\nthat means $$\\mathcal{O}(N^{\\log_b(a)}) = \\mathcal{O}(N)$$ time complexity.\n\n* Space complexity : $$\\mathcal{O}(N)$$, since we store the entire tree.\nEncoded string: one needs to store\n$$(N - 1)$$ delimiters, and $$N$$ node values in the encoded string. \nTree structure is encoded in the order of values and uses no space.\n<br /> \n<br />\n\n\n---\n#### Approach 2: Convert int to 4-bytes string to optimise space for node values.\n\n**Intuition**\n\nApproach 1 works fine with the small node values but starts to\nconsume more and more space in the case of large ones. \n\nFor example, the tree `[2,null,3,null,4]` is encoded as a string\n`\"4 3 2\"` which uses `5` bytes to store the values and delimiters, `1` byte per\nvalue or delimiter. So far everything is fine. \n\nLet's consider now the tree `[12345,null,12346,null,12347]` which is\nencoded as `\"12347 12346 12345\"` and consumes `17` bytes to store \n3 integers and 2 delimiters, `15` bytes for node values only.\nAt the same time it's known that `4` bytes is enough to store an int value,\n_i.e._ `12` bytes should be enough for 3 integers. \n`15 > 12` and hence the storage of values could be optimised.\n\n> How to do it? Convert each integer into 4-bytes string.\n\n![pic2](../Figures/449/four_bytes.png)\n\n**Implementation**\n\n<iframe src=\"https://leetcode.com/playground/gqcqpL6j/shared\" frameBorder=\"0\" width=\"100%\" height=\"500\" name=\"gqcqpL6j\"></iframe>\n\n**Complexity Analysis**\n\n* Time complexity : $$\\mathcal{O}(N)$$ both for serialization\nand deserialization. \n\n* Space complexity : $$\\mathcal{O}(N)$$, since we store the entire tree.\nEncoded string: one needs $$2(N - 1)$$ bytes for the delimiters, \nand $$4 N$$ bytes for the node values in the encoded string. \nTree structure is encoded in the order of node values and uses no space. \n<br /> \n<br />\n\n\n---\n#### Approach 3: Get rid of delimiters.\n\n**Intuition**\n\nApproach 2 works well except for delimiter usage.\n\nSince all node values are now encoded as 4-bytes strings,\none could just split the encoded string into 4-bytes chunks,\nconvert each chunk back to the integer and proceed further. \n\n![pic3](../Figures/449/no_delimiters.png)\n\n**Implementation**\n\n<iframe src=\"https://leetcode.com/playground/PSVDTDsj/shared\" frameBorder=\"0\" width=\"100%\" height=\"500\" name=\"PSVDTDsj\"></iframe>\n\n**Complexity Analysis**\n\n* Time complexity : $$\\mathcal{O}(N)$$ both for serialization\nand deserialization. \n\n* Space complexity : $$\\mathcal{O}(N)$$, since we store the entire tree.\nEncoded string: no delimiters, no additional space for the tree structure,\njust $$4 N$$ bytes for the node values in the encoded string. \n    \nAnalysis written by @[liaison](https://leetcode.com/liaison/)\nand @[andvary](https://leetcode.com/andvary/)",
    "contentTypeId": "107",
    "rating": {
      "id": "718",
      "count": 19,
      "average": 4.474,
      "userRating": null
    }
  },
  "status": null,
  "sampleTestCase": "[2,1,3]",
  "metaData": "{\n  \"name\": \"CodecDriver\",\n  \"params\": [\n    {\n      \"name\": \"root\",\n      \"type\": \"TreeNode\"\n    }\n  ],\n  \"return\": {\n    \"type\": \"TreeNode\"\n  },\n  \"languages\": [\n    \"cpp\",\n    \"java\",\n    \"python\",\n    \"c\",\n    \"csharp\",\n    \"javascript\",\n    \"ruby\",\n    \"php\",\n    \"python3\"\n  ],\n  \"manual\": true\n}",
  "judgerAvailable": true,
  "judgeType": "large",
  "mysqlSchemas": [],
  "enableRunCode": true,
  "enableTestMode": false,
  "libraryUrl": null
}
