{
  "questionId": "44",
  "questionFrontendId": "44",
  "boundTopicId": null,
  "title": "Wildcard Matching",
  "titleSlug": "wildcard-matching",
  "categoryTitle": "Algorithms",
  "content": "<p>Given an input string (<code>s</code>) and a pattern (<code>p</code>), implement wildcard pattern matching with support for <code>&#39;?&#39;</code> and <code>&#39;*&#39;</code>.</p>\r\n\r\n<pre>\r\n&#39;?&#39; Matches any single character.\r\n&#39;*&#39; Matches any sequence of characters (including the empty sequence).\r\n</pre>\r\n\r\n<p>The matching should cover the <strong>entire</strong> input string (not partial).</p>\r\n\r\n<p><strong>Note:</strong></p>\r\n\r\n<ul>\r\n\t<li><code>s</code>&nbsp;could be empty and contains only lowercase letters <code>a-z</code>.</li>\r\n\t<li><code>p</code> could be empty and contains only lowercase letters <code>a-z</code>, and characters like <code><font face=\"monospace\">?</font></code>&nbsp;or&nbsp;<code>*</code>.</li>\r\n</ul>\r\n\r\n<p><strong>Example 1:</strong></p>\r\n\r\n<pre>\r\n<strong>Input:</strong>\r\ns = &quot;aa&quot;\r\np = &quot;a&quot;\r\n<strong>Output:</strong> false\r\n<strong>Explanation:</strong> &quot;a&quot; does not match the entire string &quot;aa&quot;.\r\n</pre>\r\n\r\n<p><strong>Example 2:</strong></p>\r\n\r\n<pre>\r\n<strong>Input:</strong>\r\ns = &quot;aa&quot;\r\np = &quot;*&quot;\r\n<strong>Output:</strong> true\r\n<strong>Explanation:</strong>&nbsp;&#39;*&#39; matches any sequence.\r\n</pre>\r\n\r\n<p><strong>Example 3:</strong></p>\r\n\r\n<pre>\r\n<strong>Input:</strong>\r\ns = &quot;cb&quot;\r\np = &quot;?a&quot;\r\n<strong>Output:</strong> false\r\n<strong>Explanation:</strong>&nbsp;&#39;?&#39; matches &#39;c&#39;, but the second letter is &#39;a&#39;, which does not match &#39;b&#39;.\r\n</pre>\r\n\r\n<p><strong>Example 4:</strong></p>\r\n\r\n<pre>\r\n<strong>Input:</strong>\r\ns = &quot;adceb&quot;\r\np = &quot;*a*b&quot;\r\n<strong>Output:</strong> true\r\n<strong>Explanation:</strong>&nbsp;The first &#39;*&#39; matches the empty sequence, while the second &#39;*&#39; matches the substring &quot;dce&quot;.\r\n</pre>\r\n\r\n<p><strong>Example 5:</strong></p>\r\n\r\n<pre>\r\n<strong>Input:</strong>\r\ns = &quot;acdcb&quot;\r\np = &quot;a*c?b&quot;\r\n<strong>Output:</strong> false\r\n</pre>\r\n",
  "isPaidOnly": false,
  "difficulty": "Hard",
  "likes": 1471,
  "dislikes": 84,
  "isLiked": null,
  "similarQuestions": "[{\"title\": \"Regular Expression Matching\", \"titleSlug\": \"regular-expression-matching\", \"difficulty\": \"Hard\", \"translatedTitle\": null}]",
  "contributors": [],
  "topicTags": [
    {
      "name": "String",
      "slug": "string"
    },
    {
      "name": "Dynamic Programming",
      "slug": "dynamic-programming"
    },
    {
      "name": "Backtracking",
      "slug": "backtracking"
    },
    {
      "name": "Greedy",
      "slug": "greedy"
    }
  ],
  "companyTagStats": "{\"2\": [{\"taggedByAdmin\": true, \"name\": \"Facebook\", \"slug\": \"facebook\", \"timesEncountered\": 5}, {\"taggedByAdmin\": true, \"name\": \"Two Sigma\", \"slug\": \"two-sigma\", \"timesEncountered\": 3}, {\"taggedByAdmin\": false, \"name\": \"Adobe\", \"slug\": \"adobe\", \"timesEncountered\": 2}], \"1\": [{\"taggedByAdmin\": false, \"name\": \"Microsoft\", \"slug\": \"microsoft\", \"timesEncountered\": 6}, {\"taggedByAdmin\": true, \"name\": \"Google\", \"slug\": \"google\", \"timesEncountered\": 4}, {\"taggedByAdmin\": false, \"name\": \"Amazon\", \"slug\": \"amazon\", \"timesEncountered\": 3}, {\"taggedByAdmin\": false, \"name\": \"Goldman Sachs\", \"slug\": \"goldman-sachs\", \"timesEncountered\": 3}, {\"taggedByAdmin\": false, \"name\": \"Bloomberg\", \"slug\": \"bloomberg\", \"timesEncountered\": 2}], \"3\": [{\"taggedByAdmin\": false, \"name\": \"Cruise Automation\", \"slug\": \"cruise-automation\", \"timesEncountered\": 2}, {\"taggedByAdmin\": true, \"name\": \"Twitter\", \"slug\": \"twitter\", \"timesEncountered\": 0}, {\"taggedByAdmin\": true, \"name\": \"Snapchat\", \"slug\": \"snapchat\", \"timesEncountered\": 0}]}",
  "codeSnippets": [
    {
      "lang": "C++",
      "code": "class Solution {\r\npublic:\r\n    bool isMatch(string s, string p) {\r\n        \r\n    }\r\n};"
    },
    {
      "lang": "Java",
      "code": "class Solution {\n    public boolean isMatch(String s, String p) {\n        \n    }\n}"
    },
    {
      "lang": "Python",
      "code": "class Solution(object):\n    def isMatch(self, s, p):\n        \"\"\"\n        :type s: str\n        :type p: str\n        :rtype: bool\n        \"\"\"\n        "
    },
    {
      "lang": "Python3",
      "code": "class Solution:\n    def isMatch(self, s: str, p: str) -> bool:\n        "
    },
    {
      "lang": "C",
      "code": "\n\nbool isMatch(char * s, char * p){\n\n}\n\n"
    },
    {
      "lang": "C#",
      "code": "public class Solution {\r\n    public bool IsMatch(string s, string p) {\r\n        \r\n    }\r\n}"
    },
    {
      "lang": "JavaScript",
      "code": "/**\n * @param {string} s\n * @param {string} p\n * @return {boolean}\n */\nvar isMatch = function(s, p) {\n    \n};"
    },
    {
      "lang": "Ruby",
      "code": "# @param {String} s\r\n# @param {String} p\r\n# @return {Boolean}\r\ndef is_match(s, p)\r\n    \r\nend"
    },
    {
      "lang": "Swift",
      "code": "class Solution {\r\n    func isMatch(_ s: String, _ p: String) -> Bool {\r\n        \r\n    }\r\n}"
    },
    {
      "lang": "Go",
      "code": "func isMatch(s string, p string) bool {\r\n    \r\n}"
    },
    {
      "lang": "Scala",
      "code": "object Solution {\r\n    def isMatch(s: String, p: String): Boolean = {\r\n        \r\n    }\r\n}"
    },
    {
      "lang": "Kotlin",
      "code": "class Solution {\r\n    fun isMatch(s: String, p: String): Boolean {\r\n        \r\n    }\r\n}"
    },
    {
      "lang": "Rust",
      "code": "impl Solution {\n    pub fn is_match(s: String, p: String) -> bool {\n        \n    }\n}"
    },
    {
      "lang": "PHP",
      "code": "class Solution {\n\n    /**\n     * @param String $s\n     * @param String $p\n     * @return Boolean\n     */\n    function isMatch($s, $p) {\n        \n    }\n}"
    }
  ],
  "stats": "{\"totalAccepted\": \"210.3K\", \"totalSubmission\": \"884.7K\", \"totalAcceptedRaw\": 210284, \"totalSubmissionRaw\": 884709, \"acRate\": \"23.8%\"}",
  "hints": [],
  "solution": {
    "id": "730",
    "canSeeDetail": true,
    "url": "/articles/wildcard-matching/",
    "content": "[TOC]\n\n## Solution\n\n--- \n\n#### Approach 1: Recursion with memorisation\n\n**Intuition**\n\nThe first idea here is a recursion. That's a straightforward\napproach but quite time consuming because of huge recursion depth for long input strings.\n\n- If the strings are equal `p == s`, return `True`.\n\n- If the pattern matches whatever string `p == '*'`, return `True`.\n\n- If `p` is empty, or `s` is empty, return False.\n\n- If the current characters match `p[0] == s[0]` or `p[0] == '?'`, \nthen compare the next ones and return `isMatch(s[1:], p[1:])`.\n\n- If the current pattern character is a star `p[0] == '*'`, then\nthere are two possible situations:\n\n    - The star matches no characters, and hence the answer is\n    `isMatch(s, p[1:])`.\n    \n    - The star matches one or more characters, and so the answer is\n    `isMatch(s[1:], p)`.\n    \n- If `p[0] != s[0]`, return `False`.\n\n![bla](../Figures/44/stupid.png)\n\nThe problem of this algorithm is that it doesn't pass \nall test cases because of time limit issue, \nand hence has to be optimised.\nHere is what could be done:\n\n1. _Memorisation_. That is a standard way to optimise the recursion. \nLet's have a memorisation hashmap using pair `(s, p)` as a key and\nmatch/doesn't match as a boolean value. \nOne could keep all already checked pairs `(s, p)` in this hashmap, so that\nif there are any duplicate checks, the answer is right here, \nand there is no need to proceed to the computations again.\n\n2. _Clean up of the input data_. Whether the patterns with multiple stars \nin a row `a****bc**cc` are valid wildcards or not, they could be \nsimplified without any data loss `a*bc*cc`. Such a cleanup helps to decrease\nthe recursion depth. \n\n**Algorithm**\n\nHere is the algorithm.\n\n- Clean up the input by replacing more than one star in a row by a single star: \n`p = remove_duplicate_stars(p)`.\n\n- Initiate the memorisation hashmap `dp`.\n\n- Return the helper function with a cleaned input: `helper(s, p)`.\n\n- `helper(s, p)`:\n\n    - If (s, p) is already known and stored in dp, return the value.\n\n    - If the strings are equal `p == s`, or the pattern matches whatever string `p == '*'`,\n    add `dp[(s, p)] = True`.\n    \n    - Else if `p` is empty, or `s` is empty, add `dp[(s, p)] = False`.\n    \n    - Else if the current characters match `p[0] == s[0]` or `p[0] == '?'`, \n    then compare the next ones and add `dp[(s, p)] = helper(s[1:], p[1:])`.\n    \n    - Else if the current pattern character is a star `p[0] == '*'`, then\n    there are two possible situations: the star matches no characters,\n    and the star matches one or more characters. \n    `dp[(s, p)] = helper(s, p[1:]) or helper(s, p[1:])`.\n        \n    - Else `p[0] != s[0]`, add `dp[(s, p)] = False`.\n    \n    - Now that the value is computed, return it `dp[(s, p)]`.\n\n**Implementation**   \n\n<iframe src=\"https://leetcode.com/playground/rQXhux3f/shared\" frameBorder=\"0\" width=\"100%\" height=\"500\" name=\"rQXhux3f\"></iframe>\n\n**Complexity Analysis**\n\n* Time complexity: $$\\mathcal{O}(\\min(S, P))$$ for the best case, \nand $$\\mathcal{O}(2^{\\min(S, P/2)})$$ for the worst case, where S and P are lengths of \nthe input string and the pattern correspondingly. The best case is quite obvious, \nlet's estimate the worst case. The most time consuming is the situation where \nrecursion forms the tree on the star character in the pattern. \nIn this situation 2 branches are executed : `helper(s, p[1:])` and `helper(s[1:], p)`. \nThe maximum number of stars in the pattern after data cleanup is $$P/2$$ and hence\nthe time complexity is $$\\mathcal{O}(2^{\\min(S, P/2)})$$.\n* Space complexity: $$\\mathcal{O}(2^{\\min(S, P/2)})$$ to keep the memorisation hashmap and\nthe recursion stack.\n<br />\n<br />\n\n\n---\n#### Approach 2: Dynamic Programming \n\n**Intuition**\n\nRecursion approach above shows how painful the large recursion depth could be,\nso let's try something more iterative. \n\nMemorisation from the first approach gives an idea to try a dynamic programming.\nThe problem is very similar with [Edit Distance problem](https://leetcode.com/problems/edit-distance/solution/),\nso let's use exactly the same approach here.\n\nThe idea would be to reduce the problem to simple ones. \nFor example, there is a string `adcebdk` and pattern `*a*b?k`,\nand we want to compute if there is a match for them: `D = True/False`. \nOne could notice that it seems to be more simple for short strings and patterns \nand so it would be logical to relate a match `D[p_len][s_len]` with the lengths `p_len` \nand `s_len` of input pattern and string correspondingly.\n\nLet's go further and introduce a match `D[p_idx][s_idx]` \nwhich is a match between the first `p_idx` characters of the pattern \nand the first `s_idx` characters of the string.\n\n![bla](../Figures/44/dp_match2.png)\n\nIt turns out that one could compute `D[p_idx][s_idx]`, knowing \na match without the last characters `D[p_idx - 1][s_idx - 1]`.\n\n> If the last characters are the same or pattern character is '?', then \n\n$$\nD[p_{idx}][s_{idx}] = D[p_{idx} - 1][s_{idx} - 1] \\qquad (1)\n$$\n\n![bla](../Figures/44/word_match3.png)\n\n> If the pattern character is '*' and there was a match on the previous step\n`D[p_idx - 1][s_idx - 1] = True`, then \n\n- The star at the end of pattern still results in a match. \n\n- The star could much as many characters as you wish.\n\n$$\nD[p_{idx} - 1][i] = \\textrm{True}, i \\ge s_{idx} - 1 \\qquad(2)\n$$\n\nSo each step of the computation would be done based on the previous ones,\nas follows: \n\n![bla](../Figures/44/if_match.png)\n\n![bla](../Figures/44/dpstar.png)\n\n**Algorithm**\n\n- Start from the table initiated as `False` everywhere but `D[0][0] = True`.\n\n- Apply rules (1) and (2) in a loop and return `D[p_len][s_len]` as an answer.\n\n![bla](../Figures/44/fixed.png)\n\n**Implementation**\n\n<iframe src=\"https://leetcode.com/playground/fz7UfsPP/shared\" frameBorder=\"0\" width=\"100%\" height=\"500\" name=\"fz7UfsPP\"></iframe>\n\n**Complexity Analysis**\n\n* Time complexity : $$\\mathcal{O}(S P)$$ where S and P are lengths of \nthe input string and the pattern correspondingly. \n* Space complexity : $$\\mathcal{O}(S P)$$ to keep the matrix.\n<br />\n<br />\n\n\n---\n#### Approach 3: Backtracking\n\n**Intuition**\n\nComplexity $$\\mathcal{O}(S P)$$ is much better than $$\\mathcal{O}(2^{\\min(S, P/2)})$$,\nbut still could be improved. There is no need to compute the entire matrix,\nand i.e. to check all the possibilities for each star :\n\n- Star matches zero characters.\n- Star matches one character.\n- Star matches two characters. \n\n...\n\n- Star matches all remaining characters.  \n\nLet's just pick up the first opportunity \"matches zero characters\" and proceed further.\nIf this assumption would lead in \"no match\" situation, then _backtrack_ : come back\nto the previous star, assume now that it matches one more character (one) and \nproceed again. Again \"no match\" situation? \n_Backtrack again_ : come back to the previous star, \nand assume now that it matches one more character (two), etc. \n\n![bla](../Figures/44/backtrack.png)\n\n**Algorithm**\n\nHere is the algorithm.\n\n- Let's use two pointers here: `s_idx` to iterate over the string, and `p_idx` to \niterate over the pattern. While `s_idx < s_len`:\n\n    - If there are still characters in the pattern `p_idx < p_len` and\n    the characters under the pointers match \n    `p[p_idx] == s[s_idx]` or `p[p_idx] == '?'`,\n    then move forward by increasing both pointers.\n    \n    - Else if there are still characters in the pattern `p_idx < p_len`, and\n    `p[p_idx] == '*'`, then first check \"match zero characters\" situation, i.e.\n    increase only pattern pointer `p_idx++`.\n    Write down for a possible backtrack the star position in `star_idx` variable,\n    and the current string pointer in `s_tmp_idx` variable.\n    \n    - Else if there is \"no match\" situation: \n    the pattern is used up `p_idx < p_len`\n    or the characters under the pointers doesn't match. \n    \n        - If there was no stars in the pattern, i.e. no `star_idx`, return `False`.\n        \n        - If there was a star, then backtrack: set pattern pointer\n        just after the last star `p_idx = star_idx + 1`, and string \n        pointer `s_idx = s_tmp_idx + 1`, i.e. assume that this time the star\n        matches _one more character_. Save the current string pointer \n        for the possible backtrack `s_tmp_idx = s_idx`.\n        \n- Return `True` if all remaining characters in the pattern are stars. \n\n**Implementation**\n\n<iframe src=\"https://leetcode.com/playground/Xr2tmU7S/shared\" frameBorder=\"0\" width=\"100%\" height=\"500\" name=\"Xr2tmU7S\"></iframe>\n\n**Complexity Analysis**\n\n* Time complexity : $$\\mathcal{O}(\\min(S, P))$$ for the best case and\nbetter than $$\\mathcal{O}(S \\log P)$$ for the average case, where S and P are lengths of \nthe input string and the pattern correspondingly. \nPlease refer to [this article](https://arxiv.org/pdf/1407.0950.pdf) for the detailed proof. \n* Space complexity : $$\\mathcal{O}(1)$$ since it's a constant space solution.\n<br />\n<br />\n\n\n---\n#### Further reading\n\nThere are a lot of search-related questions around this problem \nwhich could pop up during the interview.\nTo prepare, you could read about [string searching algorithm](https://en.wikipedia.org/wiki/String-searching_algorithm)\nand [KMP algorithm](https://en.wikipedia.org/wiki/Knuth%E2%80%93Morris%E2%80%93Pratt_algorithm).\n\nAnalysis written by @[liaison](https://leetcode.com/liaison/)\nand @[andvary](https://leetcode.com/andvary/)",
    "contentTypeId": "107",
    "rating": {
      "id": "715",
      "count": 18,
      "average": 4.611,
      "userRating": null
    }
  },
  "status": null,
  "sampleTestCase": "\"aa\"\n\"a\"",
  "metaData": "{ \r\n  \"name\": \"isMatch\",\r\n  \"params\": [\r\n    { \r\n      \"name\": \"s\",\r\n      \"type\": \"string\"\r\n    },\r\n    { \r\n      \"name\": \"p\",\r\n      \"type\": \"string\"\r\n    }\r\n  ],\r\n  \"return\": {\r\n    \"type\": \"boolean\"\r\n  }\r\n}",
  "judgerAvailable": true,
  "judgeType": "large",
  "mysqlSchemas": [],
  "enableRunCode": true,
  "enableTestMode": false,
  "libraryUrl": null
}
