{
  "questionId": "450",
  "questionFrontendId": "450",
  "boundTopicId": null,
  "title": "Delete Node in a BST",
  "titleSlug": "delete-node-in-a-bst",
  "categoryTitle": "Algorithms",
  "content": "<p>Given a root node reference of a BST and a key, delete the node with the given key in the BST. Return the root node reference (possibly updated) of the BST.</p>\r\n\r\n<p>Basically, the deletion can be divided into two stages:\r\n<ol>\r\n<li>Search for a node to remove.</li>\r\n<li>If the node is found, delete the node.</li>\r\n</ol>\r\n</p>\r\n\r\n<p><b>Note:</b> Time complexity should be O(height of tree).</p>\r\n\r\n<p><b>Example:</b>\r\n<pre>\r\nroot = [5,3,6,2,4,null,7]\r\nkey = 3\r\n\r\n    5\r\n   / \\\r\n  3   6\r\n / \\   \\\r\n2   4   7\r\n\r\nGiven key to delete is 3. So we find the node with value 3 and delete it.\r\n\r\nOne valid answer is [5,4,6,2,null,null,7], shown in the following BST.\r\n\r\n    5\r\n   / \\\r\n  4   6\r\n /     \\\r\n2       7\r\n\r\nAnother valid answer is [5,2,6,null,4,null,7].\r\n\r\n    5\r\n   / \\\r\n  2   6\r\n   \\   \\\r\n    4   7\r\n</pre>\r\n</p>",
  "isPaidOnly": false,
  "difficulty": "Medium",
  "likes": 1253,
  "dislikes": 69,
  "isLiked": null,
  "similarQuestions": "[{\"title\": \"Split BST\", \"titleSlug\": \"split-bst\", \"difficulty\": \"Medium\", \"translatedTitle\": null}]",
  "contributors": [
    {
      "username": "tsipporah5945",
      "profileUrl": "/tsipporah5945/",
      "avatarUrl": "https://www.gravatar.com/avatar/1dbf45d681db6debea259cf98679fc26.png?s=200"
    }
  ],
  "topicTags": [
    {
      "name": "Tree",
      "slug": "tree"
    }
  ],
  "companyTagStats": "{\"2\": [{\"taggedByAdmin\": false, \"name\": \"Amazon\", \"slug\": \"amazon\", \"timesEncountered\": 3}, {\"taggedByAdmin\": false, \"name\": \"Google\", \"slug\": \"google\", \"timesEncountered\": 2}, {\"taggedByAdmin\": false, \"name\": \"Facebook\", \"slug\": \"facebook\", \"timesEncountered\": 2}], \"3\": [{\"taggedByAdmin\": false, \"name\": \"LinkedIn\", \"slug\": \"linkedin\", \"timesEncountered\": 4}, {\"taggedByAdmin\": false, \"name\": \"Yahoo\", \"slug\": \"yahoo\", \"timesEncountered\": 3}, {\"taggedByAdmin\": false, \"name\": \"Apple\", \"slug\": \"apple\", \"timesEncountered\": 2}, {\"taggedByAdmin\": true, \"name\": \"Uber\", \"slug\": \"uber\", \"timesEncountered\": 0}], \"1\": [{\"taggedByAdmin\": false, \"name\": \"Microsoft\", \"slug\": \"microsoft\", \"timesEncountered\": 3}, {\"taggedByAdmin\": false, \"name\": \"Oracle\", \"slug\": \"oracle\", \"timesEncountered\": 2}]}",
  "codeSnippets": [
    {
      "lang": "C++",
      "code": "/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\n * };\n */\nclass Solution {\npublic:\n    TreeNode* deleteNode(TreeNode* root, int key) {\n        \n    }\n};"
    },
    {
      "lang": "Java",
      "code": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode(int x) { val = x; }\n * }\n */\nclass Solution {\n    public TreeNode deleteNode(TreeNode root, int key) {\n        \n    }\n}"
    },
    {
      "lang": "Python",
      "code": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, x):\n#         self.val = x\n#         self.left = None\n#         self.right = None\n\nclass Solution(object):\n    def deleteNode(self, root, key):\n        \"\"\"\n        :type root: TreeNode\n        :type key: int\n        :rtype: TreeNode\n        \"\"\"\n        "
    },
    {
      "lang": "Python3",
      "code": "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, x):\n#         self.val = x\n#         self.left = None\n#         self.right = None\n\nclass Solution:\n    def deleteNode(self, root: TreeNode, key: int) -> TreeNode:\n        "
    },
    {
      "lang": "C",
      "code": "/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     struct TreeNode *left;\n *     struct TreeNode *right;\n * };\n */\n\n\nstruct TreeNode* deleteNode(struct TreeNode* root, int key){\n\n}\n\n"
    },
    {
      "lang": "C#",
      "code": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     public int val;\n *     public TreeNode left;\n *     public TreeNode right;\n *     public TreeNode(int x) { val = x; }\n * }\n */\npublic class Solution {\n    public TreeNode DeleteNode(TreeNode root, int key) {\n        \n    }\n}"
    },
    {
      "lang": "JavaScript",
      "code": "/**\n * Definition for a binary tree node.\n * function TreeNode(val) {\n *     this.val = val;\n *     this.left = this.right = null;\n * }\n */\n/**\n * @param {TreeNode} root\n * @param {number} key\n * @return {TreeNode}\n */\nvar deleteNode = function(root, key) {\n    \n};"
    },
    {
      "lang": "Ruby",
      "code": "# Definition for a binary tree node.\n# class TreeNode\n#     attr_accessor :val, :left, :right\n#     def initialize(val)\n#         @val = val\n#         @left, @right = nil, nil\n#     end\n# end\n\n# @param {TreeNode} root\n# @param {Integer} key\n# @return {TreeNode}\ndef delete_node(root, key)\n    \nend"
    },
    {
      "lang": "Swift",
      "code": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     public var val: Int\n *     public var left: TreeNode?\n *     public var right: TreeNode?\n *     public init(_ val: Int) {\n *         self.val = val\n *         self.left = nil\n *         self.right = nil\n *     }\n * }\n */\nclass Solution {\n    func deleteNode(_ root: TreeNode?, _ key: Int) -> TreeNode? {\n        \n    }\n}"
    },
    {
      "lang": "Go",
      "code": "/**\n * Definition for a binary tree node.\n * type TreeNode struct {\n *     Val int\n *     Left *TreeNode\n *     Right *TreeNode\n * }\n */\nfunc deleteNode(root *TreeNode, key int) *TreeNode {\n    \n}"
    },
    {
      "lang": "Scala",
      "code": "/**\n * Definition for a binary tree node.\n * class TreeNode(var _value: Int) {\n *   var value: Int = _value\n *   var left: TreeNode = null\n *   var right: TreeNode = null\n * }\n */\nobject Solution {\n    def deleteNode(root: TreeNode, key: Int): TreeNode = {\n        \n    }\n}"
    },
    {
      "lang": "Kotlin",
      "code": "/**\n * Example:\n * var ti = TreeNode(5)\n * var v = ti.`val`\n * Definition for a binary tree node.\n * class TreeNode(var `val`: Int) {\n *     var left: TreeNode? = null\n *     var right: TreeNode? = null\n * }\n */\nclass Solution {\n    fun deleteNode(root: TreeNode?, key: Int): TreeNode? {\n        \n    }\n}"
    },
    {
      "lang": "Rust",
      "code": "// Definition for a binary tree node.\n// #[derive(Debug, PartialEq, Eq)]\n// pub struct TreeNode {\n//   pub val: i32,\n//   pub left: Option<Rc<RefCell<TreeNode>>>,\n//   pub right: Option<Rc<RefCell<TreeNode>>>,\n// }\n// \n// impl TreeNode {\n//   #[inline]\n//   pub fn new(val: i32) -> Self {\n//     TreeNode {\n//       val,\n//       left: None,\n//       right: None\n//     }\n//   }\n// }\nuse std::rc::Rc;\nuse std::cell::RefCell;\nimpl Solution {\n    pub fn delete_node(root: Option<Rc<RefCell<TreeNode>>>, key: i32) -> Option<Rc<RefCell<TreeNode>>> {\n        \n    }\n}"
    },
    {
      "lang": "PHP",
      "code": "/**\n * Definition for a binary tree node.\n * class TreeNode {\n *     public $val = null;\n *     public $left = null;\n *     public $right = null;\n *     function __construct($value) { $this->val = $value; }\n * }\n */\nclass Solution {\n\n    /**\n     * @param TreeNode $root\n     * @param Integer $key\n     * @return TreeNode\n     */\n    function deleteNode($root, $key) {\n        \n    }\n}"
    }
  ],
  "stats": "{\"totalAccepted\": \"85.5K\", \"totalSubmission\": \"207.3K\", \"totalAcceptedRaw\": 85485, \"totalSubmissionRaw\": 207279, \"acRate\": \"41.2%\"}",
  "hints": [],
  "solution": {
    "id": "722",
    "canSeeDetail": true,
    "url": "/articles/delete-node-in-a-bst/",
    "content": "[TOC]\n\n## Solution\n\n--- \n\n#### Three facts to know about BST\n\nHere is list of facts which are better to know before the interview.\n\n> Inorder traversal of BST is an array sorted in the ascending order.\n\nTo compute inorder traversal follow the direction `Left -> Node -> Right`.\n\n<iframe src=\"https://leetcode.com/playground/95JYyMAJ/shared\" frameBorder=\"0\" width=\"100%\" height=\"174\" name=\"95JYyMAJ\"></iframe>\n\n![traversal](../Figures/450/450_inorder.png)\n\n> Successor = \"after node\", i.e. the next node, or the smallest node _after_ the current one.  \n\nIt's also the _next_ node in the inorder traversal. To find a successor, go to the right once\nand then as many times to the left as you could.\n\n<iframe src=\"https://leetcode.com/playground/VjP2NYQZ/shared\" frameBorder=\"0\" width=\"100%\" height=\"140\" name=\"VjP2NYQZ\"></iframe>\n\n> Predecessor = \"before node\", i.e. the previous node, or the largest node _before_ the current one.  \n\nIt's also the _previous_ node in the inorder traversal. To find a predecessor, go to the left once\nand then as many times to the right as you could.\n\n<iframe src=\"https://leetcode.com/playground/bqxv9K6u/shared\" frameBorder=\"0\" width=\"100%\" height=\"140\" name=\"bqxv9K6u\"></iframe>\n\n![bla](../Figures/450/succ2.png)\n\n<br />\n<br />\n\n\n---\n#### Approach 1: Recursion\n\n**Intuition**\n\nThere are three possible situations here :\n\n- Node is a leaf, and one could delete it straightforward : `node = null`.\n\n![bla](../Figures/450/del_leaf.png)\n\n- Node is not a leaf and has a right child. Then the node could be replaced by its\n_successor_ which is somewhere lower in the right subtree. Then one could proceed down recursively to\ndelete the successor.\n\n![bla](../Figures/450/del_succ.png)\n\n- Node is not a leaf, has no right child and has a left child. That means that its _successor_ is somewhere\n upper in the tree but we don't want to go back.\n Let's use the _predecessor_ here which is somewhere lower in the left subtree.\n The node could be replaced by its\n_predecessor_ and then one could proceed down recursively to delete the predecessor.\n\n![bla](../Figures/450/del_pred.png)\n\n**Algorithm**\n\n- If `key > root.val` then delete the node to delete is in the right subtree\n`root.right = deleteNode(root.right, key)`.\n\n- If `key < root.val` then delete the node to delete is in the left subtree\n`root.left = deleteNode(root.left, key)`.  \n\n- If `key == root.val` then the node to delete is right here. Let's do it :\n\n    - If the node is a leaf, the delete process is straightforward :\n    `root = null`.\n    \n    - If the node is not a leaf and has the right child, then replace the node \n    value by a successor value `root.val = successor.val`, \n    and then recursively delete\n    the successor in the right subtree `root.right = deleteNode(root.right, root.val)`.\n    \n    - If the node is not a leaf and has only the left child, then replace the node \n    value by a predecessor value `root.val = predecessor.val`, and then recursively delete\n    the predecessor in the left subtree `root.left = deleteNode(root.left, root.val)`.\n    \n- Return `root`.\n\n**Implementation**\n\n![bla](../Figures/450/implem2.png)\n\n<iframe src=\"https://leetcode.com/playground/VJcydB3p/shared\" frameBorder=\"0\" width=\"100%\" height=\"500\" name=\"VJcydB3p\"></iframe>\n\n**Complexity Analysis**\n\n* Time complexity : $$\\mathcal{O}(\\log N)$$. During the algorithm \nexecution we go down the tree\nall the time - on the left or on the right, \nfirst to search the node to delete ($$\\mathcal{O}(H_1)$$ time\ncomplexity as already \n[discussed](https://leetcode.com/articles/insert-into-a-bst/)) \nand then to actually delete it. $$H_1$$ is a tree height from the root to the node \nto delete.\nDelete process takes $$\\mathcal{O}(H_2)$$ time, where $$H_2$$ is a tree height\nfrom the root to delete to the leafs.\nThat in total results in $$\\mathcal{O}(H_1 + H_2) = \\mathcal{O}(H)$$ time\ncomplexity, where $$H$$ is a tree height, equal to $$\\log N$$ in the case of the balanced tree.    \n    \n* Space complexity : $$\\mathcal{O}(H)$$ to keep the recursion stack, where $$H$$ is a tree\nheight. $$H = \\log N$$ for the balanced tree.\n\nAnalysis written by @[liaison](https://leetcode.com/liaison/)\nand @[andvary](https://leetcode.com/andvary/)",
    "contentTypeId": "107",
    "rating": {
      "id": "707",
      "count": 59,
      "average": 5,
      "userRating": null
    }
  },
  "status": null,
  "sampleTestCase": "[5,3,6,2,4,null,7]\n3",
  "metaData": "{\r\n  \"name\": \"deleteNode\",\r\n  \"params\": [\r\n    {\r\n      \"name\": \"root\",\r\n      \"type\": \"TreeNode\",\r\n      \"dealloc\": false\r\n    },\r\n    {\r\n      \"name\": \"key\",\r\n      \"type\": \"integer\"\r\n    }\r\n  ],\r\n  \"return\": {\r\n    \"type\": \"TreeNode\"\r\n  }\r\n}",
  "judgerAvailable": true,
  "judgeType": "large",
  "mysqlSchemas": [],
  "enableRunCode": true,
  "enableTestMode": false,
  "libraryUrl": null
}
