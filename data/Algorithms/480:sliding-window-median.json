{
  "questionId": "480",
  "questionFrontendId": "480",
  "boundTopicId": null,
  "title": "Sliding Window Median",
  "titleSlug": "sliding-window-median",
  "categoryTitle": "Algorithms",
  "content": "<p>Median is the middle value in an ordered integer list. If the size of the list is even, there is no middle value. So the median is the mean of the two middle value.</p>\r\nExamples: <br />\r\n<p><code>[2,3,4]</code> , the median is <code>3</code></p>\r\n<p><code>[2,3]</code>, the median is <code>(2 + 3) / 2 = 2.5</code> </p>\r\n\r\n<p>Given an array <i>nums</i>, there is a sliding window of size <i>k</i> which is moving from the very left of the array to the very right. You can only see the <i>k</i> numbers in the window. Each time the sliding window moves right by one position. Your job is to output the median array for each window in the original array.</p>\r\n\r\n<p>For example,<br>\r\nGiven <i>nums</i> = <code>[1,3,-1,-3,5,3,6,7]</code>, and <i>k</i> = 3.</p>\r\n\r\n<pre>\r\nWindow position                Median\r\n---------------               -----\r\n[1  3  -1] -3  5  3  6  7       1\r\n 1 [3  -1  -3] 5  3  6  7       -1\r\n 1  3 [-1  -3  5] 3  6  7       -1\r\n 1  3  -1 [-3  5  3] 6  7       3\r\n 1  3  -1  -3 [5  3  6] 7       5\r\n 1  3  -1  -3  5 [3  6  7]      6\r\n</pre>\r\n\r\n<p>Therefore, return the median sliding window as <code>[1,-1,-1,3,5,6]</code>.</p>\r\n\r\n<p><b>Note: </b><br>\r\nYou may assume <code>k</code> is always valid, ie: <code>k</code> is always smaller than input array's size for non-empty array.</p>",
  "isPaidOnly": false,
  "difficulty": "Hard",
  "likes": 583,
  "dislikes": 60,
  "isLiked": null,
  "similarQuestions": "[{\"title\": \"Find Median from Data Stream\", \"titleSlug\": \"find-median-from-data-stream\", \"difficulty\": \"Hard\", \"translatedTitle\": null}]",
  "contributors": [
    {
      "username": "YutingLiu",
      "profileUrl": "/yutingliu/",
      "avatarUrl": "https://www.gravatar.com/avatar/9b3ac648a18bf38ff56b9770f1703473.png?s=200"
    }
  ],
  "topicTags": [
    {
      "name": "Sliding Window",
      "slug": "sliding-window"
    }
  ],
  "companyTagStats": "{\"2\": [{\"taggedByAdmin\": true, \"name\": \"Google\", \"slug\": \"google\", \"timesEncountered\": 4}, {\"taggedByAdmin\": false, \"name\": \"Amazon\", \"slug\": \"amazon\", \"timesEncountered\": 2}, {\"taggedByAdmin\": false, \"name\": \"Snapchat\", \"slug\": \"snapchat\", \"timesEncountered\": 2}], \"3\": [{\"taggedByAdmin\": false, \"name\": \"Oracle\", \"slug\": \"oracle\", \"timesEncountered\": 2}], \"1\": [{\"taggedByAdmin\": false, \"name\": \"Facebook\", \"slug\": \"facebook\", \"timesEncountered\": 4}]}",
  "codeSnippets": [
    {
      "lang": "C++",
      "code": "class Solution {\npublic:\n    vector<double> medianSlidingWindow(vector<int>& nums, int k) {\n        \n    }\n};"
    },
    {
      "lang": "Java",
      "code": "class Solution {\n    public double[] medianSlidingWindow(int[] nums, int k) {\n        \n    }\n}"
    },
    {
      "lang": "Python",
      "code": "class Solution(object):\n    def medianSlidingWindow(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: List[float]\n        \"\"\"\n        "
    },
    {
      "lang": "Python3",
      "code": "class Solution:\n    def medianSlidingWindow(self, nums: List[int], k: int) -> List[float]:\n        "
    },
    {
      "lang": "C",
      "code": "\n\n/**\n * Note: The returned array must be malloced, assume caller calls free().\n */\ndouble* medianSlidingWindow(int* nums, int numsSize, int k, int* returnSize){\n\n}\n\n"
    },
    {
      "lang": "C#",
      "code": "public class Solution {\n    public double[] MedianSlidingWindow(int[] nums, int k) {\n        \n    }\n}"
    },
    {
      "lang": "JavaScript",
      "code": "/**\n * @param {number[]} nums\n * @param {number} k\n * @return {number[]}\n */\nvar medianSlidingWindow = function(nums, k) {\n    \n};"
    },
    {
      "lang": "Ruby",
      "code": "# @param {Integer[]} nums\n# @param {Integer} k\n# @return {Float[]}\ndef median_sliding_window(nums, k)\n    \nend"
    },
    {
      "lang": "Swift",
      "code": "class Solution {\n    func medianSlidingWindow(_ nums: [Int], _ k: Int) -> [Double] {\n        \n    }\n}"
    },
    {
      "lang": "Go",
      "code": "func medianSlidingWindow(nums []int, k int) []float64 {\n    \n}"
    },
    {
      "lang": "Scala",
      "code": "object Solution {\n    def medianSlidingWindow(nums: Array[Int], k: Int): Array[Double] = {\n        \n    }\n}"
    },
    {
      "lang": "Kotlin",
      "code": "class Solution {\n    fun medianSlidingWindow(nums: IntArray, k: Int): DoubleArray {\n        \n    }\n}"
    },
    {
      "lang": "Rust",
      "code": "impl Solution {\n    pub fn median_sliding_window(nums: Vec<i32>, k: i32) -> Vec<f64> {\n        \n    }\n}"
    },
    {
      "lang": "PHP",
      "code": "class Solution {\n\n    /**\n     * @param Integer[] $nums\n     * @param Integer $k\n     * @return Float[]\n     */\n    function medianSlidingWindow($nums, $k) {\n        \n    }\n}"
    }
  ],
  "stats": "{\"totalAccepted\": \"36.4K\", \"totalSubmission\": \"104.7K\", \"totalAcceptedRaw\": 36400, \"totalSubmissionRaw\": 104726, \"acRate\": \"34.8%\"}",
  "hints": [
    "The simplest of solutions comes from the basic idea of finding the median given a set of numbers. We know that by definition, a median is the center element (or an average of the two center elements). Given an unsorted list of numbers, how do we find the median element? If you know the answer to this question, can we extend this idea to every sliding window that we come across in the array?",
    "Is there a better way to do what we are doing in the above hint? Don't you think there is duplication of calculation being done there? Is there some sort of optimization that we can do to achieve the same result? This approach is merely a modification of the basic approach except that it simply reduces duplication of calculations once done.",
    "The third line of thought is also based on this same idea but achieving the result in a different way. We obviously need the window to be sorted for us to be able to find the median. Is there a data-structure out there that we can use (in one or more quantities) to obtain the median element extremely fast, say O(1) time while having the ability to perform the other operations fairly efficiently as well?"
  ],
  "solution": {
    "id": "86",
    "canSeeDetail": true,
    "url": "/articles/sliding-window-median/",
    "content": "[TOC]\n\n### A word of advice\n\nThis problem is a companion problem to [295. Find Median From Data Stream](https://leetcode.com/problems/find-median-from-data-stream/). This means that a lot of approaches to solve this problem are based on the [methods to solve 295. Find Median From Data Stream](https://leetcode.com/articles/find-median-from-data-stream). Perhaps try that problem before you approach this one.\n\n## Solution\n---\n#### Approach 1: Simple Sorting\n\n**Intuition**\n\nDo what the question says.\n\n**Algorithm**\n\nStore the numbers in a window container of size $$k$$. The following operations must take place:\n\n1. **Inserting** the incoming element.\n2. **Deleting** the outgoing element.\n3. **Sorting** the window to find the medians.\n\nOne primitive approach is to copy $$k$$ consecutive elements from the input to the window and keep sorting these every time. This constitutes duplication of effort.\n\nWe can do a bit better if we instead *insert* and *delete* one element per window shift. The challenge then is to maintain the window as **sorted**, before and after the *insert* and *delete* operations.\n\n<iframe src=\"https://leetcode.com/playground/AgXFqxC2/shared\" frameBorder=\"0\" width=\"100%\" height=\"395\" name=\"AgXFqxC2\"></iframe>\n\nPython comes with an excellent `bisect` module to help perform efficient insert operations on lists while maintaining their sorted property.\n\n**Complexity Analysis**\n\n* Time complexity: $$O(n \\cdot k \\log k)$$ to $$O(n \\cdot k)$$.\n\n    + Copying elements into the container takes about $$O(k)$$ time each. This happens about $$(n-k)$$ times.\n    + Sorting for each of the $$(n-k)$$ sliding window instances takes about $$O(k \\log k)$$ time each.\n\n    + Bisected insertion or deletion takes about $$O(\\log k)$$ for searching and $$O(k)$$ for actual shifting of elements. This takes place about $$n$$ times.\n\n* Space complexity: $$O(k)$$ extra linear space for the window container.\n\n---\n#### Approach 2: Two Heaps (Lazy Removal)\n\n**Intuition**\n\nThe idea is the same as [Approach 3](https://leetcode.com/articles/find-median-from-data-stream/#approach-3-two-heaps) from [295. Find Median From Data Stream](https://leetcode.com/problems/find-median-from-data-stream/). The only additional requirement is removing the outgoing elements from the window.\n\nSince the window elements are stored in heaps, deleting elements that are not at the top of the heaps is a pain.\n\nSome languages (like **Java**) provide implementations of the `PriorityQueue` class that allow for removing *arbitrarily* placed elements. Generally, using such features is not efficient nor is their portability assured.\n\nAssuming that only the tops of heaps (and by extension the `PriorityQueue` class) are accessible, we need to find a way to efficiently invalidate and remove elements that are moving out of the sliding window.\n\nAt this point, an important thing to notice is the fact that if the two heaps are balanced, only the top of the heaps are actually needed to find the medians. This means that as long as we can somehow keep the heaps balanced, we could also keep some extraneous elements.\n\nThus, we can use hash-tables to keep track of invalidated elements. Once they reach the heap tops, we remove them from the heaps. This is the lazy removal technique.\n\nAn immediate challenge at this point is balancing the heaps while keeping extraneous elements. This is done by actually moving some elements to the heap which has extraneous elements, from the other heap. This cancels out the effect of having extraneous elements and maintains the invariant that the heaps are balanced.\n\n**NOTE:** When we talk about keeping the heaps balanced, we are **not** referring to the actual heap sizes. We are only concerned with valid elements and hence when we talk about balancing heaps, we are referring to count of such elements.\n\n**Algorithm**\n\n+ Two priority queues:\n\n    1. A max-heap `lo` to store the smaller half of the numbers\n    2. A min-heap `hi` to store the larger half of the numbers\n\n+ A hash-map or hash-table `hash_table` for keeping track of invalid numbers. It holds the count of the occurrences of all such numbers that have been invalidated and yet remain in the heaps.\n\n+ The max-heap `lo` is allowed to store, at worst, one more element more than the min-heap `hi`. Hence if we have processed $$k$$ elements:\n\n    + If $$k = 2 \\cdot n + 1 \\quad (\\forall \\, n \\in \\mathbb{Z})$$, then `lo` is allowed to hold $$n+1$$ elements, while `hi` can hold $$n$$ elements.\n    + If $$k = 2 \\cdot n \\quad (\\forall \\, n \\in \\mathbb{Z})$$, then both heaps are balanced and hold $$n$$ elements each.\n\n    This gives us the nice property that when the heaps are perfectly balanced, the median can be derived from the tops of both heaps. Otherwise, the top of the max-heap `lo` holds the legitimate median.\n\n**NOTE:** As mentioned before, when we are talking about keeping the heaps balanced, the actual sizes of the heaps are irrelevant. Only the count of valid elements in both heaps matter.\n\n+ Keep a `balance` factor. It indicates three situations:\n\n    + `balance` $$= 0$$: Both heaps are balanced or nearly balanced.\n    + `balance` $$< 0$$: `lo` needs more valid elements. Elements from `hi` are moved to `lo`.\n    + `balance` $$> 0$$: `hi` needs more valid elements. Elements from `lo` are moved to `hi`.\n\n+ Inserting an incoming number `in_num`:\n\n    + If `in_num` is less than or equal to the top element of `lo`, then it can be inserted to `lo`. However this unbalances `hi` (`hi` has lesser valid elements now). Hence `balance` is incremented.\n\n    + Otherwise, `in_num` must be added to `hi`. Obviously, now `lo` is unbalanced. Hence `balance` is decremented.\n\n+ Lazy removal of an outgoing number `out_num`:\n\n    + If `out_num` is present in `lo`, then invalidating this occurrence will unbalance `lo` itself. Hence `balance` must be decremented.\n    + If `out_num` is present in `hi`, then invalidating this occurrence will unbalance `hi` itself. Hence `balance` must be incremented.\n\n    + We increment the count of this element in the hash_table table.\n    + Once an invalid element reaches either of the heap tops, we remove them and decrement their counts in the hash_table table.\n\n<iframe src=\"https://leetcode.com/playground/CSNVtycd/shared\" frameBorder=\"0\" width=\"100%\" height=\"500\" name=\"CSNVtycd\"></iframe>\n\n**Complexity Analysis**\n\n* Time complexity: $$O(2 \\cdot n \\log k) + O(n-k) \\approx O(n \\log k)$$.\n\n    + Either (or sometimes both) of the heaps gets every element inserted into it at least once. Collectively each of those takes about $$O(\\log k)$$ time. That is $$n$$ such insertions.\n    + About $$(n-k)$$ removals from the top of the heaps take place (the number of sliding window instances). Each of those takes about $$O(\\log k)$$ time.\n    + Hash table operations are assumed to take $$O(1)$$ time each. This happens roughly the same number of times as removals from heaps take place.\n\n* Space complexity: $$O(k) + O(n) \\approx O(n)$$ extra linear space.\n\n    + The heaps collectively require $$O(k)$$ space.\n    + The hash table needs about $$O(n-k)$$ space.\n\n---\n#### Approach 3: Two Multisets\n\n**Intuition**\n\nOne can see that `multiset`s are a great way to keep elements sorted while providing efficient access to the first and last elements. Inserting and deleting arbitrary elements are also fairly efficient operations in a `multiset`. (Refer to [Approach 4 Intuition](https://leetcode.com/articles/find-median-from-data-stream/#approach-4-multiset-and-two-pointers) for [295. Find Median From Data Stream](https://leetcode.com/problems/find-median-from-data-stream/))\n\nThus, if the previous approach gives you too much heartburn, consider replacing the use of `priority_queue` with `multiset`.\n\n**Algorithm**\n\nInserting or deleting an element is straight-forward. Balancing the heaps takes the same route as [Approach 3](https://leetcode.com/articles/find-median-from-data-stream/#approach-3-two-heaps) of [295. Find Median From Data Stream](https://leetcode.com/problems/find-median-from-data-stream/).\n\n<iframe src=\"https://leetcode.com/playground/yeSxQhvY/shared\" frameBorder=\"0\" width=\"100%\" height=\"500\" name=\"yeSxQhvY\"></iframe>\n\n**Complexity Analysis**\n\n* Time complexity: $$O((n-k) \\cdot 6 \\cdot \\log k) \\approx O(n \\log k)$$.\n\n    + At worst, there are three set insertions and three set deletions from the start or end. Each of these takes about $$O(\\log k)$$ time.\n    + Finding the mean takes constant $$O(1)$$ time since the start or ends of sets are directly accessible.\n    + Each of these steps takes place about $$(n-k)$$ times (the number of sliding window instances).\n\n* Space complexity: $$O(k)$$ extra linear space to hold contents of the window.\n\n---\n#### Approach 4: Multiset and Two Pointers\n\n**Intuition**\n\nThis is same as [Approach 4](https://leetcode.com/articles/find-median-from-data-stream/#approach-4-multiset-and-two-pointers) for [295. Find Median From Data Stream](https://leetcode.com/problems/find-median-from-data-stream/).\n\n> But, we don't actually need two pointers.\n\nMedian elements are derived using a single iterator position (when the window size $$k$$ is odd) or two consecutive iterator positions (when $$k$$ is even). Hence keeping track of *only* one pointer is sufficient. The other pointer can be *implicitly derived* when required.\n\n**Algorithm**\n\n+ A single iterator `mid`, which iterates over the `window` multiset. It is analogous to `upper_median` in [Approach 4](https://leetcode.com/articles/find-median-from-data-stream/#approach-4-multiset-and-two-pointers) for [295. Find Median From Data Stream](https://leetcode.com/problems/find-median-from-data-stream/). `lower_median` is *implicitly derived* from `mid`. It's either equal to `mid` (when the window size $$k$$ is odd) or `prev(mid)` [^note-1] \\(when the window size $$k$$ is even\\).\n\n+ We start with populating our multiset `window` with the first $$k$$ elements. We set `mid` to the $$\\lfloor k/2 \\rfloor$$ indexed element in `window` (`0`-based indexing; Multisets always maintain their sorted property).\n\n+ While inserting an element `num` into `window`, three cases arise:\n\n    1. `num` is less than the value of upper median `mid`.\n\n    2. `num` is greater than the value of upper median `mid`.\n\n    3. `num` is equal to the value of upper median `mid`. This situation is often handled as language-dependent. Since C++ `multiset` insert elements at the end of their equal range, this situation is essentially the same as the previous case.\n\n    + For the first case, `num` is inserted before the upper median element `mid`. Thus `mid` now, no longer points to the $$\\lfloor k/2 \\rfloor$$ indexed element. In fact it points to the $$\\lfloor k/2 \\rfloor + 1$$ indexed element. We fix that by decrementing `mid`.\n\n    + For the second and third cases, `num` is inserted after the upper median element `mid` and hence does not spoil the `mid` iterator. It still points to the $$\\lfloor k/2 \\rfloor$$ indexed element.\n\n    + Of course, the window size just increased to $$k + 1$$ in all three cases. That will easily be fixed by removing the element that is about to exit the window.\n\n+ While removing an element `num`, the same three cases arise as when we wanted to insert an element:\n\n    1. `num` is less than the value of upper median `mid`.\n\n    2. `num` is greater than the value of upper median `mid`.\n\n    3. `num` is equal to the value of upper median `mid`. Since `mid` will point to the first occurrence of `num` in the multiset `window` and we deterministically remove the first occurrence (take note that we use `std::multiset::lower_bound()` [^note-2] to find the correct occurrence to erase), this case is handled in the same manner as the first case.\n\n    + In the first and third cases, removing `num` will spoil the `mid` iterator. Thus we need to fix that by incrementing `mid` before we remove that element.\n\n    + For the second case, the `mid` iterator is not spoiled. No further action is required.\n\n    + Once this element has been removed, the window size returns to being $$k$$.\n\n+ After insertion of the incoming element and removal of the outgoing element, we are left again with some nice invariants:\n\n    1. Window size is again $$k$$.\n    2. The window is still fully sorted.\n    3. `mid` still points to the $$\\lfloor k/2 \\rfloor$$ indexed element.\n\n+ Finding the median of the window is easy! It is simply the **mean** of the elements pointed to by the two pointers `lo_median` and `hi_median`. In our case those are `mid` or `prev(mid)` (as decided by whether $$k$$ is odd or even) , and `mid` respectively.\n\n[^note-3]\n\n<iframe src=\"https://leetcode.com/playground/aZD3boL4/shared\" frameBorder=\"0\" width=\"100%\" height=\"500\" name=\"aZD3boL4\"></iframe>\n\n**Complexity Analysis**\n\n* Time complexity: $$O((n-k) \\log k) + O(k) \\approx O(n \\log k)$$.\n\n    + Initializing `mid` takes about $$O(k)$$ time.\n    + Inserting or deleting a number takes $$O(\\log k)$$ time for a standard `multiset` scheme. [^note-4]\n    + Finding the mean takes constant $$O(1)$$ time since the median elements are directly accessible from `mid` iterator.\n    + The last two steps take place about $$(n-k)$$ times (the number of sliding window instances).\n\n* Space complexity: $$O(k)$$ extra linear space to hold contents of the window.\n\n---\n#### Further Thoughts\n\nAs noted before, this problem is essentially an extension to [295. Find Median From Data Stream](https://leetcode.com/problems/find-median-from-data-stream/). That problem had a lot of ways to go about, that frankly, are not of much use in an interview. But they are interesting to follow all the same. If you are interested take a look [here.](https://leetcode.com/articles/find-median-from-data-stream#further-thoughts) Try extending those methods to this problem.\n\n---\nAnalysis written by [@babhishek21](https://leetcode.com/babhishek21).\n\n[^note-1]: `std::prev()` is a C++ method to find the previous element to the current one being pointed to by an iterator.\n[^note-2]: Had we used `std::multiset::find()`, there was no guarantee that the first occurrence of `num` would be found. Although the contrary did happen in all of our tests, I don't recommend using it. Your mileage may vary.\n[^note-3]: Shout-out to [@votrubac](https://leetcode.com/votrubac/) and [@StefanPochmann](https://leetcode.com/stefanpochmann)!\n[^note-4]: [Hinting](http://en.cppreference.com/w/cpp/container/multiset/insert) can reduce that to amortized constant $$O(1)$$ time.",
    "contentTypeId": "107",
    "rating": {
      "id": "84",
      "count": 14,
      "average": 4.071,
      "userRating": null
    }
  },
  "status": null,
  "sampleTestCase": "[1,3,-1,-3,5,3,6,7]\n3",
  "metaData": "{ \r\n  \"name\": \"medianSlidingWindow\",\r\n  \"params\": [\r\n    { \r\n      \"name\": \"nums\",\r\n      \"type\": \"integer[]\"\r\n    },\r\n    {\r\n      \"name\": \"k\",\r\n      \"type\": \"integer\"\r\n    }\r\n  ],\r\n  \"return\": {\r\n    \"type\": \"double[]\"\r\n  }\r\n}",
  "judgerAvailable": true,
  "judgeType": "large",
  "mysqlSchemas": [],
  "enableRunCode": true,
  "enableTestMode": false,
  "libraryUrl": null
}
