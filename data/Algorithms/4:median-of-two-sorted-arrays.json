{
  "questionId": "4",
  "questionFrontendId": "4",
  "boundTopicId": null,
  "title": "Median of Two Sorted Arrays",
  "titleSlug": "median-of-two-sorted-arrays",
  "categoryTitle": "Algorithms",
  "content": "<p>There are two sorted arrays <b>nums1</b> and <b>nums2</b> of size m and n respectively.</p>\r\n\r\n<p>Find the median of the two sorted arrays. The overall run time complexity should be O(log (m+n)).</p>\r\n\r\n<p>You may assume <strong>nums1</strong> and <strong>nums2</strong>&nbsp;cannot be both empty.</p>\r\n\r\n<p><b>Example 1:</b></p>\r\n\r\n<pre>\r\nnums1 = [1, 3]\r\nnums2 = [2]\r\n\r\nThe median is 2.0\r\n</pre>\r\n\r\n<p><b>Example 2:</b></p>\r\n\r\n<pre>\r\nnums1 = [1, 2]\r\nnums2 = [3, 4]\r\n\r\nThe median is (2 + 3)/2 = 2.5\r\n</pre>\r\n",
  "isPaidOnly": false,
  "difficulty": "Hard",
  "likes": 5575,
  "dislikes": 825,
  "isLiked": null,
  "similarQuestions": "[]",
  "contributors": [],
  "topicTags": [
    {
      "name": "Array",
      "slug": "array"
    },
    {
      "name": "Binary Search",
      "slug": "binary-search"
    },
    {
      "name": "Divide and Conquer",
      "slug": "divide-and-conquer"
    }
  ],
  "companyTagStats": "{\"1\": [{\"taggedByAdmin\": false, \"name\": \"Amazon\", \"slug\": \"amazon\", \"timesEncountered\": 14}, {\"taggedByAdmin\": true, \"name\": \"Google\", \"slug\": \"google\", \"timesEncountered\": 13}, {\"taggedByAdmin\": false, \"name\": \"Goldman Sachs\", \"slug\": \"goldman-sachs\", \"timesEncountered\": 11}, {\"taggedByAdmin\": false, \"name\": \"Uber\", \"slug\": \"uber\", \"timesEncountered\": 6}, {\"taggedByAdmin\": true, \"name\": \"Microsoft\", \"slug\": \"microsoft\", \"timesEncountered\": 5}, {\"taggedByAdmin\": true, \"name\": \"Apple\", \"slug\": \"apple\", \"timesEncountered\": 5}, {\"taggedByAdmin\": false, \"name\": \"Facebook\", \"slug\": \"facebook\", \"timesEncountered\": 3}, {\"taggedByAdmin\": true, \"name\": \"Yahoo\", \"slug\": \"yahoo\", \"timesEncountered\": 3}, {\"taggedByAdmin\": true, \"name\": \"Adobe\", \"slug\": \"adobe\", \"timesEncountered\": 2}, {\"taggedByAdmin\": false, \"name\": \"Zillow\", \"slug\": \"zillow\", \"timesEncountered\": 2}, {\"taggedByAdmin\": false, \"name\": \"Zulily\", \"slug\": \"zulily\", \"timesEncountered\": 2}, {\"taggedByAdmin\": false, \"name\": \"Oracle\", \"slug\": \"oracle\", \"timesEncountered\": 2}], \"3\": [{\"taggedByAdmin\": false, \"name\": \"Tencent\", \"slug\": \"tencent\", \"timesEncountered\": 6}, {\"taggedByAdmin\": false, \"name\": \"Two Sigma\", \"slug\": \"two-sigma\", \"timesEncountered\": 4}, {\"taggedByAdmin\": false, \"name\": \"DiDi\", \"slug\": \"didi\", \"timesEncountered\": 3}, {\"taggedByAdmin\": false, \"name\": \"Airbnb\", \"slug\": \"airbnb\", \"timesEncountered\": 3}, {\"taggedByAdmin\": false, \"name\": \"Baidu\", \"slug\": \"baidu\", \"timesEncountered\": 3}, {\"taggedByAdmin\": false, \"name\": \"Alibaba\", \"slug\": \"alibaba\", \"timesEncountered\": 3}, {\"taggedByAdmin\": false, \"name\": \"Hulu\", \"slug\": \"hulu\", \"timesEncountered\": 2}, {\"taggedByAdmin\": false, \"name\": \"Houzz\", \"slug\": \"houzz\", \"timesEncountered\": 2}, {\"taggedByAdmin\": false, \"name\": \"Garena\", \"slug\": \"garena\", \"timesEncountered\": 2}, {\"taggedByAdmin\": true, \"name\": \"Zenefits\", \"slug\": \"zenefits\", \"timesEncountered\": 0}, {\"taggedByAdmin\": true, \"name\": \"Dropbox\", \"slug\": \"dropbox\", \"timesEncountered\": 0}], \"2\": [{\"taggedByAdmin\": false, \"name\": \"Bloomberg\", \"slug\": \"bloomberg\", \"timesEncountered\": 3}, {\"taggedByAdmin\": false, \"name\": \"VMware\", \"slug\": \"vmware\", \"timesEncountered\": 3}, {\"taggedByAdmin\": false, \"name\": \"Walmart Labs\", \"slug\": \"walmart-labs\", \"timesEncountered\": 3}, {\"taggedByAdmin\": false, \"name\": \"Visa\", \"slug\": \"visa\", \"timesEncountered\": 3}, {\"taggedByAdmin\": false, \"name\": \"eBay\", \"slug\": \"ebay\", \"timesEncountered\": 2}, {\"taggedByAdmin\": false, \"name\": \"Rubrik\", \"slug\": \"rubrik\", \"timesEncountered\": 2}, {\"taggedByAdmin\": false, \"name\": \"GoDaddy\", \"slug\": \"godaddy\", \"timesEncountered\": 2}]}",
  "codeSnippets": [
    {
      "lang": "C++",
      "code": "class Solution {\npublic:\n    double findMedianSortedArrays(vector<int>& nums1, vector<int>& nums2) {\n        \n    }\n};"
    },
    {
      "lang": "Java",
      "code": "class Solution {\n    public double findMedianSortedArrays(int[] nums1, int[] nums2) {\n        \n    }\n}"
    },
    {
      "lang": "Python",
      "code": "class Solution(object):\n    def findMedianSortedArrays(self, nums1, nums2):\n        \"\"\"\n        :type nums1: List[int]\n        :type nums2: List[int]\n        :rtype: float\n        \"\"\"\n        "
    },
    {
      "lang": "Python3",
      "code": "class Solution:\n    def findMedianSortedArrays(self, nums1: List[int], nums2: List[int]) -> float:\n        "
    },
    {
      "lang": "C",
      "code": "\n\ndouble findMedianSortedArrays(int* nums1, int nums1Size, int* nums2, int nums2Size){\n\n}\n\n"
    },
    {
      "lang": "C#",
      "code": "public class Solution {\n    public double FindMedianSortedArrays(int[] nums1, int[] nums2) {\n        \n    }\n}"
    },
    {
      "lang": "JavaScript",
      "code": "/**\n * @param {number[]} nums1\n * @param {number[]} nums2\n * @return {number}\n */\nvar findMedianSortedArrays = function(nums1, nums2) {\n    \n};"
    },
    {
      "lang": "Ruby",
      "code": "# @param {Integer[]} nums1\n# @param {Integer[]} nums2\n# @return {Float}\ndef find_median_sorted_arrays(nums1, nums2)\n    \nend"
    },
    {
      "lang": "Swift",
      "code": "class Solution {\n    func findMedianSortedArrays(_ nums1: [Int], _ nums2: [Int]) -> Double {\n        \n    }\n}"
    },
    {
      "lang": "Go",
      "code": "func findMedianSortedArrays(nums1 []int, nums2 []int) float64 {\n    \n}"
    },
    {
      "lang": "Scala",
      "code": "object Solution {\n    def findMedianSortedArrays(nums1: Array[Int], nums2: Array[Int]): Double = {\n        \n    }\n}"
    },
    {
      "lang": "Kotlin",
      "code": "class Solution {\n    fun findMedianSortedArrays(nums1: IntArray, nums2: IntArray): Double {\n        \n    }\n}"
    },
    {
      "lang": "Rust",
      "code": "impl Solution {\n    pub fn find_median_sorted_arrays(nums1: Vec<i32>, nums2: Vec<i32>) -> f64 {\n        \n    }\n}"
    },
    {
      "lang": "PHP",
      "code": "class Solution {\n\n    /**\n     * @param Integer[] $nums1\n     * @param Integer[] $nums2\n     * @return Float\n     */\n    function findMedianSortedArrays($nums1, $nums2) {\n        \n    }\n}"
    }
  ],
  "stats": "{\"totalAccepted\": \"561.4K\", \"totalSubmission\": \"2M\", \"totalAcceptedRaw\": 561405, \"totalSubmissionRaw\": 2007448, \"acRate\": \"28.0%\"}",
  "hints": [],
  "solution": {
    "id": "232",
    "canSeeDetail": true,
    "url": "/articles/median-of-two-sorted-arrays/",
    "content": "[TOC]\n\n## Solution\n\n---\n#### Approach 1: Recursive Approach\n\nTo solve this problem, we need to understand \"What is the use of median\". In statistics, the median is used for:\n\n>Dividing a set into two equal length subsets, that one subset is always greater than the other.\n\nIf we understand the use of median for dividing, we are very close to the answer.\n\nFirst let's cut $$\\text{A}$$ into two parts at a random position $$i$$:\n\n```\n          left_A             |        right_A\n    A[0], A[1], ..., A[i-1]  |  A[i], A[i+1], ..., A[m-1]\n```\n\nSince $$\\text{A}$$ has $$m$$ elements, so there are $$m+1$$ kinds of cutting ($$i = 0 \\sim m$$).\n\nAnd we know:\n\n>$$\\text{len}(\\text{left\\_A}) = i, \\text{len}(\\text{right\\_A}) = m - i$$.\n>\n>Note: when $$i = 0$$, $$\\text{left\\_A}$$ is empty, and when $$i = m$$, $$\\text{right\\_A}$$ is empty.\n\nWith the same way, cut $$\\text{B}$$ into two parts at a random position $$j$$:\n\n```\n\n          left_B             |        right_B\n    B[0], B[1], ..., B[j-1]  |  B[j], B[j+1], ..., B[n-1]\n```\n\nPut $$\\text{left\\_A}$$ and $$\\text{left\\_B}$$ into one set, and put $$\\text{right\\_A}$$ and $$\\text{right\\_B}$$ into another set. Let's name them $$\\text{left\\_part}$$ and $$\\text{right\\_part}$$:\n\n```\n          left_part          |        right_part\n    A[0], A[1], ..., A[i-1]  |  A[i], A[i+1], ..., A[m-1]\n    B[0], B[1], ..., B[j-1]  |  B[j], B[j+1], ..., B[n-1]\n```\n\nIf we can ensure:\n\n>1. $$\\text{len}(\\text{left\\_part}) = \\text{len}(\\text{right\\_part})$$\n>2. $$\\max(\\text{left\\_part}) \\leq \\min(\\text{right\\_part})$$\n\nthen we divide all elements in $$\\{\\text{A}, \\text{B}\\}$$ into two parts with equal length, and one part is always greater than the other. Then\n\n$$\n\\text{median} = \\frac{\\text{max}(\\text{left}\\_\\text{part}) + \\text{min}(\\text{right}\\_\\text{part})}{2}\n$$\n\nTo ensure these two conditions, we just need to ensure:\n\n>1. $$i + j = m - i + n - j$$ (or: $$m - i + n - j + 1$$)  \n>   if $$n \\geq m$$, we just need to set:  $$ \\ i = 0 \\sim m,\\  j = \\frac{m + n + 1}{2} - i \\\\$$  \n>  \n>  \n>2.  $$\\text{B}[j-1] \\leq \\text{A}[i]$$ and $$\\text{A}[i-1] \\leq \\text{B}[j]$$\n\nps.1 For simplicity, I presume $$\\text{A}[i-1], \\text{B}[j-1], \\text{A}[i], \\text{B}[j]$$ are always valid even if $$i=0$$, $$i=m$$, $$j=0$$, or $$j=n$$.\nI will talk about how to deal with these edge values at last.\n\nps.2 Why $$n \\geq m$$? Because I have to make sure $$j$$ is non-negative since $$0 \\leq i \\leq m$$ and $$j = \\frac{m + n + 1}{2} - i$$. If $$n < m$$, then $$j$$ may be negative, that will lead to wrong result.\n\nSo, all we need to do is:\n\n>Searching $$i$$ in $$[0, m]$$, to find an object $$i$$ such that:\n>  \n>$$\\qquad \\text{B}[j-1] \\leq \\text{A}[i]\\ $$ and $$\\ \\text{A}[i-1] \\leq \\text{B}[j],\\ $$ where $$j = \\frac{m + n + 1}{2} - i$$\n\nAnd we can do a binary search following steps described below:\n\n1. Set $$\\text{imin} = 0$$, $$\\text{imax} = m$$, then start searching in $$[\\text{imin}, \\text{imax}]$$\n2. Set $$i = \\frac{\\text{imin} + \\text{imax}}{2}$$, $$j = \\frac{m + n + 1}{2} - i$$\n3. Now we have $$\\text{len}(\\text{left}\\_\\text{part})=\\text{len}(\\text{right}\\_\\text{part})$$. And there are only 3 situations that we may encounter:  \n\n    - $$\\text{B}[j-1] \\leq \\text{A}[i]$$ and $$\\text{A}[i-1] \\leq \\text{B}[j]$$  \n      Means we have found the object $$i$$, so stop searching.  \n\n    - $$\\text{B}[j-1] > \\text{A}[i]$$  \n      Means $$\\text{A}[i]$$ is too small. We must adjust $$i$$ to get $$\\text{B}[j-1] \\leq \\text{A}[i]$$.  \n      Can we increase $$i$$?  \n      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Yes. Because when $$i$$ is increased, $$j$$ will be decreased.  \n      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;So $$\\text{B}[j-1]$$ is decreased and $$\\text{A}[i]$$ is increased, and $$\\text{B}[j-1] \\leq \\text{A}[i]$$ may  \n      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;be satisfied.  \n      Can we decrease $$i$$?  \n      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;No! Because when $$i$$ is decreased, $$j$$ will be increased.  \n      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;So $$\\text{B}[j-1]$$ is increased and $$\\text{A}[i]$$ is decreased, and $$\\text{B}[j-1] \\leq \\text{A}[i]$$ will  \n      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;be never satisfied.  \n      So we must increase $$i$$. That is, we must adjust the searching range to $$[i+1, \\text{imax}]$$.  \n      So, set $$\\text{imin} = i+1$$, and goto 2.\n\n    - $$\\text{A}[i-1] > \\text{B}[j]$$:  \n      Means $$\\text{A}[i-1]$$ is too big. And we must decrease $$i$$ to get   $$\\text{A}[i-1]\\leq \\text{B}[j]$$.  \n      That is, we must adjust the searching range to $$[\\text{imin}, i-1]$$.  \n      So, set $$\\text{imax} = i-1$$, and goto 2.\n\n\nWhen the object $$i$$ is found, the median is:\n\n>$$\\max(\\text{A}[i-1], \\text{B}[j-1]), \\ $$ when $$m + n$$ is odd\n\n>$$\\frac{\\max(\\text{A}[i-1], \\text{B}[j-1]) + \\min(\\text{A}[i], \\text{B}[j])}{2}, \\ $$ when $$m + n$$ is even\n\nNow let's consider the edges values $$i=0,i=m,j=0,j=n$$ where $$\\text{A}[i-1],\\text{B}[j-1],\\text{A}[i],\\text{B}[j]$$ may not exist.\nActually this situation is easier than you think.\n\nWhat we need to do is ensuring that $$\\text{max}(\\text{left}\\_\\text{part}) \\leq \\text{min}(\\text{right}\\_\\text{part})$$. So, if $$i$$ and $$j$$ are not edges values (means $$\\text{A}[i-1],\n\\text{B}[j-1],\\text{A}[i],\\text{B}[j]$$ all exist), then we must check both $$\\text{B}[j-1] \\leq \\text{A}[i]$$ and $$\\text{A}[i-1] \\leq \\text{B}[j]$$.\nBut if some of $$\\text{A}[i-1],\\text{B}[j-1],\\text{A}[i],\\text{B}[j]$$ don't exist, then we don't need to check one (or both) of these two conditions.\nFor example, if $$i=0$$, then $$\\text{A}[i-1]$$ doesn't exist, then we don't need to check $$\\text{A}[i-1] \\leq \\text{B}[j]$$.\nSo, what we need to do is:\n\n>Searching $$i$$ in $$[0, m]$$, to find an object $$i$$ such that:\n>\n>$$(j = 0$$ or $$i = m$$ or $$\\text{B}[j-1] \\leq \\text{A}[i])$$ and  \n>$$(i = 0$$ or $$j = n$$ or $$\\text{A}[i-1] \\leq \\text{B}[j]),$$  where $$j = \\frac{m + n + 1}{2} - i$$\n\nAnd in a searching loop, we will encounter only three situations:\n\n>1. $$(j = 0$$ or $$i = m$$ or $$\\text{B}[j-1] \\leq \\text{A}[i])$$ and  \n    $$(i = 0$$ or $$j = n$$ or $$\\text{A}[i-1] \\leq \\text{B}[j])$$  \n    Means $$i$$ is perfect, we can stop searching.\n>2. $$j > 0$$ and $$i < m$$ and $$\\text{B}[j - 1] > \\text{A}[i]$$  \n    Means $$i$$ is too small, we must increase it.\n>3. $$i > 0$$ and $$j < n$$ and $$\\text{A}[i - 1] > \\text{B}[j]$$  \n    Means $$i$$ is too big, we must decrease it.\n\nThanks to [@Quentin.chen](https://leetcode.com/Quentin.chen) for pointing out that: $$i < m \\implies j > 0$$ and $$i > 0 \\implies j < n$$. Because:\n\n\n>$$m \\leq n,\\  i < m \\implies j = \\frac{m+n+1}{2} - i > \\frac{m+n+1}{2} - m \\geq \\frac{2m+1}{2} - m \\geq 0$$\n>\n>$$m \\leq n,\\  i > 0 \\implies j = \\frac{m+n+1}{2} - i < \\frac{m+n+1}{2} \\leq \\frac{2n+1}{2} \\leq n$$\n\n\nSo in situation 2. and 3. , we don't need to check whether $$j > 0$$ and whether $$j < n$$.\n\n<iframe src=\"https://leetcode.com/playground/X5mgSxnd/shared\" frameBorder=\"0\" width=\"100%\" height=\"500\" name=\"X5mgSxnd\"></iframe>\n\n**Complexity Analysis**\n\n* Time complexity: $$O\\big(\\log\\big(\\text{min}(m,n)\\big)\\big)$$.  \nAt first, the searching range is $$[0, m]$$.\nAnd the length of this searching range will be reduced by half after each loop.\nSo, we only need $$\\log(m)$$ loops. Since we do constant operations in each loop, so the time complexity is $$O\\big(\\log(m)\\big)$$.\nSince $$m \\leq n$$, so the time complexity is $$O\\big(\\log\\big(\\text{min}(m,n)\\big)\\big)$$.\n\n* Space complexity: $$O(1)$$.  \nWe only need constant memory to store $$9$$ local variables, so the space complexity is $$O(1)$$.",
    "contentTypeId": "107",
    "rating": {
      "id": "227",
      "count": 485,
      "average": 3.79,
      "userRating": null
    }
  },
  "status": "ac",
  "sampleTestCase": "[1,3]\n[2]",
  "metaData": "{\r\n  \"name\": \"findMedianSortedArrays\",\r\n  \"params\": [\r\n    {\r\n      \"name\": \"nums1\",\r\n      \"type\": \"integer[]\"\r\n    },\r\n    {\r\n      \"name\": \"nums2\",\r\n      \"type\": \"integer[]\"\r\n    }\r\n  ],\r\n  \"return\": {\r\n    \"type\": \"double\"\r\n  }\r\n}",
  "judgerAvailable": true,
  "judgeType": "large",
  "mysqlSchemas": [],
  "enableRunCode": true,
  "enableTestMode": false,
  "libraryUrl": null
}
