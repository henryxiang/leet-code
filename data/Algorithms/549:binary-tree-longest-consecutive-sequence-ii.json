{
  "questionId": "549",
  "questionFrontendId": "549",
  "boundTopicId": null,
  "title": "Binary Tree Longest Consecutive Sequence II",
  "titleSlug": "binary-tree-longest-consecutive-sequence-ii",
  "categoryTitle": "Algorithms",
  "content": "<p>Given a binary tree, you need to find the length of Longest Consecutive Path in Binary Tree.</p>\r\n\r\n<p>Especially, this path can be either increasing or decreasing. For example, [1,2,3,4] and [4,3,2,1] are both considered valid, but the path [1,2,4,3] is not valid. On the other hand, the path can be in the child-Parent-child order, where not necessarily be parent-child order.</p>\r\n\r\n<p><b>Example 1:</b></p>\r\n\r\n<pre>\r\n<b>Input:</b>\r\n        1\r\n       / \\\r\n      2   3\r\n<b>Output:</b> 2\r\n<b>Explanation:</b> The longest consecutive path is [1, 2] or [2, 1].\r\n</pre>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p><b>Example 2:</b></p>\r\n\r\n<pre>\r\n<b>Input:</b>\r\n        2\r\n       / \\\r\n      1   3\r\n<b>Output:</b> 3\r\n<b>Explanation:</b> The longest consecutive path is [1, 2, 3] or [3, 2, 1].\r\n</pre>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p><b>Note:</b> All the values of tree nodes are in the range of [-1e7, 1e7].</p>\r\n",
  "isPaidOnly": true,
  "difficulty": "Medium",
  "likes": 465,
  "dislikes": 28,
  "isLiked": null,
  "similarQuestions": "[{\"title\": \"Binary Tree Longest Consecutive Sequence\", \"titleSlug\": \"binary-tree-longest-consecutive-sequence\", \"difficulty\": \"Medium\", \"translatedTitle\": null}]",
  "contributors": [
    {
      "username": "nagasupreeth",
      "profileUrl": "/nagasupreeth/",
      "avatarUrl": "https://www.gravatar.com/avatar/b08635e8d534a2effdef540fb1ddb564.png?s=200"
    }
  ],
  "topicTags": [
    {
      "name": "Tree",
      "slug": "tree"
    }
  ],
  "companyTagStats": "{\"3\": [{\"taggedByAdmin\": true, \"name\": \"Google\", \"slug\": \"google\", \"timesEncountered\": 4}, {\"taggedByAdmin\": false, \"name\": \"Amazon\", \"slug\": \"amazon\", \"timesEncountered\": 2}], \"1\": [{\"taggedByAdmin\": false, \"name\": \"Facebook\", \"slug\": \"facebook\", \"timesEncountered\": 2}], \"2\": [{\"taggedByAdmin\": false, \"name\": \"Apple\", \"slug\": \"apple\", \"timesEncountered\": 2}]}",
  "codeSnippets": [
    {
      "lang": "C++",
      "code": "/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\n * };\n */\nclass Solution {\npublic:\n    int longestConsecutive(TreeNode* root) {\n        \n    }\n};"
    },
    {
      "lang": "Java",
      "code": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode(int x) { val = x; }\n * }\n */\nclass Solution {\n    public int longestConsecutive(TreeNode root) {\n        \n    }\n}"
    },
    {
      "lang": "Python",
      "code": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, x):\n#         self.val = x\n#         self.left = None\n#         self.right = None\n\nclass Solution(object):\n    def longestConsecutive(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        "
    },
    {
      "lang": "Python3",
      "code": "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, x):\n#         self.val = x\n#         self.left = None\n#         self.right = None\n\nclass Solution:\n    def longestConsecutive(self, root: TreeNode) -> int:\n        "
    },
    {
      "lang": "C",
      "code": "/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     struct TreeNode *left;\n *     struct TreeNode *right;\n * };\n */\n\n\nint longestConsecutive(struct TreeNode* root){\n\n}\n\n"
    },
    {
      "lang": "C#",
      "code": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     public int val;\n *     public TreeNode left;\n *     public TreeNode right;\n *     public TreeNode(int x) { val = x; }\n * }\n */\npublic class Solution {\n    public int LongestConsecutive(TreeNode root) {\n        \n    }\n}"
    },
    {
      "lang": "JavaScript",
      "code": "/**\n * Definition for a binary tree node.\n * function TreeNode(val) {\n *     this.val = val;\n *     this.left = this.right = null;\n * }\n */\n/**\n * @param {TreeNode} root\n * @return {number}\n */\nvar longestConsecutive = function(root) {\n    \n};"
    },
    {
      "lang": "Ruby",
      "code": "# Definition for a binary tree node.\n# class TreeNode\n#     attr_accessor :val, :left, :right\n#     def initialize(val)\n#         @val = val\n#         @left, @right = nil, nil\n#     end\n# end\n\n# @param {TreeNode} root\n# @return {Integer}\ndef longest_consecutive(root)\n    \nend"
    },
    {
      "lang": "Swift",
      "code": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     public var val: Int\n *     public var left: TreeNode?\n *     public var right: TreeNode?\n *     public init(_ val: Int) {\n *         self.val = val\n *         self.left = nil\n *         self.right = nil\n *     }\n * }\n */\nclass Solution {\n    func longestConsecutive(_ root: TreeNode?) -> Int {\n        \n    }\n}"
    },
    {
      "lang": "Go",
      "code": "/**\n * Definition for a binary tree node.\n * type TreeNode struct {\n *     Val int\n *     Left *TreeNode\n *     Right *TreeNode\n * }\n */\nfunc longestConsecutive(root *TreeNode) int {\n    \n}"
    },
    {
      "lang": "Scala",
      "code": "/**\n * Definition for a binary tree node.\n * class TreeNode(var _value: Int) {\n *   var value: Int = _value\n *   var left: TreeNode = null\n *   var right: TreeNode = null\n * }\n */\nobject Solution {\n    def longestConsecutive(root: TreeNode): Int = {\n        \n    }\n}"
    },
    {
      "lang": "Kotlin",
      "code": "/**\n * Example:\n * var ti = TreeNode(5)\n * var v = ti.`val`\n * Definition for a binary tree node.\n * class TreeNode(var `val`: Int) {\n *     var left: TreeNode? = null\n *     var right: TreeNode? = null\n * }\n */\nclass Solution {\n    fun longestConsecutive(root: TreeNode?): Int {\n        \n    }\n}"
    },
    {
      "lang": "Rust",
      "code": "// Definition for a binary tree node.\n// #[derive(Debug, PartialEq, Eq)]\n// pub struct TreeNode {\n//   pub val: i32,\n//   pub left: Option<Rc<RefCell<TreeNode>>>,\n//   pub right: Option<Rc<RefCell<TreeNode>>>,\n// }\n// \n// impl TreeNode {\n//   #[inline]\n//   pub fn new(val: i32) -> Self {\n//     TreeNode {\n//       val,\n//       left: None,\n//       right: None\n//     }\n//   }\n// }\nuse std::rc::Rc;\nuse std::cell::RefCell;\nimpl Solution {\n    pub fn longest_consecutive(root: Option<Rc<RefCell<TreeNode>>>) -> i32 {\n        \n    }\n}"
    },
    {
      "lang": "PHP",
      "code": "/**\n * Definition for a binary tree node.\n * class TreeNode {\n *     public $val = null;\n *     public $left = null;\n *     public $right = null;\n *     function __construct($value) { $this->val = $value; }\n * }\n */\nclass Solution {\n\n    /**\n     * @param TreeNode $root\n     * @return Integer\n     */\n    function longestConsecutive($root) {\n        \n    }\n}"
    }
  ],
  "stats": "{\"totalAccepted\": \"20.9K\", \"totalSubmission\": \"45.6K\", \"totalAcceptedRaw\": 20863, \"totalSubmissionRaw\": 45632, \"acRate\": \"45.7%\"}",
  "hints": [],
  "solution": {
    "id": "103",
    "canSeeDetail": true,
    "url": "/articles/binary-tree-longest-consecutive-sequence-ii/",
    "content": "[TOC]\n\n## Summary\n\nFind the length of Longest Consecutive Path in Binary Tree. The path can be both increasing or decreasing i,e [1,2,3,4] and [4,3,2,1] are both considered valid. The path can be child-Parent-child not necessarily parent-child.\n\n## Solution\n\n---\n#### Approach #1 Brute Force [Time Limit Exceeded]\n\nWe can easily see that in a tree there is exactly one  unique path one from one node to another. So, the number of paths possible will be equal to number of pairs of nodes $${{N}\\choose{2}}$$, where $$N$$ is the number of nodes.\n\nBrute force solution of this problem is to find the path between every two nodes and check whether it is increasing or decreasing. In this way we can find maximum length increasing or decreasing sequence.\n\n**Complexity Analysis**\n\n* Time complexity : $$O(n^3)$$. Total possible number of paths are $$n^2$$ and checking every path whether it is increasing or decreasing will take $$O(n)$$ for one path.\n\n* Space complexity : $$O(n^3)$$. $$n^2$$ paths each with $$O(n)$$ nodes.\n\n---\n\n#### Approach #2 Single traversal [Accepted]\n\n**Algorithm**\n\nThis solution is very simple. With every node, we associate two values/variables named $$inr$$ and $$dcr$$, where $$incr$$ represents the length of the longest incrementing branch below the current node including itself, and $$dcr$$ represents the length of the longest decrementing branch below the current node including itself.\n\nWe make use of a recursive function `longestPath(node)` which returns an array of the form $$[inr, dcr]$$ for the calling node. We start off by assigning both $$inr$$ and $$dcr$$ as 1 for the current node. This is because the node itself always forms a consecutive increasing as well as decreasing path of length 1.\n\nThen, we obtain the length of the longest path for the left child of the current node using `longestPath[root.left]`. Now, if the left child is just smaller than the current node, it forms a decreasing sequence with the current node. Thus, the $$dcr$$ value for the current node is stored as  the left child's $$dcr$$ value + 1. But, if the left child is just larger than the current node, it forms an incrementing sequence with the current node. Thus, we update the current node's $$inr$$ value as $$left\\_child(inr) + 1$$.\n\nThen, we do the same process with the right child as well. But, for obtaining the $$inr$$ and $$dcr$$ value for the current node, we need to consider the maximum value out of the two values obtained from the left and the right child for both $$inr$$ and $$dcr$$, since we need to consider the longest sequence possible.\n\nFurther, after we've obtained the final updated values of $$inr$$ and $$dcr$$ for a node, we update the length of the longest consecutive path found so far as $$maxval =  \\text{max}(inr + dcr - 1)$$.\n\nThe following animation will make the process clear:\n\n<!-- ![Longest_Sequence_Tree](../Figures/549_Binary_Tree_2.gif) -->\n\n!?!../Documents/549_Binary_Tree_Longest_Sequence_ii.json:1000,563!?!\n\n\n<iframe src=\"https://leetcode.com/playground/5zMV57sH/shared\" frameBorder=\"0\" name=\"5zMV57sH\" width=\"100%\" height=\"515\"></iframe>\n\n**Complexity Analysis**\n\n* Time complexity : $$O(n)$$. The whole tree is traversed only once.\n* Space complexity : $$O(n)$$. The recursion goes upto a depth of $$n$$ in the worst case.\n\n---\n\nAnalysis written by: [@vinod23](https://leetcode.com/vinod23)",
    "contentTypeId": "107",
    "rating": {
      "id": "103",
      "count": 13,
      "average": 4.923,
      "userRating": null
    }
  },
  "status": null,
  "sampleTestCase": "[1,2,3,4]",
  "metaData": "{\r\n  \"name\": \"longestConsecutive\",\r\n  \"params\": [\r\n    {\r\n      \"name\": \"root\",\r\n      \"type\": \"TreeNode\"\r\n    }\r\n  ],\r\n  \"return\": {\r\n    \"type\": \"integer\"\r\n  }\r\n}\r\n",
  "judgerAvailable": true,
  "judgeType": "large",
  "mysqlSchemas": [],
  "enableRunCode": true,
  "enableTestMode": false,
  "libraryUrl": null
}
