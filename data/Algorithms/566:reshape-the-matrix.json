{
  "questionId": "566",
  "questionFrontendId": "566",
  "boundTopicId": null,
  "title": "Reshape the Matrix",
  "titleSlug": "reshape-the-matrix",
  "categoryTitle": "Algorithms",
  "content": "<p>In MATLAB, there is a very useful function called 'reshape', which can reshape a matrix into a new one with different size but keep its original data.\r\n</p>\r\n\r\n<p>\r\nYou're given a matrix represented by a two-dimensional array, and two <b>positive</b> integers <b>r</b> and <b>c</b> representing the <b>row</b> number and <b>column</b> number of the wanted reshaped matrix, respectively.</p>\r\n\r\n <p>The reshaped matrix need to be filled with all the elements of the original matrix in the same <b>row-traversing</b> order as they were.\r\n</p>\r\n\r\n<p>\r\nIf the 'reshape' operation with given parameters is possible and legal, output the new reshaped matrix; Otherwise, output the original matrix.\r\n</p>\r\n\r\n<p><b>Example 1:</b><br />\r\n<pre>\r\n<b>Input:</b> \r\nnums = \r\n[[1,2],\r\n [3,4]]\r\nr = 1, c = 4\r\n<b>Output:</b> \r\n[[1,2,3,4]]\r\n<b>Explanation:</b><br>The <b>row-traversing</b> of nums is [1,2,3,4]. The new reshaped matrix is a 1 * 4 matrix, fill it row by row by using the previous list.\r\n</pre>\r\n</p>\r\n\r\n<p><b>Example 2:</b><br />\r\n<pre>\r\n<b>Input:</b> \r\nnums = \r\n[[1,2],\r\n [3,4]]\r\nr = 2, c = 4\r\n<b>Output:</b> \r\n[[1,2],\r\n [3,4]]\r\n<b>Explanation:</b><br>There is no way to reshape a 2 * 2 matrix to a 2 * 4 matrix. So output the original matrix.\r\n</pre>\r\n</p>\r\n\r\n<p><b>Note:</b><br>\r\n<ol>\r\n<li>The height and width of the given matrix is in range [1, 100].</li>\r\n<li>The given r and c are all positive.</li>\r\n</ol>\r\n</p>",
  "isPaidOnly": false,
  "difficulty": "Easy",
  "likes": 658,
  "dislikes": 94,
  "isLiked": null,
  "similarQuestions": "[]",
  "contributors": [
    {
      "username": "just_not_over_12",
      "profileUrl": "/just_not_over_12/",
      "avatarUrl": "https://www.gravatar.com/avatar/464d04f3923cca7da1660e31335cd246.png?s=200"
    }
  ],
  "topicTags": [
    {
      "name": "Array",
      "slug": "array"
    }
  ],
  "companyTagStats": "{\"3\": [{\"taggedByAdmin\": true, \"name\": \"Mathworks\", \"slug\": \"mathworks\", \"timesEncountered\": 0}], \"1\": [], \"2\": []}",
  "codeSnippets": [
    {
      "lang": "C++",
      "code": "class Solution {\npublic:\n    vector<vector<int>> matrixReshape(vector<vector<int>>& nums, int r, int c) {\n        \n    }\n};"
    },
    {
      "lang": "Java",
      "code": "class Solution {\n    public int[][] matrixReshape(int[][] nums, int r, int c) {\n        \n    }\n}"
    },
    {
      "lang": "Python",
      "code": "class Solution(object):\n    def matrixReshape(self, nums, r, c):\n        \"\"\"\n        :type nums: List[List[int]]\n        :type r: int\n        :type c: int\n        :rtype: List[List[int]]\n        \"\"\"\n        "
    },
    {
      "lang": "Python3",
      "code": "class Solution:\n    def matrixReshape(self, nums: List[List[int]], r: int, c: int) -> List[List[int]]:\n        "
    },
    {
      "lang": "C",
      "code": "\n\n/**\n * Return an array of arrays of size *returnSize.\n * The sizes of the arrays are returned as *returnColumnSizes array.\n * Note: Both returned array and *columnSizes array must be malloced, assume caller calls free().\n */\nint** matrixReshape(int** nums, int numsSize, int* numsColSize, int r, int c, int* returnSize, int** returnColumnSizes){\n\n}\n\n"
    },
    {
      "lang": "C#",
      "code": "public class Solution {\n    public int[][] MatrixReshape(int[][] nums, int r, int c) {\n        \n    }\n}"
    },
    {
      "lang": "JavaScript",
      "code": "/**\n * @param {number[][]} nums\n * @param {number} r\n * @param {number} c\n * @return {number[][]}\n */\nvar matrixReshape = function(nums, r, c) {\n    \n};"
    },
    {
      "lang": "Ruby",
      "code": "# @param {Integer[][]} nums\n# @param {Integer} r\n# @param {Integer} c\n# @return {Integer[][]}\ndef matrix_reshape(nums, r, c)\n    \nend"
    },
    {
      "lang": "Swift",
      "code": "class Solution {\n    func matrixReshape(_ nums: [[Int]], _ r: Int, _ c: Int) -> [[Int]] {\n        \n    }\n}"
    },
    {
      "lang": "Go",
      "code": "func matrixReshape(nums [][]int, r int, c int) [][]int {\n    \n}"
    },
    {
      "lang": "Scala",
      "code": "object Solution {\n    def matrixReshape(nums: Array[Array[Int]], r: Int, c: Int): Array[Array[Int]] = {\n        \n    }\n}"
    },
    {
      "lang": "Kotlin",
      "code": "class Solution {\n    fun matrixReshape(nums: Array<IntArray>, r: Int, c: Int): Array<IntArray> {\n        \n    }\n}"
    },
    {
      "lang": "Rust",
      "code": "impl Solution {\n    pub fn matrix_reshape(nums: Vec<Vec<i32>>, r: i32, c: i32) -> Vec<Vec<i32>> {\n        \n    }\n}"
    },
    {
      "lang": "PHP",
      "code": "class Solution {\n\n    /**\n     * @param Integer[][] $nums\n     * @param Integer $r\n     * @param Integer $c\n     * @return Integer[][]\n     */\n    function matrixReshape($nums, $r, $c) {\n        \n    }\n}"
    }
  ],
  "stats": "{\"totalAccepted\": \"89K\", \"totalSubmission\": \"149.2K\", \"totalAcceptedRaw\": 88958, \"totalSubmissionRaw\": 149203, \"acRate\": \"59.6%\"}",
  "hints": [
    "Do you know how 2d matrix is stored in 1d memory? Try to map 2-dimensions into one.",
    "M[i][j]=M[n*i+j] , where n is the number of cols. \r\nThis is the one way of converting 2-d indices into one 1-d index.  \r\nNow, how will you convert 1-d index into 2-d indices?",
    "Try to use division and modulus to convert 1-d index into 2-d indices.",
    "M[i] =>  M[n/i][n%i]   Will it result in right mapping? Take some example and check this formulae."
  ],
  "solution": {
    "id": "120",
    "canSeeDetail": true,
    "url": "/articles/reshape-the-matrix/",
    "content": "[TOC]\n\n## Solution\n\n---\n#### Approach #1 Using queue [Accepted]\n\n**Algorithm**\n\nThe simplest method is to extract all the elements of the given matrix by reading the elements in a row-wise fashion. In this implementation, we use a queue to put the extracted elements. Then, we can take out the elements of the queue formed in a serial order and arrange the elements in the resultant required matrix in a row-by-row order again.\n\nThe formation of the resultant matrix won't be possible if the number of elements in the original matrix isn't equal to the number of elements in the resultant matrix.\n\n<iframe src=\"https://leetcode.com/playground/QiYrHtjz/shared\" frameBorder=\"0\" name=\"QiYrHtjz\" width=\"100%\" height=\"428\"></iframe>\n\n**Complexity Analysis**\n\n* Time complexity : $$O(m*n)$$. We traverse over $$m*n$$ elements twice. Here, $$m$$ and $$n$$ refer to the number of rows and columns of the given matrix respectively.\n\n* Space complexity : $$O(m*n)$$. The queue formed will be of size $$m*n$$.\n\n---\n#### Approach #2 Without using extra Space [Accepted]\n\n**Algorithm**\n\nInstead of unnecessarily using the queue as in the brute force approach, we can keep putting the numbers in the resultant matrix directly while iterating over the given matrix in a row-by-row order. While putting the numbers in the resultant array, we fix a particular row and keep on incrementing the column numbers only till we reach the end of the required columns indicated by $$c$$. At this moment, we update the row index by incrementing it and reset the column index to start from 0 again. Thus, we can save the space consumed by the queue for storing the data that just needs to be copied into a new array.\n\n<iframe src=\"https://leetcode.com/playground/JvBHJ8mJ/shared\" frameBorder=\"0\" name=\"JvBHJ8mJ\" width=\"100%\" height=\"394\"></iframe>\n\n**Complexity Analysis**\n\n* Time complexity : $$O(m*n)$$. We traverse the entire matrix of size $$m*n$$ once only. Here, $$m$$ and $$n$$ refers to the number of rows and columns in the given matrix.\n\n* Space complexity : $$O(m*n)$$. The resultant matrix of size $$m*n$$ is used. \n\n---\n\n#### Approach #3  Using division and modulus [Accepted]\n\n**Algorithm**\n\nIn the last approach, we needed to keep a track of when we reached the end of columns for the resultant matrix and needed to update the current row and column number for putting the extracted elements by checking the current indices every time. Instead of doing these limit checks at every step, we can make use of maths to help ease the situation. \n\nThe idea behind this approach is as follows. Do you know how a 2-D array is stored in the main memory(which is 1-D  in nature)? It is internally represented as a 1-D array only. The element $$nums[i][j]$$ of $$nums$$ array is represented in the form of a one dimensional array by using the index in the form: $$nums[n*i + j]$$, where $$m$$ is the number of columns in the given matrix. Looking at the same in the reverse order, while putting the elements in the elements in the resultant matrix, we can make use of a $$count$$ variable which gets incremented for every element traversed as if we are putting the elements in a 1-D resultant array. But, to convert the $$count$$ back into 2-D matrix indices with a column count of $$c$$, we can obtain the indices as $$res[count/c][count\\%c]$$ where $$count/c$$ is the row number and $$count\\%c$$ is the coloumn number. Thus, we can save the extra checking required at each step.\n\n<iframe src=\"https://leetcode.com/playground/3U3C5txm/shared\" frameBorder=\"0\" name=\"3U3C5txm\" width=\"100%\" height=\"309\"></iframe>\n**Complexity Analysis**\n\n* Time complexity : $$O(m*n)$$. We traverse the entire matrix of size $$m*n$$ once only. Here, $$m$$ and $$n$$ refers to the number of rows and columns in the given matrix.\n\n* Space complexity : $$O(m*n)$$. The resultant matrix of size $$m*n$$ is used. \n\n---\nAnalysis written by: [@vinod23](https://leetcode.com/vinod23)",
    "contentTypeId": "107",
    "rating": {
      "id": "118",
      "count": 23,
      "average": 4.826,
      "userRating": null
    }
  },
  "status": null,
  "sampleTestCase": "[[1,2],[3,4]]\n1\n4",
  "metaData": "{\r\n  \"name\": \"matrixReshape\",\r\n  \"params\": [\r\n    {\r\n      \"name\": \"nums\",\r\n      \"type\": \"integer[][]\"\r\n    },\r\n    {\r\n        \"name\": \"r\",\r\n        \"type\": \"integer\"\r\n    },\r\n    {\r\n        \"name\": \"c\",\r\n        \"type\": \"integer\"\r\n    }\r\n  ],\r\n  \"return\": {\r\n    \"type\": \"integer[][]\"\r\n  }\r\n}\r\n",
  "judgerAvailable": true,
  "judgeType": "large",
  "mysqlSchemas": [],
  "enableRunCode": true,
  "enableTestMode": false,
  "libraryUrl": null
}
