{
  "questionId": "572",
  "questionFrontendId": "572",
  "boundTopicId": null,
  "title": "Subtree of Another Tree",
  "titleSlug": "subtree-of-another-tree",
  "categoryTitle": "Algorithms",
  "content": "<p>\r\nGiven two non-empty binary trees <b>s</b> and <b>t</b>, check whether tree <b>t</b> has exactly the same structure and node values with a subtree of <b>s</b>. A subtree of <b>s</b> is a tree consists of a node in <b>s</b> and all of this node's descendants. The tree <b>s</b> could also be considered as a subtree of itself.\r\n</p>\r\n\r\n<p><b>Example 1:</b><br>\r\n\r\nGiven tree s:\r\n<pre>\r\n     3\r\n    / \\\r\n   4   5\r\n  / \\\r\n 1   2\r\n</pre>\r\nGiven tree t:\r\n<pre>\r\n   4 \r\n  / \\\r\n 1   2\r\n</pre>\r\nReturn <b>true</b>, because t has the same structure and node values with a subtree of s.\r\n</p>\r\n\r\n<p><b>Example 2:</b><br>\r\n\r\nGiven tree s:\r\n<pre>\r\n     3\r\n    / \\\r\n   4   5\r\n  / \\\r\n 1   2\r\n    /\r\n   0\r\n</pre>\r\nGiven tree t:\r\n<pre>\r\n   4\r\n  / \\\r\n 1   2\r\n</pre>\r\nReturn <b>false</b>.\r\n</p>",
  "isPaidOnly": false,
  "difficulty": "Easy",
  "likes": 1642,
  "dislikes": 72,
  "isLiked": null,
  "similarQuestions": "[{\"title\": \"Count Univalue Subtrees\", \"titleSlug\": \"count-univalue-subtrees\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Most Frequent Subtree Sum\", \"titleSlug\": \"most-frequent-subtree-sum\", \"difficulty\": \"Medium\", \"translatedTitle\": null}]",
  "contributors": [
    {
      "username": "laowangx",
      "profileUrl": "/laowangx/",
      "avatarUrl": "https://assets.leetcode.com/users/laowangx/avatar_1520135661.png"
    }
  ],
  "topicTags": [
    {
      "name": "Tree",
      "slug": "tree"
    }
  ],
  "companyTagStats": "{\"1\": [{\"taggedByAdmin\": false, \"name\": \"Amazon\", \"slug\": \"amazon\", \"timesEncountered\": 71}, {\"taggedByAdmin\": false, \"name\": \"Microsoft\", \"slug\": \"microsoft\", \"timesEncountered\": 5}, {\"taggedByAdmin\": false, \"name\": \"Google\", \"slug\": \"google\", \"timesEncountered\": 2}], \"3\": [{\"taggedByAdmin\": false, \"name\": \"Bloomberg\", \"slug\": \"bloomberg\", \"timesEncountered\": 5}, {\"taggedByAdmin\": false, \"name\": \"Samsung\", \"slug\": \"samsung\", \"timesEncountered\": 4}, {\"taggedByAdmin\": true, \"name\": \"eBay\", \"slug\": \"ebay\", \"timesEncountered\": 0}], \"2\": [{\"taggedByAdmin\": true, \"name\": \"Facebook\", \"slug\": \"facebook\", \"timesEncountered\": 3}]}",
  "codeSnippets": [
    {
      "lang": "C++",
      "code": "/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\n * };\n */\nclass Solution {\npublic:\n    bool isSubtree(TreeNode* s, TreeNode* t) {\n        \n    }\n};"
    },
    {
      "lang": "Java",
      "code": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode(int x) { val = x; }\n * }\n */\nclass Solution {\n    public boolean isSubtree(TreeNode s, TreeNode t) {\n        \n    }\n}"
    },
    {
      "lang": "Python",
      "code": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, x):\n#         self.val = x\n#         self.left = None\n#         self.right = None\n\nclass Solution(object):\n    def isSubtree(self, s, t):\n        \"\"\"\n        :type s: TreeNode\n        :type t: TreeNode\n        :rtype: bool\n        \"\"\"\n        "
    },
    {
      "lang": "Python3",
      "code": "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, x):\n#         self.val = x\n#         self.left = None\n#         self.right = None\n\nclass Solution:\n    def isSubtree(self, s: TreeNode, t: TreeNode) -> bool:\n        "
    },
    {
      "lang": "C",
      "code": "/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     struct TreeNode *left;\n *     struct TreeNode *right;\n * };\n */\n\n\nbool isSubtree(struct TreeNode* s, struct TreeNode* t){\n\n}\n\n"
    },
    {
      "lang": "C#",
      "code": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     public int val;\n *     public TreeNode left;\n *     public TreeNode right;\n *     public TreeNode(int x) { val = x; }\n * }\n */\npublic class Solution {\n    public bool IsSubtree(TreeNode s, TreeNode t) {\n        \n    }\n}"
    },
    {
      "lang": "JavaScript",
      "code": "/**\n * Definition for a binary tree node.\n * function TreeNode(val) {\n *     this.val = val;\n *     this.left = this.right = null;\n * }\n */\n/**\n * @param {TreeNode} s\n * @param {TreeNode} t\n * @return {boolean}\n */\nvar isSubtree = function(s, t) {\n    \n};"
    },
    {
      "lang": "Ruby",
      "code": "# Definition for a binary tree node.\n# class TreeNode\n#     attr_accessor :val, :left, :right\n#     def initialize(val)\n#         @val = val\n#         @left, @right = nil, nil\n#     end\n# end\n\n# @param {TreeNode} s\n# @param {TreeNode} t\n# @return {Boolean}\ndef is_subtree(s, t)\n    \nend"
    },
    {
      "lang": "Swift",
      "code": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     public var val: Int\n *     public var left: TreeNode?\n *     public var right: TreeNode?\n *     public init(_ val: Int) {\n *         self.val = val\n *         self.left = nil\n *         self.right = nil\n *     }\n * }\n */\nclass Solution {\n    func isSubtree(_ s: TreeNode?, _ t: TreeNode?) -> Bool {\n        \n    }\n}"
    },
    {
      "lang": "Go",
      "code": "/**\n * Definition for a binary tree node.\n * type TreeNode struct {\n *     Val int\n *     Left *TreeNode\n *     Right *TreeNode\n * }\n */\nfunc isSubtree(s *TreeNode, t *TreeNode) bool {\n    \n}"
    },
    {
      "lang": "Scala",
      "code": "/**\n * Definition for a binary tree node.\n * class TreeNode(var _value: Int) {\n *   var value: Int = _value\n *   var left: TreeNode = null\n *   var right: TreeNode = null\n * }\n */\nobject Solution {\n    def isSubtree(s: TreeNode, t: TreeNode): Boolean = {\n        \n    }\n}"
    },
    {
      "lang": "Kotlin",
      "code": "/**\n * Example:\n * var ti = TreeNode(5)\n * var v = ti.`val`\n * Definition for a binary tree node.\n * class TreeNode(var `val`: Int) {\n *     var left: TreeNode? = null\n *     var right: TreeNode? = null\n * }\n */\nclass Solution {\n    fun isSubtree(s: TreeNode?, t: TreeNode?): Boolean {\n        \n    }\n}"
    },
    {
      "lang": "Rust",
      "code": "// Definition for a binary tree node.\n// #[derive(Debug, PartialEq, Eq)]\n// pub struct TreeNode {\n//   pub val: i32,\n//   pub left: Option<Rc<RefCell<TreeNode>>>,\n//   pub right: Option<Rc<RefCell<TreeNode>>>,\n// }\n// \n// impl TreeNode {\n//   #[inline]\n//   pub fn new(val: i32) -> Self {\n//     TreeNode {\n//       val,\n//       left: None,\n//       right: None\n//     }\n//   }\n// }\nuse std::rc::Rc;\nuse std::cell::RefCell;\nimpl Solution {\n    pub fn is_subtree(s: Option<Rc<RefCell<TreeNode>>>, t: Option<Rc<RefCell<TreeNode>>>) -> bool {\n        \n    }\n}"
    },
    {
      "lang": "PHP",
      "code": "/**\n * Definition for a binary tree node.\n * class TreeNode {\n *     public $val = null;\n *     public $left = null;\n *     public $right = null;\n *     function __construct($value) { $this->val = $value; }\n * }\n */\nclass Solution {\n\n    /**\n     * @param TreeNode $s\n     * @param TreeNode $t\n     * @return Boolean\n     */\n    function isSubtree($s, $t) {\n        \n    }\n}"
    }
  ],
  "stats": "{\"totalAccepted\": \"155.8K\", \"totalSubmission\": \"359.4K\", \"totalAcceptedRaw\": 155799, \"totalSubmissionRaw\": 359449, \"acRate\": \"43.3%\"}",
  "hints": [
    "Which approach is better here- recursive or iterative?",
    "If recursive approach is better, can you write recursive function with its parameters?",
    "Two trees <b>s</b> and <b>t</b> are said to be identical if their root values are same and their left and right subtrees are identical. Can you write this in form of recursive formulae?",
    "Recursive formulae can be: \r\nisIdentical(s,t)= s.val==t.val AND isIdentical(s.left,t.left) AND isIdentical(s.right,t.right)"
  ],
  "solution": {
    "id": "128",
    "canSeeDetail": true,
    "url": "/articles/subtree-of-another-tree/",
    "content": "[TOC]\n\n\n## Solution\n\n---\n#### Approach #1 Using Preorder Traversal [Accepted]\n\n**Algorithm**\n\nWe can find the preorder traversal of the given tree $$s$$ and $$t$$, given by, say $$s_{preorder}$$ and $$t_{preorder}$$ respectively(represented in the form of a string). Now, we can check if $$t_{preorder}$$ is a substring of $$s_{preorder}$$. \n\nBut, in order to use this approach, we need to treat the given tree in a different manner. Rather than assuming a $$null$$ value for the childern of the leaf nodes, we need to treat the left and right child as a $$lnull$$ and $$rnull$$ value respectively. This is done to ensure that the $$t_{preorder}$$ doesn't become a substring of $$s_{preorder}$$ even in cases when $$t$$ isn't a subtree of $$s$$. \n\nYou can also note that we've added a '#' before every considering every value. If this isn't done, the trees of the form `s:[23, 4, 5]` and `t:[3, 4, 5]` will also give a true result since the preorder string of the `t(\"23 4 lnull rull 5 lnull rnull\")` will be a substring of the preorder string of `s(\"3 4 lnull rull 5 lnull rnull\")`. Adding a '#' before the node's value solves this problem.\n\n![Preorder_null](../Figures/572_Subtree_1.PNG)\n{:align=\"center\"}\n\n![Preorder_lnull_rnull](../Figures/572_Subtree_2.PNG)\n{:align=\"center\"}\n\n\n<iframe src=\"https://leetcode.com/playground/cagXWqSv/shared\" frameBorder=\"0\" name=\"cagXWqSv\" width=\"100%\" height=\"513\"></iframe>\n\n**Complexity Analysis**\n\n* Time complexity : $$O(m^2+n^2+m*n)$$. A total of $$n$$ nodes of the tree $$s$$ and $$m$$ nodes of tree $$t$$ are traversed. Assuming string concatenation takes $$O(k)$$ time for strings of length $$k$$ and `indexOf` takes $$O(m*n)$$.\n\n* Space complexity : $$O(max(m,n))$$. The depth of the recursion tree can go upto $$n$$ for tree $$t$$ and $$m$$ for tree $$s$$ in worst case.\n\n---\n#### Approach #2 By Comparison of Nodes  [Accepted]\n\n**Algorithm**\n\nInstead of creating an inorder traversal, we can treat every node of the given tree $$t$$ as the root, treat it as a subtree and compare the corresponding subtree with the given subtree $$s$$ for equality. For checking the equality, we can compare the all the nodes of the two subtrees. \n\nFor doing this, we make use a function `traverse(s,t)` which traverses over the given tree $$s$$ and treats every node as the root of the subtree currently being considered. It also checks the two subtrees currently being considered for their equality. In order to check the equality of the two subtrees, we make use of `equals(x,y)` function, which takes $$x$$ and $$y$$, which are the roots of the two subtrees to be compared as the inputs and returns True or False depending on whether the two are equal or not. It compares all the nodes of the two subtrees for equality. Firstly, it checks whether the roots of the two trees for equality and then calls itself recursively for the left subtree and the right subtree.\n\nThe follwowing animation depicts an abstracted view of the process:\n\n!?!../Documents/572_Subtree.json:1000,563!?!\n\n<iframe src=\"https://leetcode.com/playground/A6ipy4aH/shared\" frameBorder=\"0\" name=\"A6ipy4aH\" width=\"100%\" height=\"515\"></iframe>\n\n**Complexity Analysis**\n\n* Time complexity : $$O(m*n)$$. In worst case(skewed tree) `traverse` function takes $$O(m*n)$$ time. \n\n* Space complexity : $$O(n)$$. The depth of the recursion tree can go upto $$n$$. $$n$$ refers to the number of nodes in $$s$$.\n\n---\nAnalysis written by: [@vinod23](https://leetcode.com/vinod23)",
    "contentTypeId": "107",
    "rating": {
      "id": "126",
      "count": 64,
      "average": 3.078,
      "userRating": null
    }
  },
  "status": null,
  "sampleTestCase": "[3,4,5,1,2]\n[4,1,2]",
  "metaData": "{\r\n  \"name\": \"isSubtree\",\r\n  \"params\": [\r\n    {\r\n      \"name\": \"s\",\r\n      \"type\": \"TreeNode\"\r\n    },\r\n    {\r\n      \"name\": \"t\",\r\n      \"type\": \"TreeNode\"\r\n    }\r\n  ],\r\n  \"return\": {\r\n    \"type\": \"boolean\"\r\n  }\r\n}",
  "judgerAvailable": true,
  "judgeType": "large",
  "mysqlSchemas": [],
  "enableRunCode": true,
  "enableTestMode": false,
  "libraryUrl": null
}
