{
  "questionId": "623",
  "questionFrontendId": "623",
  "boundTopicId": null,
  "title": "Add One Row to Tree",
  "titleSlug": "add-one-row-to-tree",
  "categoryTitle": "Algorithms",
  "content": "<p>Given the root of a binary tree, then value <code>v</code> and depth <code>d</code>, you need to add a row of nodes with value <code>v</code> at the given depth <code>d</code>. The root node is at depth 1. </p>\r\n\r\n<p>The adding rule is: given a positive integer depth <code>d</code>, for each NOT null tree nodes <code>N</code> in depth <code>d-1</code>, create two tree nodes with value <code>v</code> as <code>N's</code> left subtree root and right subtree root. And <code>N's</code> <b>original left subtree</b> should be the left subtree of the new left subtree root, its <b>original right subtree</b> should be the right subtree of the new right subtree root. If depth <code>d</code> is 1 that means there is no depth d-1 at all, then create a tree node with value <b>v</b> as the new root of the whole original tree, and the original tree is the new root's left subtree.</p>\r\n\r\n<p><b>Example 1:</b><br />\r\n<pre>\r\n<b>Input:</b> \r\nA binary tree as following:\r\n       4\r\n     /   \\\r\n    2     6\r\n   / \\   / \r\n  3   1 5   \r\n\r\n<b>v = 1</b>\r\n\r\n<b>d = 2</b>\r\n\r\n<b>Output:</b> \r\n       4\r\n      / \\\r\n     1   1\r\n    /     \\\r\n   2       6\r\n  / \\     / \r\n 3   1   5   \r\n\r\n</pre>\r\n</p>\r\n\r\n\r\n<p><b>Example 2:</b><br />\r\n<pre>\r\n<b>Input:</b> \r\nA binary tree as following:\r\n      4\r\n     /   \r\n    2    \r\n   / \\   \r\n  3   1    \r\n\r\n<b>v = 1</b>\r\n\r\n<b>d = 3</b>\r\n\r\n<b>Output:</b> \r\n      4\r\n     /   \r\n    2\r\n   / \\    \r\n  1   1\r\n /     \\  \r\n3       1\r\n</pre>\r\n</p>\r\n\r\n<p><b>Note:</b><br>\r\n<ol>\r\n<li>The given d is in range [1, maximum depth of the given tree + 1].</li>\r\n<li>The given binary tree has at least one tree node.</li>\r\n</ol>\r\n</p>",
  "isPaidOnly": false,
  "difficulty": "Medium",
  "likes": 338,
  "dislikes": 113,
  "isLiked": null,
  "similarQuestions": "[]",
  "contributors": [
    {
      "username": "fallcreek",
      "profileUrl": "/fallcreek/",
      "avatarUrl": "https://www.gravatar.com/avatar/043194ec5c4c5d2778049a3fa6d2e1d8.png?s=200"
    }
  ],
  "topicTags": [
    {
      "name": "Tree",
      "slug": "tree"
    }
  ],
  "companyTagStats": "{\"3\": [{\"taggedByAdmin\": false, \"name\": \"Microsoft\", \"slug\": \"microsoft\", \"timesEncountered\": 2}, {\"taggedByAdmin\": true, \"name\": \"Gilt Groupe\", \"slug\": \"gilt-groupe\", \"timesEncountered\": 0}], \"1\": [], \"2\": []}",
  "codeSnippets": [
    {
      "lang": "C++",
      "code": "/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\n * };\n */\nclass Solution {\npublic:\n    TreeNode* addOneRow(TreeNode* root, int v, int d) {\n        \n    }\n};"
    },
    {
      "lang": "Java",
      "code": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode(int x) { val = x; }\n * }\n */\nclass Solution {\n    public TreeNode addOneRow(TreeNode root, int v, int d) {\n        \n    }\n}"
    },
    {
      "lang": "Python",
      "code": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, x):\n#         self.val = x\n#         self.left = None\n#         self.right = None\n\nclass Solution(object):\n    def addOneRow(self, root, v, d):\n        \"\"\"\n        :type root: TreeNode\n        :type v: int\n        :type d: int\n        :rtype: TreeNode\n        \"\"\"\n        "
    },
    {
      "lang": "Python3",
      "code": "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, x):\n#         self.val = x\n#         self.left = None\n#         self.right = None\n\nclass Solution:\n    def addOneRow(self, root: TreeNode, v: int, d: int) -> TreeNode:\n        "
    },
    {
      "lang": "C",
      "code": "/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     struct TreeNode *left;\n *     struct TreeNode *right;\n * };\n */\n\n\nstruct TreeNode* addOneRow(struct TreeNode* root, int v, int d){\n\n}\n\n"
    },
    {
      "lang": "C#",
      "code": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     public int val;\n *     public TreeNode left;\n *     public TreeNode right;\n *     public TreeNode(int x) { val = x; }\n * }\n */\npublic class Solution {\n    public TreeNode AddOneRow(TreeNode root, int v, int d) {\n        \n    }\n}"
    },
    {
      "lang": "JavaScript",
      "code": "/**\n * Definition for a binary tree node.\n * function TreeNode(val) {\n *     this.val = val;\n *     this.left = this.right = null;\n * }\n */\n/**\n * @param {TreeNode} root\n * @param {number} v\n * @param {number} d\n * @return {TreeNode}\n */\nvar addOneRow = function(root, v, d) {\n    \n};"
    },
    {
      "lang": "Ruby",
      "code": "# Definition for a binary tree node.\n# class TreeNode\n#     attr_accessor :val, :left, :right\n#     def initialize(val)\n#         @val = val\n#         @left, @right = nil, nil\n#     end\n# end\n\n# @param {TreeNode} root\n# @param {Integer} v\n# @param {Integer} d\n# @return {TreeNode}\ndef add_one_row(root, v, d)\n    \nend"
    },
    {
      "lang": "Swift",
      "code": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     public var val: Int\n *     public var left: TreeNode?\n *     public var right: TreeNode?\n *     public init(_ val: Int) {\n *         self.val = val\n *         self.left = nil\n *         self.right = nil\n *     }\n * }\n */\nclass Solution {\n    func addOneRow(_ root: TreeNode?, _ v: Int, _ d: Int) -> TreeNode? {\n        \n    }\n}"
    },
    {
      "lang": "Go",
      "code": "/**\n * Definition for a binary tree node.\n * type TreeNode struct {\n *     Val int\n *     Left *TreeNode\n *     Right *TreeNode\n * }\n */\nfunc addOneRow(root *TreeNode, v int, d int) *TreeNode {\n    \n}"
    },
    {
      "lang": "Scala",
      "code": "/**\n * Definition for a binary tree node.\n * class TreeNode(var _value: Int) {\n *   var value: Int = _value\n *   var left: TreeNode = null\n *   var right: TreeNode = null\n * }\n */\nobject Solution {\n    def addOneRow(root: TreeNode, v: Int, d: Int): TreeNode = {\n        \n    }\n}"
    },
    {
      "lang": "Kotlin",
      "code": "/**\n * Example:\n * var ti = TreeNode(5)\n * var v = ti.`val`\n * Definition for a binary tree node.\n * class TreeNode(var `val`: Int) {\n *     var left: TreeNode? = null\n *     var right: TreeNode? = null\n * }\n */\nclass Solution {\n    fun addOneRow(root: TreeNode?, v: Int, d: Int): TreeNode? {\n        \n    }\n}"
    },
    {
      "lang": "Rust",
      "code": "// Definition for a binary tree node.\n// #[derive(Debug, PartialEq, Eq)]\n// pub struct TreeNode {\n//   pub val: i32,\n//   pub left: Option<Rc<RefCell<TreeNode>>>,\n//   pub right: Option<Rc<RefCell<TreeNode>>>,\n// }\n// \n// impl TreeNode {\n//   #[inline]\n//   pub fn new(val: i32) -> Self {\n//     TreeNode {\n//       val,\n//       left: None,\n//       right: None\n//     }\n//   }\n// }\nuse std::rc::Rc;\nuse std::cell::RefCell;\nimpl Solution {\n    pub fn add_one_row(root: Option<Rc<RefCell<TreeNode>>>, v: i32, d: i32) -> Option<Rc<RefCell<TreeNode>>> {\n        \n    }\n}"
    },
    {
      "lang": "PHP",
      "code": "/**\n * Definition for a binary tree node.\n * class TreeNode {\n *     public $val = null;\n *     public $left = null;\n *     public $right = null;\n *     function __construct($value) { $this->val = $value; }\n * }\n */\nclass Solution {\n\n    /**\n     * @param TreeNode $root\n     * @param Integer $v\n     * @param Integer $d\n     * @return TreeNode\n     */\n    function addOneRow($root, $v, $d) {\n        \n    }\n}"
    }
  ],
  "stats": "{\"totalAccepted\": \"31.3K\", \"totalSubmission\": \"65K\", \"totalAcceptedRaw\": 31290, \"totalSubmissionRaw\": 64958, \"acRate\": \"48.2%\"}",
  "hints": [],
  "solution": {
    "id": "170",
    "canSeeDetail": true,
    "url": "/articles/add-one-row-in-a-tree/",
    "content": "[TOC]\n\n## Solution\n\n---\n#### Approach #1 Using Recursion(DFS) [Accepted]\n\nIf the given depth $$d$$ happens to be equal to 1, we can directly put the whole current tree as a left child of the newly added node. Otherwise, we need to put the new node at appropriate levels. \n\nTo do so, we make use of a recursive function `insert(val,node,depth,n)`. Here, $$val$$ refers to the value of the new node to be inserted, $$depth$$ refers to the depth of the node currently considered, $$node$$ refers to the node calling the current function for its child subtrees and $$n$$ refers to the height at which the new node needs to be inserted. \n\nFor inserting the new node at appropriate level, we can start by making a call to `insert` with the root node and 1 as the current level. Inside every such call, we check if we've reached one level prior to the level where the new node needs to be inserted. \n\nFrom this level, we can store the roots of the left and right subtrees of the current node temporarily, and insert the new node as the new left and right subchild of the current node, with the temporarily stored left and right subtrees as the left and right subtrees of the newly inserted left or right subchildren appropriately.\n\nBut, if we haven't reached the destined level, we keep on continuing the recursive calling process with the left and right children of the current node respectively. At every such call, we also incrmenet the depth of the current level to reflect the depth change appropriately.\n\nThe animation below illustrates the process:\n\n!?!../Documents/623_Add_One_Row_Recursion_New.json:1000,563!?!\n\n<iframe src=\"https://leetcode.com/playground/mqAnMFzQ/shared\" frameBorder=\"0\" name=\"mqAnMFzQ\" width=\"100%\" height=\"515\"></iframe>\n\n**Complexity Analysis**\n\n* Time complexity : $$O(n)$$. A total of $$n$$ nodes of the given tree will be considered.\n\n* Space complexity : $$O(n)$$. The depth of the recursion tree can go upto $$n$$ in the worst case(skewed tree).\n\n---\n#### Approach #2 Using stack(DFS) [Accepted]\n\n**Algorithm**\n\nWe can do the same task as discussed in the last approach by making use of a $$stack$$ as well. But, we need to make use of a new data structure, $$Node$$ here, to keep a track of the depth of the current node along with its value. \n\nWe start by pushing the root $$Node$$ onto the $$stack$$. Then, at every step we do as follows:\n\n* Pop an element from the $$stack$$. \n\n* For every Node popped, check if its depth corresponds to one prior to the depth at which the new node needs to be inserted. \n\n* If yes, insert the new nodes appropriately as in the last approach. \n\n* If no, we push both the left and the right child Node(value+depth) of the current node onto the $$stack$$. \n\n* Continue the popping and pushing process till the $$stack$$ becomes empty.\n\nLook at the animation below for a better understanding.\n\n!?!../Documents/623_Add_One_Row_Stack_new.json:1000,563!?!\n\n<iframe src=\"https://leetcode.com/playground/6Gut8kVG/shared\" frameBorder=\"0\" name=\"6Gut8kVG\" width=\"100%\" height=\"515\"></iframe>\n\n**Complexity Analysis**\n\n* Time complexity : $$O(n)$$. A total of $$n$$ nodes of the given tree will be considered.\n\n* Space complexity : $$O(n)$$. The depth of the $$stack$$ can go upto $$n$$ in the worst case(skewed tree).\n\n---\n\n#### Approach #3 Using queue(BFS) [Accepted]\n\n**Algorithm**\n\nThe idea of traversal in the last approach is similar to Depth First Search. In that case, we need to traverse through all the nodes of the given tree in the order of branches. Firstly we explored one branch to as much depth as possible and then continued with the other ones. \n\nIf, instead, we go for Breadth First Search, along with keeping track of the depth of the nodes being considered at any moment during the Breadth First Search, we can stop the search process as soon as all the nodes at the depth $$d - 1$$ have been considered once. \n\nTo implement this BFS, we make use of a $$queue$$. We start off by pushing the root node of the given tree at the back of the $$queue$$ and with the depth of the current level set as 1. Then, at every step, we do the following:\n\n* Remove an element from the front of the $$queue$$ and add all its children to the back of another temporary queue, $$temp$$. \n\n* Keep on adding the elements to the back of the $$temp$$ till $$queue$$ becomes empty. (Once $$queue$$ becomes empty, it indicates that all the nodes at the current level have been considered and now $$temp$$ contains all the nodes lying at the next level).\n\n* Reinitialize $$queue$$  with its value as $$temp$$. Update the current value of the $$depth$$ to reflect the level of nodes currently being considered. \n\n* Repeat the process till we reach the depth $$d - 1$$. \n\n* On hitting this depth level($$d-1$$), add the new nodes appropriately to all the nodes in the $$queue$$ currently, as done in the previous approaches.\n\nThe following animation illustrates the process.\n\n!?!../Documents/623_Add_One_Row_queue_new.json:1000,563!?!\n\n<iframe src=\"https://leetcode.com/playground/EC8ne3QM/shared\" frameBorder=\"0\" name=\"EC8ne3QM\" width=\"100%\" height=\"515\"></iframe>\n\n**Complexity Analysis**\n\n* Time complexity : $$O(n)$$. A total of $$n$$ nodes of the given tree will be considered in the worst case.\n\n* Space complexity : $$O(x)$$. The size of the $$queue$$ or $$temp$$ queue can grow upto $$x$$ only. Here, $$x$$ refers to the number of maximum number of nodes at any level in the given tree.\n\n---\n\n\nAnalysis written by: [@vinod23](https://leetcode.com/vinod23)",
    "contentTypeId": "107",
    "rating": {
      "id": "165",
      "count": 6,
      "average": 5,
      "userRating": null
    }
  },
  "status": null,
  "sampleTestCase": "[4,2,6,3,1,5]\n1\n2",
  "metaData": "{\r\n  \"name\": \"addOneRow\",\r\n  \"params\": [\r\n    {\r\n      \"name\": \"root\",\r\n      \"type\": \"TreeNode\"\r\n    },\r\n    {\r\n      \"name\": \"v\",\r\n      \"type\": \"integer\"\r\n    },\r\n    {\r\n      \"name\": \"d\",\r\n      \"type\": \"integer\"\r\n    }\r\n  ],\r\n  \"return\": {\r\n    \"type\": \"TreeNode\"\r\n  }\r\n}\r\n",
  "judgerAvailable": true,
  "judgeType": "large",
  "mysqlSchemas": [],
  "enableRunCode": true,
  "enableTestMode": false,
  "libraryUrl": null
}
