{
  "questionId": "631",
  "questionFrontendId": "631",
  "boundTopicId": null,
  "title": "Design Excel Sum Formula",
  "titleSlug": "design-excel-sum-formula",
  "categoryTitle": "Algorithms",
  "content": "<p>Your task is to design the basic function of Excel and implement the function of sum formula.  Specifically, you need to implement the following functions:</p>\r\n\r\n\r\n\r\n<p><code>Excel(int H, char W):</code> This is the constructor. The inputs represents the height and width of the Excel form. <b>H</b> is a positive integer, range from 1 to 26. It represents the height. <b>W</b> is a character range from 'A' to 'Z'. It represents that the width is the number of characters from 'A' to <b>W</b>. The Excel form content is represented by a height * width 2D integer array <code>C</code>, it should be initialized to zero. You should assume that the first row of <code>C</code> starts from 1, and the first column of <code>C</code> starts from 'A'.</p>\r\n\r\n<br>\r\n\r\n<p><code>void Set(int row, char column, int val):</code> Change the value at <code>C(row, column)</code> to be val.</p>\r\n<br>\r\n<p><code>int Get(int row, char column):</code> Return the value at <code>C(row, column)</code>.</p>\r\n<br>\r\n<p><code>int Sum(int row, char column, List of Strings : numbers):</code> This function calculate and set the value at <code>C(row, column)</code>, where the value should be the sum of cells represented by <code>numbers</code>. This function return the sum result at <code>C(row, column)</code>. This sum formula should exist until this cell is overlapped by another value or another sum formula.</p>\r\n\r\n<p><code>numbers</code> is a list of strings that each string represent a cell or a range of cells. If the string represent a single cell, then it has the following format : <code>ColRow</code>. For example, \"F7\" represents the cell at (7, F). </p>\r\n\r\n<p>If the string represent a range of cells, then it has the following format : <code>ColRow1:ColRow2</code>. The range will always be a rectangle, and ColRow1 represent the position of the top-left cell, and ColRow2 represents the position of the bottom-right cell. </p>\r\n<br>\r\n<p><b>Example 1:</b><br />\r\n<pre>\r\nExcel(3,\"C\"); \r\n// construct a 3*3 2D array with all zero.\r\n//   A B C\r\n// 1 0 0 0\r\n// 2 0 0 0\r\n// 3 0 0 0\r\n\r\nSet(1, \"A\", 2);\r\n// set C(1,\"A\") to be 2.\r\n//   A B C\r\n// 1 2 0 0\r\n// 2 0 0 0\r\n// 3 0 0 0\r\n\r\nSum(3, \"C\", [\"A1\", \"A1:B2\"]);\r\n// set C(3,\"C\") to be the sum of value at C(1,\"A\") and the values sum of the rectangle range whose top-left cell is C(1,\"A\") and bottom-right cell is C(2,\"B\"). Return 4. \r\n//   A B C\r\n// 1 2 0 0\r\n// 2 0 0 0\r\n// 3 0 0 4\r\n\r\nSet(2, \"B\", 2);\r\n// set C(2,\"B\") to be 2. Note C(3, \"C\") should also be changed.\r\n//   A B C\r\n// 1 2 0 0\r\n// 2 0 2 0\r\n// 3 0 0 6\r\n</pre>\r\n</p>\r\n\r\n<p><b>Note:</b><br>\r\n<ol>\r\n<li>You could assume that there won't be any circular sum reference. For example, A1 = sum(B1) and B1 = sum(A1).</li>\r\n<li> The test cases are using double-quotes to represent a character.</li>\r\n<li>Please remember to <b>RESET</b> your class variables declared in class Excel, as static/class variables are <b>persisted across multiple test cases</b>. Please see <a href=\"https://leetcode.com/faq/#different-output\">here</a> for more details.</li>\r\n</ol>\r\n</p>",
  "isPaidOnly": true,
  "difficulty": "Hard",
  "likes": 76,
  "dislikes": 77,
  "isLiked": null,
  "similarQuestions": "[]",
  "contributors": [
    {
      "username": "fallcreek",
      "profileUrl": "/fallcreek/",
      "avatarUrl": "https://www.gravatar.com/avatar/043194ec5c4c5d2778049a3fa6d2e1d8.png?s=200"
    }
  ],
  "topicTags": [
    {
      "name": "Design",
      "slug": "design"
    }
  ],
  "companyTagStats": "{\"2\": [{\"taggedByAdmin\": false, \"name\": \"Amazon\", \"slug\": \"amazon\", \"timesEncountered\": 2}], \"3\": [{\"taggedByAdmin\": true, \"name\": \"Microsoft\", \"slug\": \"microsoft\", \"timesEncountered\": 0}], \"1\": []}",
  "codeSnippets": [
    {
      "lang": "C++",
      "code": "class Excel {\npublic:\n    Excel(int H, char W) {\n        \n    }\n    \n    void set(int r, char c, int v) {\n        \n    }\n    \n    int get(int r, char c) {\n        \n    }\n    \n    int sum(int r, char c, vector<string> strs) {\n        \n    }\n};\n\n/**\n * Your Excel object will be instantiated and called as such:\n * Excel* obj = new Excel(H, W);\n * obj->set(r,c,v);\n * int param_2 = obj->get(r,c);\n * int param_3 = obj->sum(r,c,strs);\n */"
    },
    {
      "lang": "Java",
      "code": "class Excel {\n\n    public Excel(int H, char W) {\n        \n    }\n    \n    public void set(int r, char c, int v) {\n        \n    }\n    \n    public int get(int r, char c) {\n        \n    }\n    \n    public int sum(int r, char c, String[] strs) {\n        \n    }\n}\n\n/**\n * Your Excel object will be instantiated and called as such:\n * Excel obj = new Excel(H, W);\n * obj.set(r,c,v);\n * int param_2 = obj.get(r,c);\n * int param_3 = obj.sum(r,c,strs);\n */"
    },
    {
      "lang": "Python",
      "code": "class Excel(object):\n\n    def __init__(self, H, W):\n        \"\"\"\n        :type H: int\n        :type W: str\n        \"\"\"\n        \n\n    def set(self, r, c, v):\n        \"\"\"\n        :type r: int\n        :type c: str\n        :type v: int\n        :rtype: None\n        \"\"\"\n        \n\n    def get(self, r, c):\n        \"\"\"\n        :type r: int\n        :type c: str\n        :rtype: int\n        \"\"\"\n        \n\n    def sum(self, r, c, strs):\n        \"\"\"\n        :type r: int\n        :type c: str\n        :type strs: List[str]\n        :rtype: int\n        \"\"\"\n        \n\n\n# Your Excel object will be instantiated and called as such:\n# obj = Excel(H, W)\n# obj.set(r,c,v)\n# param_2 = obj.get(r,c)\n# param_3 = obj.sum(r,c,strs)"
    },
    {
      "lang": "Python3",
      "code": "class Excel:\n\n    def __init__(self, H: int, W: str):\n        \n\n    def set(self, r: int, c: str, v: int) -> None:\n        \n\n    def get(self, r: int, c: str) -> int:\n        \n\n    def sum(self, r: int, c: str, strs: List[str]) -> int:\n        \n\n\n# Your Excel object will be instantiated and called as such:\n# obj = Excel(H, W)\n# obj.set(r,c,v)\n# param_2 = obj.get(r,c)\n# param_3 = obj.sum(r,c,strs)"
    },
    {
      "lang": "C",
      "code": "\n\n\ntypedef struct {\n    \n} Excel;\n\n\nExcel* excelCreate(int H, char W) {\n    \n}\n\nvoid excelSet(Excel* obj, int r, char c, int v) {\n  \n}\n\nint excelGet(Excel* obj, int r, char c) {\n  \n}\n\nint excelSum(Excel* obj, int r, char c, char ** strs, int strsSize) {\n  \n}\n\nvoid excelFree(Excel* obj) {\n    \n}\n\n/**\n * Your Excel struct will be instantiated and called as such:\n * Excel* obj = excelCreate(H, W);\n * excelSet(obj, r, c, v);\n \n * int param_2 = excelGet(obj, r, c);\n \n * int param_3 = excelSum(obj, r, c, strs, strsSize);\n \n * excelFree(obj);\n*/"
    },
    {
      "lang": "C#",
      "code": "public class Excel {\n\n    public Excel(int H, char W) {\n        \n    }\n    \n    public void Set(int r, char c, int v) {\n        \n    }\n    \n    public int Get(int r, char c) {\n        \n    }\n    \n    public int Sum(int r, char c, string[] strs) {\n        \n    }\n}\n\n/**\n * Your Excel object will be instantiated and called as such:\n * Excel obj = new Excel(H, W);\n * obj.Set(r,c,v);\n * int param_2 = obj.Get(r,c);\n * int param_3 = obj.Sum(r,c,strs);\n */"
    },
    {
      "lang": "JavaScript",
      "code": "/**\n * @param {number} H\n * @param {character} W\n */\nvar Excel = function(H, W) {\n    \n};\n\n/** \n * @param {number} r \n * @param {character} c \n * @param {number} v\n * @return {void}\n */\nExcel.prototype.set = function(r, c, v) {\n    \n};\n\n/** \n * @param {number} r \n * @param {character} c\n * @return {number}\n */\nExcel.prototype.get = function(r, c) {\n    \n};\n\n/** \n * @param {number} r \n * @param {character} c \n * @param {string[]} strs\n * @return {number}\n */\nExcel.prototype.sum = function(r, c, strs) {\n    \n};\n\n/** \n * Your Excel object will be instantiated and called as such:\n * var obj = new Excel(H, W)\n * obj.set(r,c,v)\n * var param_2 = obj.get(r,c)\n * var param_3 = obj.sum(r,c,strs)\n */"
    },
    {
      "lang": "Ruby",
      "code": "class Excel\n\n=begin\n    :type h: Integer\n    :type w: Character\n=end\n    def initialize(h, w)\n        \n    end\n\n\n=begin\n    :type r: Integer\n    :type c: Character\n    :type v: Integer\n    :rtype: Void\n=end\n    def set(r, c, v)\n        \n    end\n\n\n=begin\n    :type r: Integer\n    :type c: Character\n    :rtype: Integer\n=end\n    def get(r, c)\n        \n    end\n\n\n=begin\n    :type r: Integer\n    :type c: Character\n    :type strs: String[]\n    :rtype: Integer\n=end\n    def sum(r, c, strs)\n        \n    end\n\n\nend\n\n# Your Excel object will be instantiated and called as such:\n# obj = Excel.new(h, w)\n# obj.set(r, c, v)\n# param_2 = obj.get(r, c)\n# param_3 = obj.sum(r, c, strs)"
    },
    {
      "lang": "Swift",
      "code": "\nclass Excel {\n\n    init(_ H: Int, _ W: Character) {\n        \n    }\n    \n    func set(_ r: Int, _ c: Character, _ v: Int) {\n        \n    }\n    \n    func get(_ r: Int, _ c: Character) -> Int {\n        \n    }\n    \n    func sum(_ r: Int, _ c: Character, _ strs: [String]) -> Int {\n        \n    }\n}\n\n/**\n * Your Excel object will be instantiated and called as such:\n * let obj = Excel(H, W)\n * obj.set(r, c, v)\n * let ret_2: Int = obj.get(r, c)\n * let ret_3: Int = obj.sum(r, c, strs)\n */"
    },
    {
      "lang": "Go",
      "code": "type Excel struct {\n    \n}\n\n\nfunc Constructor(H int, W byte) Excel {\n    \n}\n\n\nfunc (this *Excel) Set(r int, c byte, v int)  {\n    \n}\n\n\nfunc (this *Excel) Get(r int, c byte) int {\n    \n}\n\n\nfunc (this *Excel) Sum(r int, c byte, strs []string) int {\n    \n}\n\n\n/**\n * Your Excel object will be instantiated and called as such:\n * obj := Constructor(H, W);\n * obj.Set(r,c,v);\n * param_2 := obj.Get(r,c);\n * param_3 := obj.Sum(r,c,strs);\n */"
    },
    {
      "lang": "Scala",
      "code": "class Excel(_H: Int, _W: Char) {\n\n    def set(r: Int, c: Char, v: Int) {\n        \n    }\n\n    def get(r: Int, c: Char): Int = {\n        \n    }\n\n    def sum(r: Int, c: Char, strs: Array[String]): Int = {\n        \n    }\n\n}\n\n/**\n * Your Excel object will be instantiated and called as such:\n * var obj = new Excel(H, W)\n * obj.set(r,c,v)\n * var param_2 = obj.get(r,c)\n * var param_3 = obj.sum(r,c,strs)\n */"
    },
    {
      "lang": "Kotlin",
      "code": "class Excel(H: Int, W: Char) {\n\n    fun set(r: Int, c: Char, v: Int) {\n        \n    }\n\n    fun get(r: Int, c: Char): Int {\n        \n    }\n\n    fun sum(r: Int, c: Char, strs: Array<String>): Int {\n        \n    }\n\n}\n\n/**\n * Your Excel object will be instantiated and called as such:\n * var obj = Excel(H, W)\n * obj.set(r,c,v)\n * var param_2 = obj.get(r,c)\n * var param_3 = obj.sum(r,c,strs)\n */"
    },
    {
      "lang": "Rust",
      "code": "struct Excel {\n\n}\n\n\n/** \n * `&self` means the method takes an immutable reference.\n * If you need a mutable reference, change it to `&mut self` instead.\n */\nimpl Excel {\n\n    fn new(H: i32, W: char) -> Self {\n        \n    }\n    \n    fn set(&self, r: i32, c: char, v: i32) {\n        \n    }\n    \n    fn get(&self, r: i32, c: char) -> i32 {\n        \n    }\n    \n    fn sum(&self, r: i32, c: char, strs: Vec<String>) -> i32 {\n        \n    }\n}\n\n/**\n * Your Excel object will be instantiated and called as such:\n * let obj = Excel::new(H, W);\n * obj.set(r, c, v);\n * let ret_2: i32 = obj.get(r, c);\n * let ret_3: i32 = obj.sum(r, c, strs);\n */"
    },
    {
      "lang": "PHP",
      "code": "class Excel {\n    /**\n     * @param Integer $H\n     * @param String $W\n     */\n    function __construct($H, $W) {\n        \n    }\n  \n    /**\n     * @param Integer $r\n     * @param String $c\n     * @param Integer $v\n     * @return NULL\n     */\n    function set($r, $c, $v) {\n        \n    }\n  \n    /**\n     * @param Integer $r\n     * @param String $c\n     * @return Integer\n     */\n    function get($r, $c) {\n        \n    }\n  \n    /**\n     * @param Integer $r\n     * @param String $c\n     * @param String[] $strs\n     * @return Integer\n     */\n    function sum($r, $c, $strs) {\n        \n    }\n}\n\n/**\n * Your Excel object will be instantiated and called as such:\n * $obj = Excel($H, $W);\n * $obj->set($r, $c, $v);\n * $ret_2 = $obj->get($r, $c);\n * $ret_3 = $obj->sum($r, $c, $strs);\n */"
    }
  ],
  "stats": "{\"totalAccepted\": \"3.5K\", \"totalSubmission\": \"11.6K\", \"totalAcceptedRaw\": 3516, \"totalSubmissionRaw\": 11556, \"acRate\": \"30.4%\"}",
  "hints": [],
  "solution": {
    "id": "187",
    "canSeeDetail": true,
    "url": "/articles/design-excel-sum-formula/",
    "content": "[TOC]\n\n## Solution\n\n---\n#### Approach 1: Topological Sort\n\nBefore discussing the required design, we'll discuss some prerequisites to help ease the understanding of the solution. \n\nFirstly, we can note that once a formula is applied to any cell in excel, let's say $$C1 = C2 + C3$$, if any change is made to $$C2$$ or $$C3$$, the result to be put into $$C1$$ needs to be evaluated again based on the new values of $$C2$$ and $$C3$$. Further, suppose some other cell, say $$D2$$ is also dependent on $$C1$$ due to some prior formula applied to $$D2$$. Then, when any change is made to, say, $$C2$$, we re-evaluate $$C1$$'s value. Furhter, since $$D2$$ is dependent on $$C1$$, we need to re-evaluate $$D2$$'s value as well. \n\nThus, whenever, we make any change to any cell, $$x$$,  we need to determine the cells which are dependent on $$x$$, and update these cells, and further determine the cells which are dependent on the changed cells and so on. We can assume that no cycles are present in the formulas, i.e. Any cell's value won't directly or indirectly be dependent on its own value. \n\nBut, while doing these set of evaluations of the cells to determine their updated values, we need to update the cells in such an order that the cell on which some other cell is dependent is always evaluated prior to the cell which is dependent on the former cell.\n\nIn order to do so, we can view the dependence between the cells in the form of a dependency graph, which can be a Directed Graph. Since, no cycles are allowed between the formulas, the graph reduces to a Directed Acyclic Graph. Now, to solve the problem of evaluating the cells in the required order, we can make use of a very well known method specifically used for such problems in Directed Acyclic Graphs, known as the Topological Sorting. \n\nTopological sorting for Directed Acyclic Graph (DAG) is a linear ordering of vertices such that for every directed edge $$uv$$, vertex $$u$$ comes before $$v$$ in the ordering. For example, a topological sorting of the following graph is `5 4 2 3 1 0`. \n\nThere can be more than one topological sorting for a graph. For example, another topological sorting of the following graph is `4 5 2 3 1 0`. The first vertex in topological sorting is always a vertex with in-degree as 0 (a vertex with no in-coming edges).\n\n![Topological_Sort_Graph](../Figures/631/631_Design_Excel.PNG)\n{:align=\"center\"}\n\nTopological Sorting can be done if we modify the Depth First Search to some extent.  In Depth First Search, we start from a vertex, we first print it and then recursively call DFS for its adjacent vertices. Thus, the DFS obtained for the graph above, starting from node 5, will be `5 2 3 1 0 4`. But, in the case of a topological sort, we can't print a node until all the nodes on which it is dependent have already been printed. \n\nTo solve this problem, we make use of a temporary stack. We do the traversals in the same manner as in DFS, but  we donâ€™t print the current node immediately. Instead, for the current node we do as follows:\n\n* Recursively call topological sorting for all the nodes adjacent to the current node.\n\n* Push the current node onto a stack. \n\n* Repeat the above process till all the nodes have been considered atleast once. \n\n* Print the contents of the stack. \n\nNote that a vertex is pushed to stack only when all of its adjacent(dependent) vertices (and their adjacent(dependent) vertices and so on) are already in stack. Thus, we obtain the correct ordering of the vertices. \n\nThe following animation shows an example of topological sorting for the graph above.\n\n!?!../Documents/631_Topological.json:1000,563!?!\n\nWe can make use of the same concept while evaluating the cell values to determine the order in which they need to be evaluated. \n\nNow, let's discuss how we implement the various required functions. We make use of a simple structure(Class), $$Formula$$, which contains two elements. First, the value of the cell which it represents, $$val$$, and a HashMap, $$cells$$. It is a list of cells on which the current cell's value is dependent. This $$cells$$ hashmap stores the data in the form $$(cellName, count)$$.  $$cellName$$ has the format $$ColRow$$. $$count$$ refers to the number of times the current cell directly or indirectly comes in the current cell's formulas. e.g. $$C1 = C2 + C3 + C2$$. In this case, the frequency of $$C3$$ is 1 and that of $$C2$$ is 2.\n\n* `Excel(int H, char W)` : We simply need to initialize an array of $$Formula$$ with $$H$$ rows and the required number of columns corresponding to $$W$$.\n\n* `set(int row, char column, int val)` : For setting the value of the cell corresponding to the given $$row$$ and $$column$$, we can simply change the value , $$val$$, in the $$Formulas$$ array at the indices corresponding to the current cell. Further, if any new formula is applied to a particular cell, we need to remove  the previously applied formulas on the same cell. This is because two formulas can't be used to determine the value of a cell simultaneously. Now, setting a cell to a particular value can also be seen as a formula e.g. $$C1 = 2$$. Thus, we remove all the $$cells$$ in the $$Formulas$$ for the current cell. Further, when the current cell's value is changed, all the other cells which are dependent on it also need to be evaluated in the correct order. Thus, we make use of Topological Sorting starting with the current cell. We make use of a function `topologicalSort(r, c)` for this purpose.\n\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;`topologicalSort(r, c)`: In every call to this function, we traverse over all the cells in the $$Formulas$$ array and further apply topological sorting to all the &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cells which are dependent on the current cell(row=r, column=c). To find these cells, we can check the $$cells$$ in the $$Formulas$$ associated with each cell &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;and check if the current cell lies in it. After applying Topological sorting to all these dependent cells, we put the current cell onto a $$stack$$. \n\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;After doing the topological sorting, the cells on the $$stack$$ lie in the order in which their values should be evaluated given the current dependency chain &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;based on the formulas applied. Thus, we pick up these cells one by one, and evaluate their values. To do the evaluation, we make use of &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;`calculate_sum(r, c, cells)`. In this function, we traverse over all the $$cells$$ in the $$Formulas$$ of the current cell(row=r, column=c), and keep on adding &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;their values. When this summing has been done, we update the current cell's value, $$val$$, to the sum just obtained. We keep on doing so till all the cells in &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;the $$stack$$ have been evaluated.\n\n* `get(int row, char column)` : We can simply obtain the value($$val$$) associated with the current cell's $$Formulas$$. If the cell has never been initialized previously, we can return a 0 value.\n\n* `sum(int row, char column, List of Strings : numbers)` : To implement this function, firstly, we need to expand the given $$numbers$$ to obtain all the cells which need to be added in the current formula. We obtain them, by making use of a `convert` function, which extracts all these cells by doing appropriate expansions based on `:` values. We put all these cells in the $$cells$$ associated with the current cell's $$Formulas$$. We also need to set the current cell's value to a new value based on the current formula added. For this, we make use of `calculate_sum` function as discussed above. We also need to do the topological sorting and evaluate all the cells dependent on the current cell. This is done in the same manner as in the `set` function discussed above. We also need to return the value to which the current cell has been set.\n\n\n<iframe src=\"https://leetcode.com/playground/yqYGNTu4/shared\" frameBorder=\"0\" width=\"100%\" height=\"500\" name=\"yqYGNTu4\"></iframe>\n\n**Performance Analysis**\n\n* `set` takes $$O\\big((r*c)^2\\big)$$ time. Here, $$r$$ and $$c$$ refer to the number of rows and columns in the current Excel Form. There can be a maximum of $$O(r*c)$$ formulas for an Excel Form with $$r$$ rows and $$c$$ columns. For each formula, $$r*c$$ time will be needed to find the dependent nodes. Thus, in the worst case, a total of $$O\\big((r*c)^2\\big)$$ will be needed.\n\n* `sum` takes $$O\\big((r*c)^2 + 2*r*c*l\\big)$$ time. Here, $$l$$ refers to the number of elements in the  the list of strings used for obtaining the cells required for the current sum. In the worst case, the expansion of each such element requires $$O(r*c)$$ time, leading to $$O(l*r*c)$$ time for expanding $$l$$ such elements. After doing the expansion, `calculate_sum` itself requires $$O(l*r*c)$$ time for traversing over the required elements for obtaining the sum. After this, we need to update all the dependent cells, which requires the use of `set` which itself requires $$O\\big((r*c)^2\\big)$$ time.\n\n* `get` takes $$O(1)$$ time. \n\n* The space required will be $$O\\big((r*c)^2\\big)$$ in the worst case. $$O(r*c)$$ space will be required for the Excel Form itself. For each cell in this form, the $$cells$$ list can contain $$O(r*c)$$ cells.\n\n---\nAnalysis written by: [@vinod23](https://leetcode.com/vinod23)",
    "contentTypeId": "107",
    "rating": {
      "id": "182",
      "count": 8,
      "average": 4.5,
      "userRating": null
    }
  },
  "status": null,
  "sampleTestCase": "[\"Excel\",\"get\",\"set\",\"get\"]\n[[3,\"C\"],[1,\"A\"],[1,\"A\",1],[1,\"A\"]]",
  "metaData": "{\r\n    \"classname\": \"Excel\",\r\n    \"maxbytesperline\": 200000,\r\n    \"constructor\": {\r\n        \"params\": [\r\n        {\r\n            \"type\":\"integer\",\r\n            \"name\":\"H\"\r\n        },\r\n        {\r\n            \"type\": \"character\",\r\n            \"name\": \"W\"\r\n        }\r\n        ]\r\n    },\r\n    \"methods\": [\r\n        {\r\n            \"name\" : \"set\",\r\n            \"params\": [\r\n                {\r\n                    \"type\": \"integer\",\r\n                    \"name\": \"r\"\r\n                },\r\n                {\r\n                    \"type\": \"character\",\r\n                    \"name\": \"c\"\r\n                },\r\n                {\r\n                    \"type\": \"integer\",\r\n                    \"name\": \"v\"\r\n                }\r\n            ],\r\n            \"return\": {\r\n                \"type\": \"void\"\r\n            }\r\n        },\r\n        {\r\n            \"name\" : \"get\",\r\n            \"params\": [\r\n                {\r\n                    \"type\": \"integer\",\r\n                    \"name\": \"r\"\r\n                },\r\n                {\r\n                    \"type\": \"character\",\r\n                    \"name\": \"c\"\r\n                }\r\n            ],\r\n            \"return\": {\r\n                \"type\": \"integer\"\r\n            }\r\n        },\r\n        {\r\n            \"name\" : \"sum\",\r\n            \"params\": [\r\n                {\r\n                    \"type\": \"integer\",\r\n                    \"name\": \"r\"\r\n                },\r\n                {\r\n                    \"type\": \"character\",\r\n                    \"name\": \"c\"\r\n                },\r\n                {\r\n                    \"type\": \"string[]\",\r\n                    \"name\": \"strs\"\r\n                },\r\n                {\r\n                    \"type\": \"integer\",\r\n                    \"name\": \"strsSize\",\r\n                    \"lang\": \"c\",\r\n                    \"value\": \"size_3\"\r\n                }\r\n            ],\r\n            \"return\": {\r\n                \"type\": \"integer\"\r\n            }\r\n        }\r\n    ],\r\n    \"systemdesign\": true,\r\n    \"params\": [\r\n        {\r\n            \"name\": \"inputs\",\r\n            \"type\": \"integer[]\"\r\n        },\r\n        {\r\n            \"name\": \"inputs\",\r\n            \"type\": \"integer[]\"\r\n        }\r\n    ],\r\n    \"return\": {\r\n        \"type\": \"list<String>\",\r\n        \"dealloc\": true\r\n    }\r\n}",
  "judgerAvailable": true,
  "judgeType": "large",
  "mysqlSchemas": [],
  "enableRunCode": true,
  "enableTestMode": false,
  "libraryUrl": null
}
