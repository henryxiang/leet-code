{
  "questionId": "656",
  "questionFrontendId": "656",
  "boundTopicId": null,
  "title": "Coin Path",
  "titleSlug": "coin-path",
  "categoryTitle": "Algorithms",
  "content": "<p>Given an array <code>A</code> (index starts at <code>1</code>) consisting of N integers: A<sub>1</sub>, A<sub>2</sub>, ..., A<sub>N</sub>&nbsp;and an integer <code>B</code>. The integer <code>B</code> denotes that from any place (suppose the index is <code>i</code>) in the array <code>A</code>, you can jump to any one of the place in the array <code>A</code> indexed <code>i+1</code>, <code>i+2</code>, &hellip;, <code>i+B</code> if this place can be jumped to. Also, if you step on the index <code>i</code>, you have to pay A<sub>i</sub>&nbsp;coins. If A<sub>i</sub>&nbsp;is -1, it means you can&rsquo;t jump to the place indexed <code>i</code> in the array.</p>\r\n\r\n<p>Now, you start from the place indexed <code>1</code> in the array <code>A</code>, and your aim is to reach the place indexed <code>N</code> using the minimum coins. You need to return the path of indexes (starting from 1 to N) in the array you should take to get to the place indexed <code>N</code> using minimum coins.</p>\r\n\r\n<p>If there are multiple paths with the same cost, return the lexicographically smallest such path.</p>\r\n\r\n<p>If it&#39;s not possible to reach the place indexed N then you need to return an empty array.</p>\r\n\r\n<p><b>Example 1:</b></p>\r\n\r\n<pre>\r\n<b>Input:</b> [1,2,4,-1,2], 2\r\n<b>Output:</b> [1,3,5]\r\n</pre>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p><b>Example 2:</b></p>\r\n\r\n<pre>\r\n<b>Input:</b> [1,2,4,-1,2], 1\r\n<b>Output:</b> []\r\n</pre>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p><b>Note:</b></p>\r\n\r\n<ol>\r\n\t<li>Path Pa<sub>1</sub>, Pa<sub>2</sub>, ..., Pa<sub>n</sub>&nbsp;is lexicographically smaller than Pb<sub>1</sub>, Pb<sub>2</sub>, ..., Pb<sub>m</sub>, if and only if at the first <code>i</code> where Pa<sub>i</sub>&nbsp;and Pb<sub>i</sub>&nbsp;differ, Pa<sub>i</sub>&nbsp;&lt; Pb<sub>i</sub>; when no such&nbsp;<code>i</code>&nbsp;exists, then&nbsp;<code>n</code> &lt; <code>m</code>.</li>\r\n\t<li>A<sub>1</sub> &gt;= 0. A<sub>2</sub>, ..., A<sub>N</sub> (if exist) will in the range of [-1, 100].</li>\r\n\t<li>Length of A is in the range of [1, 1000].</li>\r\n\t<li>B is in the range of [1, 100].</li>\r\n</ol>\r\n\r\n<p>&nbsp;</p>\r\n",
  "isPaidOnly": true,
  "difficulty": "Hard",
  "likes": 136,
  "dislikes": 76,
  "isLiked": null,
  "similarQuestions": "[{\"title\": \"House Robber\", \"titleSlug\": \"house-robber\", \"difficulty\": \"Easy\", \"translatedTitle\": null}, {\"title\": \"House Robber II\", \"titleSlug\": \"house-robber-ii\", \"difficulty\": \"Medium\", \"translatedTitle\": null}]",
  "contributors": [
    {
      "username": "todayhardtomorrowsunshine",
      "profileUrl": "/todayhardtomorrowsunshine/",
      "avatarUrl": "https://www.gravatar.com/avatar/8ddf26559e6656366918652f079caaf1.png?s=200"
    }
  ],
  "topicTags": [
    {
      "name": "Dynamic Programming",
      "slug": "dynamic-programming"
    }
  ],
  "companyTagStats": "{\"3\": [{\"taggedByAdmin\": true, \"name\": \"Google\", \"slug\": \"google\", \"timesEncountered\": 0}], \"1\": [], \"2\": []}",
  "codeSnippets": [
    {
      "lang": "C++",
      "code": "class Solution {\npublic:\n    vector<int> cheapestJump(vector<int>& A, int B) {\n        \n    }\n};"
    },
    {
      "lang": "Java",
      "code": "class Solution {\n    public List<Integer> cheapestJump(int[] A, int B) {\n        \n    }\n}"
    },
    {
      "lang": "Python",
      "code": "class Solution(object):\n    def cheapestJump(self, A, B):\n        \"\"\"\n        :type A: List[int]\n        :type B: int\n        :rtype: List[int]\n        \"\"\"\n        "
    },
    {
      "lang": "Python3",
      "code": "class Solution:\n    def cheapestJump(self, A: List[int], B: int) -> List[int]:\n        "
    },
    {
      "lang": "C",
      "code": "\n\n/**\n * Note: The returned array must be malloced, assume caller calls free().\n */\nint* cheapestJump(int* A, int ASize, int B, int* returnSize){\n\n}\n\n"
    },
    {
      "lang": "C#",
      "code": "public class Solution {\n    public IList<int> CheapestJump(int[] A, int B) {\n        \n    }\n}"
    },
    {
      "lang": "JavaScript",
      "code": "/**\n * @param {number[]} A\n * @param {number} B\n * @return {number[]}\n */\nvar cheapestJump = function(A, B) {\n    \n};"
    },
    {
      "lang": "Ruby",
      "code": "# @param {Integer[]} a\n# @param {Integer} b\n# @return {Integer[]}\ndef cheapest_jump(a, b)\n    \nend"
    },
    {
      "lang": "Swift",
      "code": "class Solution {\n    func cheapestJump(_ A: [Int], _ B: Int) -> [Int] {\n        \n    }\n}"
    },
    {
      "lang": "Go",
      "code": "func cheapestJump(A []int, B int) []int {\n    \n}"
    },
    {
      "lang": "Scala",
      "code": "object Solution {\n    def cheapestJump(A: Array[Int], B: Int): List[Int] = {\n        \n    }\n}"
    },
    {
      "lang": "Kotlin",
      "code": "class Solution {\n    fun cheapestJump(A: IntArray, B: Int): List<Int> {\n        \n    }\n}"
    },
    {
      "lang": "Rust",
      "code": "impl Solution {\n    pub fn cheapest_jump(a: Vec<i32>, b: i32) -> Vec<i32> {\n        \n    }\n}"
    },
    {
      "lang": "PHP",
      "code": "class Solution {\n\n    /**\n     * @param Integer[] $A\n     * @param Integer $B\n     * @return Integer[]\n     */\n    function cheapestJump($A, $B) {\n        \n    }\n}"
    }
  ],
  "stats": "{\"totalAccepted\": \"7.8K\", \"totalSubmission\": \"28.2K\", \"totalAcceptedRaw\": 7839, \"totalSubmissionRaw\": 28159, \"acRate\": \"27.8%\"}",
  "hints": [],
  "solution": {
    "id": "228",
    "canSeeDetail": true,
    "url": "/articles/coin-path/",
    "content": "[TOC]\n\n\n## Solution\n\n---\n#### Approach #1 Brute Force[Time Limit Exceeded]\n\nIn this approach, we make use of a $$next$$ array of size $$n$$. Here, $$n$$ refers to the size of the given $$A$$ array. The array $$nums$$ is used such that $$nums[i]$$ is used to store the minimum number of coins needed to jump till the end of the array $$A$$, starting from the index $$i$$. \n\nWe start by filling the $$next$$ array with all -1's. Then, in order to fill this $$next$$ array, we make use of a recursive function `jump(A, B, i, next)` which fills the $$next$$ array starting from the index $$i$$ onwards, given $$A$$ as the coins array and $$B$$ as the largest jump value.\n\nWith $$i$$ as the current index, we can consider every possible index from $$i+1$$ to $$i+B$$ as the next place to be jumped to. For every such next index, $$j$$, if this place can be jumped to, we determine the cost of reaching the end of the array starting from the index $$i$$, and with $$j$$ as the next index jumped from $$i$$, as  $$A[i] + jump(A, B, j, next)$$. If this cost is lesser than the minimum cost required till now, for the same starting index, we can update the minimum cost and the value of $$next[i]$$ as well. \n\nFor every such function call, we also need to return this minimum cost.\n\nAt the end, we traverse over the $$next$$ array starting from the index 1. At every step, we add the current index to the $$res$$ list to be returned and also jump/move to the index pointed by $$next[i]$$, since this refers to the next index for the minimum cost. We continue in the same manner till we reach the end of the array $$A$$.\n\n<iframe src=\"https://leetcode.com/playground/9tcSoGzo/shared\" frameBorder=\"0\" name=\"9tcSoGzo\" width=\"100%\" height=\"515\"></iframe>\n\n**Complexity Analysis**\n\n* Time complexity : $$O(B^n)$$. The size of the recursive tree can grow upto $$O(b^n)$$ in the worst case. This is because, we have $$B$$ possible branches at every step. Here, $$B$$ refers to the limit of the largest jump and $$n$$ refers to the size of the given $$A$$ array. \n\n* Space complexity : $$O(n)$$. The depth of the recursive tree can grow upto $$n$$. $$next$$ array of size $$n$$ is used.\n\n---\n#### Approach #2 Using Memoization [Accepted]\n\n**Algorithm**\n\nIn the recursive solution just discussed, a lot of duplicate function calls are made, since we are considering the same index through multiple paths. To remove this redundancy, we can make use of memoization.\n\nWe keep a $$memo$$ array, such that $$memo[i]$$ is used to store the minimum cost of jumps to reach the end of the array $$A$$. Whenever the value for any index is calculated once, it is stored in its appropriate location. Thus, next time whenever the same function call is made, we can return the result directly from this $$memo$$ array, pruning the search space to a great extent.\n\n<iframe src=\"https://leetcode.com/playground/mAVq4r5H/shared\" frameBorder=\"0\" name=\"mAVq4r5H\" width=\"100%\" height=\"515\"></iframe>\n\n**Complexity Analysis**\n\n* Time complexity : $$O(nB)$$. $$memo$$ array of size $$n$$ is filled only once. We also do a traversal over the $$next$$ array, which will go upto $$B$$ steps.  Here, $$n$$ refers to the number of nodes in the given tree.\n\n* Space complexity : $$O(n)$$. The depth of the recursive tree can grow upto $$n$$. $$next$$ array of size $$n$$ is used.\n\n---\n#### Approach #3 Using Dynamic Programming [Accepted]\n\n**Algorithm**\n\nFrom the solutions discussed above, we can observe that the cost of jumping till the end of the array $$A$$ starting from the index $$i$$ is only dependent on the elements following the index $$i$$ and not the ones before it. This inspires us to make use of Dynamic Programming to solve the current problem.\n\nWe again make use of a $$next$$ array to store the next jump locations. We also make use of a $$dp$$ with the same size as that of the given $$A$$ array. $$dp[i]$$ is used to store the minimum cost of jumping till the end of the array $$A$$, starting from the index $$i$$. We start with the last index as the current index and proceed backwards for filling the $$next$$ and $$dp$$ array.\n\nWith $$i$$ as the current index, we consider all the next possible positions from $$i+1$$, $$i+2$$,..., $$i+B$$, and determine the position, $$j$$,  which leads to a minimum cost of reaching the end of $$A$$, which is given by $$A[i]+dp[j]$$. We update $$next[i]$$ with this corresponding index. We also update $$dp[i]$$ with the minimum cost, to be used by the previous indices' cost calculations.\n\nAt the end, we again jump over the indices as per the $$next$$ array and put these indices in the $$res$$ array to be returned.\n\n<iframe src=\"https://leetcode.com/playground/BMCVq3jo/shared\" frameBorder=\"0\" name=\"BMCVq3jo\" width=\"100%\" height=\"515\"></iframe>\n\n**Complexity Analysis**\n\n* Time complexity : $$O(nB)$$. We need to consider all the possible $$B$$ positions for every current index considered in the $$A$$ array. Here, $$A$$ refers to the number of elements in $$A$$.\n\n* Space complexity : $$O(n)$$. $$dp$$ and $$next$$ array of size $$n$$ are used.\n\n---\n\n\nAnalysis written by: [@vinod23](https://leetcode.com/vinod23)",
    "contentTypeId": "107",
    "rating": {
      "id": "223",
      "count": 11,
      "average": 4.455,
      "userRating": null
    }
  },
  "status": null,
  "sampleTestCase": "[1,2,4,-1,2]\n2",
  "metaData": "{\r\n  \"name\": \"cheapestJump\",\r\n  \"params\": [\r\n    {\r\n      \"name\": \"A\",\r\n      \"type\": \"integer[]\"\r\n    },\r\n    {\r\n      \"name\": \"B\",\r\n      \"type\": \"integer\"\r\n    }\r\n  ],\r\n  \"return\": {\r\n    \"type\": \"list<integer>\"\r\n  }\r\n}\r\n",
  "judgerAvailable": true,
  "judgeType": "large",
  "mysqlSchemas": [],
  "enableRunCode": true,
  "enableTestMode": false,
  "libraryUrl": null
}
