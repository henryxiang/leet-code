{
  "questionId": "663",
  "questionFrontendId": "663",
  "boundTopicId": null,
  "title": "Equal Tree Partition",
  "titleSlug": "equal-tree-partition",
  "categoryTitle": "Algorithms",
  "content": "<p>\r\nGiven a binary tree with <code>n</code> nodes, your task is to check if it's possible to partition the tree to two trees which have the equal sum of values after removing <b>exactly</b> one edge on the original tree.\r\n</p>\r\n\r\n<p><b>Example 1:</b><br />\r\n<pre>\r\n<b>Input:</b>     \r\n    5\r\n   / \\\r\n  10 10\r\n    /  \\\r\n   2   3\r\n\r\n<b>Output:</b> True\r\n<b>Explanation:</b> \r\n    5\r\n   / \r\n  10\r\n      \r\nSum: 15\r\n\r\n   10\r\n  /  \\\r\n 2    3\r\n\r\nSum: 15\r\n</pre>\r\n</p>\r\n\r\n\r\n<p><b>Example 2:</b><br />\r\n<pre>\r\n<b>Input:</b>     \r\n    1\r\n   / \\\r\n  2  10\r\n    /  \\\r\n   2   20\r\n\r\n<b>Output:</b> False\r\n<b>Explanation:</b> You can't split the tree into two trees with equal sum after removing exactly one edge on the tree.\r\n</pre>\r\n</p>\r\n\r\n<p><b>Note:</b><br>\r\n<ol>\r\n<li>The range of tree node value is in the range of [-100000, 100000].</li>\r\n<li>1 <= n <= 10000</li>\r\n</ol>\r\n</p>",
  "isPaidOnly": true,
  "difficulty": "Medium",
  "likes": 255,
  "dislikes": 20,
  "isLiked": null,
  "similarQuestions": "[]",
  "contributors": [
    {
      "username": "Stomach_ache",
      "profileUrl": "/stomach_ache/",
      "avatarUrl": "https://assets.leetcode.com/users/stomach_ache/avatar_1550751028.png"
    }
  ],
  "topicTags": [
    {
      "name": "Tree",
      "slug": "tree"
    }
  ],
  "companyTagStats": "{\"3\": [{\"taggedByAdmin\": false, \"name\": \"Facebook\", \"slug\": \"facebook\", \"timesEncountered\": 2}, {\"taggedByAdmin\": true, \"name\": \"Amazon\", \"slug\": \"amazon\", \"timesEncountered\": 0}], \"1\": [], \"2\": []}",
  "codeSnippets": [
    {
      "lang": "C++",
      "code": "/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\n * };\n */\nclass Solution {\npublic:\n    bool checkEqualTree(TreeNode* root) {\n        \n    }\n};"
    },
    {
      "lang": "Java",
      "code": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode(int x) { val = x; }\n * }\n */\nclass Solution {\n    public boolean checkEqualTree(TreeNode root) {\n        \n    }\n}"
    },
    {
      "lang": "Python",
      "code": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, x):\n#         self.val = x\n#         self.left = None\n#         self.right = None\n\nclass Solution(object):\n    def checkEqualTree(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: bool\n        \"\"\"\n        "
    },
    {
      "lang": "Python3",
      "code": "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, x):\n#         self.val = x\n#         self.left = None\n#         self.right = None\n\nclass Solution:\n    def checkEqualTree(self, root: TreeNode) -> bool:\n        "
    },
    {
      "lang": "C",
      "code": "/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     struct TreeNode *left;\n *     struct TreeNode *right;\n * };\n */\n\n\nbool checkEqualTree(struct TreeNode* root){\n\n}\n\n"
    },
    {
      "lang": "C#",
      "code": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     public int val;\n *     public TreeNode left;\n *     public TreeNode right;\n *     public TreeNode(int x) { val = x; }\n * }\n */\npublic class Solution {\n    public bool CheckEqualTree(TreeNode root) {\n        \n    }\n}"
    },
    {
      "lang": "JavaScript",
      "code": "/**\n * Definition for a binary tree node.\n * function TreeNode(val) {\n *     this.val = val;\n *     this.left = this.right = null;\n * }\n */\n/**\n * @param {TreeNode} root\n * @return {boolean}\n */\nvar checkEqualTree = function(root) {\n    \n};"
    },
    {
      "lang": "Ruby",
      "code": "# Definition for a binary tree node.\n# class TreeNode\n#     attr_accessor :val, :left, :right\n#     def initialize(val)\n#         @val = val\n#         @left, @right = nil, nil\n#     end\n# end\n\n# @param {TreeNode} root\n# @return {Boolean}\ndef check_equal_tree(root)\n    \nend"
    },
    {
      "lang": "Swift",
      "code": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     public var val: Int\n *     public var left: TreeNode?\n *     public var right: TreeNode?\n *     public init(_ val: Int) {\n *         self.val = val\n *         self.left = nil\n *         self.right = nil\n *     }\n * }\n */\nclass Solution {\n    func checkEqualTree(_ root: TreeNode?) -> Bool {\n        \n    }\n}"
    },
    {
      "lang": "Go",
      "code": "/**\n * Definition for a binary tree node.\n * type TreeNode struct {\n *     Val int\n *     Left *TreeNode\n *     Right *TreeNode\n * }\n */\nfunc checkEqualTree(root *TreeNode) bool {\n    \n}"
    },
    {
      "lang": "Scala",
      "code": "/**\n * Definition for a binary tree node.\n * class TreeNode(var _value: Int) {\n *   var value: Int = _value\n *   var left: TreeNode = null\n *   var right: TreeNode = null\n * }\n */\nobject Solution {\n    def checkEqualTree(root: TreeNode): Boolean = {\n        \n    }\n}"
    },
    {
      "lang": "Kotlin",
      "code": "/**\n * Example:\n * var ti = TreeNode(5)\n * var v = ti.`val`\n * Definition for a binary tree node.\n * class TreeNode(var `val`: Int) {\n *     var left: TreeNode? = null\n *     var right: TreeNode? = null\n * }\n */\nclass Solution {\n    fun checkEqualTree(root: TreeNode?): Boolean {\n        \n    }\n}"
    },
    {
      "lang": "Rust",
      "code": "// Definition for a binary tree node.\n// #[derive(Debug, PartialEq, Eq)]\n// pub struct TreeNode {\n//   pub val: i32,\n//   pub left: Option<Rc<RefCell<TreeNode>>>,\n//   pub right: Option<Rc<RefCell<TreeNode>>>,\n// }\n// \n// impl TreeNode {\n//   #[inline]\n//   pub fn new(val: i32) -> Self {\n//     TreeNode {\n//       val,\n//       left: None,\n//       right: None\n//     }\n//   }\n// }\nuse std::rc::Rc;\nuse std::cell::RefCell;\nimpl Solution {\n    pub fn check_equal_tree(root: Option<Rc<RefCell<TreeNode>>>) -> bool {\n        \n    }\n}"
    },
    {
      "lang": "PHP",
      "code": "/**\n * Definition for a binary tree node.\n * class TreeNode {\n *     public $val = null;\n *     public $left = null;\n *     public $right = null;\n *     function __construct($value) { $this->val = $value; }\n * }\n */\nclass Solution {\n\n    /**\n     * @param TreeNode $root\n     * @return Boolean\n     */\n    function checkEqualTree($root) {\n        \n    }\n}"
    }
  ],
  "stats": "{\"totalAccepted\": \"16.1K\", \"totalSubmission\": \"41.6K\", \"totalAcceptedRaw\": 16137, \"totalSubmissionRaw\": 41624, \"acRate\": \"38.8%\"}",
  "hints": [],
  "solution": {
    "id": "325",
    "canSeeDetail": true,
    "url": "/articles/equal-tree-partition/",
    "content": "[TOC]\n\n#### Approach #1: Depth-First Search [Accepted]\n\n**Intuition and Algorithm**\n\nAfter removing some edge from `parent` to `child`, (where the `child` cannot be the original `root`) the subtree rooted at `child` must be half the sum of the entire tree.\n\nLet's record the sum of every subtree.  We can do this recursively using depth-first search.  After, we should check that half the sum of the entire tree occurs somewhere in our recording (and not from the total of the entire tree.)\n\nOur careful treatment and analysis above prevented errors in the case of these trees:\n```python\n  0\n / \\\n-1  1\n\n 0\n  \\\n   0\n```\n\n<iframe src=\"https://leetcode.com/playground/PfHZumnG/shared\" frameBorder=\"0\" width=\"100%\" height=\"378\" name=\"PfHZumnG\"></iframe>\n\n**Complexity Analysis**\n\n* Time Complexity: $$O(N)$$ where $$N$$ is the number of nodes in the input tree.  We traverse every node.\n\n* Space Complexity: $$O(N)$$, the size of `seen` and the implicit call stack in our DFS.\n\n---\n\nAnalysis written by: [@awice](https://leetcode.com/awice).",
    "contentTypeId": "107",
    "rating": {
      "id": "320",
      "count": 10,
      "average": 4.7,
      "userRating": null
    }
  },
  "status": null,
  "sampleTestCase": "[5,10,10,null,null,2,3]",
  "metaData": "{\r\n  \"name\": \"checkEqualTree\",\r\n  \"params\": [\r\n    {\r\n      \"name\": \"root\",\r\n      \"type\": \"TreeNode\"\r\n    }\r\n  ],\r\n  \"return\": {\r\n    \"type\": \"boolean\"\r\n  }\r\n}\r\n",
  "judgerAvailable": true,
  "judgeType": "large",
  "mysqlSchemas": [],
  "enableRunCode": true,
  "enableTestMode": false,
  "libraryUrl": null
}
