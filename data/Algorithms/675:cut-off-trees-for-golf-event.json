{
  "questionId": "675",
  "questionFrontendId": "675",
  "boundTopicId": null,
  "title": "Cut Off Trees for Golf Event",
  "titleSlug": "cut-off-trees-for-golf-event",
  "categoryTitle": "Algorithms",
  "content": "<p>You are asked to cut off trees in a forest for a golf event. The forest is represented as a non-negative 2D map, in this map:</p>\r\n\r\n<ol>\r\n\t<li><code>0</code> represents the <code>obstacle</code> can&#39;t be reached.</li>\r\n\t<li><code>1</code> represents the <code>ground</code> can be walked through.</li>\r\n\t<li><code>The place with number bigger than 1</code> represents a <code>tree</code> can be walked through, and this positive number represents the tree&#39;s height.</li>\r\n</ol>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p>You are asked to cut off <b>all</b> the trees in this forest in the order of tree&#39;s height - always cut off the tree with lowest height first. And after cutting, the original place has the tree will become a grass (value 1).</p>\r\n\r\n<p>You will start from the point (0, 0) and you should output the minimum steps <b>you need to walk</b> to cut off all the trees. If you can&#39;t cut off all the trees, output -1 in that situation.</p>\r\n\r\n<p>You are guaranteed that no two <code>trees</code> have the same height and there is at least one tree needs to be cut off.</p>\r\n\r\n<p><b>Example 1:</b></p>\r\n\r\n<pre>\r\n<b>Input:</b> \r\n[\r\n [1,2,3],\r\n [0,0,4],\r\n [7,6,5]\r\n]\r\n<b>Output:</b> 6\r\n</pre>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p><b>Example 2:</b></p>\r\n\r\n<pre>\r\n<b>Input:</b> \r\n[\r\n [1,2,3],\r\n [0,0,0],\r\n [7,6,5]\r\n]\r\n<b>Output:</b> -1\r\n</pre>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p><b>Example 3:</b></p>\r\n\r\n<pre>\r\n<b>Input:</b> \r\n[\r\n [2,3,4],\r\n [0,0,5],\r\n [8,7,6]\r\n]\r\n<b>Output:</b> 6\r\n<b>Explanation:</b> You started from the point (0,0) and you can cut off the tree in (0,0) directly without walking.\r\n</pre>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p><b>Hint</b>: size of the given matrix will not exceed 50x50.</p>\r\n",
  "isPaidOnly": false,
  "difficulty": "Hard",
  "likes": 397,
  "dislikes": 233,
  "isLiked": null,
  "similarQuestions": "[]",
  "contributors": [
    {
      "username": "just_not_over_12",
      "profileUrl": "/just_not_over_12/",
      "avatarUrl": "https://www.gravatar.com/avatar/464d04f3923cca7da1660e31335cd246.png?s=200"
    }
  ],
  "topicTags": [
    {
      "name": "Breadth-first Search",
      "slug": "breadth-first-search"
    }
  ],
  "companyTagStats": "{\"1\": [{\"taggedByAdmin\": true, \"name\": \"Amazon\", \"slug\": \"amazon\", \"timesEncountered\": 5}], \"2\": [], \"3\": []}",
  "codeSnippets": [
    {
      "lang": "C++",
      "code": "class Solution {\npublic:\n    int cutOffTree(vector<vector<int>>& forest) {\n        \n    }\n};"
    },
    {
      "lang": "Java",
      "code": "class Solution {\n    public int cutOffTree(List<List<Integer>> forest) {\n        \n    }\n}"
    },
    {
      "lang": "Python",
      "code": "class Solution(object):\n    def cutOffTree(self, forest):\n        \"\"\"\n        :type forest: List[List[int]]\n        :rtype: int\n        \"\"\"\n        "
    },
    {
      "lang": "Python3",
      "code": "class Solution:\n    def cutOffTree(self, forest: List[List[int]]) -> int:\n        "
    },
    {
      "lang": "C",
      "code": "\n\nint cutOffTree(int** forest, int forestSize, int* forestColSize){\n\n}\n\n"
    },
    {
      "lang": "C#",
      "code": "public class Solution {\n    public int CutOffTree(IList<IList<int>> forest) {\n        \n    }\n}"
    },
    {
      "lang": "JavaScript",
      "code": "/**\n * @param {number[][]} forest\n * @return {number}\n */\nvar cutOffTree = function(forest) {\n    \n};"
    },
    {
      "lang": "Ruby",
      "code": "# @param {Integer[][]} forest\n# @return {Integer}\ndef cut_off_tree(forest)\n    \nend"
    },
    {
      "lang": "Swift",
      "code": "class Solution {\n    func cutOffTree(_ forest: [[Int]]) -> Int {\n        \n    }\n}"
    },
    {
      "lang": "Go",
      "code": "func cutOffTree(forest [][]int) int {\n    \n}"
    },
    {
      "lang": "Scala",
      "code": "object Solution {\n    def cutOffTree(forest: List[List[Int]]): Int = {\n        \n    }\n}"
    },
    {
      "lang": "Kotlin",
      "code": "class Solution {\n    fun cutOffTree(forest: List<List<Int>>): Int {\n        \n    }\n}"
    },
    {
      "lang": "Rust",
      "code": "impl Solution {\n    pub fn cut_off_tree(forest: Vec<Vec<i32>>) -> i32 {\n        \n    }\n}"
    },
    {
      "lang": "PHP",
      "code": "class Solution {\n\n    /**\n     * @param Integer[][] $forest\n     * @return Integer\n     */\n    function cutOffTree($forest) {\n        \n    }\n}"
    }
  ],
  "stats": "{\"totalAccepted\": \"23.5K\", \"totalSubmission\": \"71K\", \"totalAcceptedRaw\": 23471, \"totalSubmissionRaw\": 70964, \"acRate\": \"33.1%\"}",
  "hints": [],
  "solution": {
    "id": "277",
    "canSeeDetail": true,
    "url": "/articles/cutoff-trees-for-golf-event/",
    "content": "[TOC]\n\n\n#### Approach Framework\n\n**Explanation**\n\nStarting from `(0, 0)`, for each tree in height order, we will calculate the distance from where we are to the next tree (and move there), adding that distance to the answer.\n\nWe frame the problem as providing some distance function `dist(forest, sr, sc, tr, tc)` that calculates the path distance from source `(sr, sc)` to target `(tr, tc)` through obstacles `dist[i][j] == 0`.  (This distance function will return `-1` if the path is impossible.)\n\nWhat follows is code and complexity analysis that is common to all three approaches.  After, the algorithms presented in our approaches will focus on only providing our `dist` function.\n\n\n**Python**\n```python\nclass Solution(object):\n    def cutOffTree(self, forest):\n        trees = sorted((v, r, c) for r, row in enumerate(forest)\n                       for c, v in enumerate(row) if v > 1)\n        sr = sc = ans = 0\n        for _, tr, tc in trees:\n            d = dist(forest, sr, sc, tr, tc)\n            if d < 0: return -1\n            ans += d\n            sr, sc = tr, tc\n        return ans\n```\n\n**Java**\n```java\nclass Solution {\n    int[] dr = {-1, 1, 0, 0};\n    int[] dc = {0, 0, -1, 1};\n\n    public int cutOffTree(List<List<Integer>> forest) {\n        List<int[]> trees = new ArrayList();\n        for (int r = 0; r < forest.size(); ++r) {\n            for (int c = 0; c < forest.get(0).size(); ++c) {\n                int v = forest.get(r).get(c);\n                if (v > 1) trees.add(new int[]{v, r, c});\n            }\n        }\n\n        Collections.sort(trees, (a, b) -> Integer.compare(a[0], b[0]));\n\n        int ans = 0, sr = 0, sc = 0;\n        for (int[] tree: trees) {\n            int d = dist(forest, sr, sc, tree[1], tree[2]);\n            if (d < 0) return -1;\n            ans += d;\n            sr = tree[1]; sc = tree[2];\n        }\n        return ans;\n    }\n}\n```\n\n**Complexity Analysis**\n\nAll three algorithms have similar worst case complexities, but in practice each successive algorithm presented performs faster on random data.\n\n* Time Complexity: $$O((RC)^2)$$ where there are $$R$$ rows and $$C$$ columns in the given `forest`.  We walk to $$R*C$$ trees, and each walk could spend $$O(R*C)$$ time searching for the tree.\n\n* Space Complexity: $$O(R*C)$$, the maximum size of the data structures used.\n\n---\n#### Approach #1: BFS [Accepted]\n\n**Intuition and Algorithm**\n\nWe perform a breadth-first-search, processing nodes (grid positions) in a queue.  `seen` keeps track of nodes that have already been added to the queue at some point - those nodes will be already processed or are in the queue awaiting processing.\n\nFor each node that is next to be processed, we look at it's neighbors.  If they are in the forest (grid), they haven't been enqueued, and they aren't an obstacle, we will enqueue that neighbor.\n\nWe also keep a side count of the distance travelled for each node.  If the node we are processing is our destination 'target' `(tr, tc)`, we'll return the answer.\n\n**Python**\n```python\ndef bfs(forest, sr, sc, tr, tc):\n    R, C = len(forest), len(forest[0])\n    queue = collections.deque([(sr, sc, 0)])\n    seen = {(sr, sc)}\n    while queue:\n        r, c, d = queue.popleft()\n        if r == tr and c == tc:\n            return d\n        for nr, nc in ((r-1, c), (r+1, c), (r, c-1), (r, c+1)):\n            if (0 <= nr < R and 0 <= nc < C and\n                    (nr, nc) not in seen and forest[nr][nc]):\n                seen.add((nr, nc))\n                queue.append((nr, nc, d+1))\n    return -1\n```\n\n**Java**\n```java\npublic int bfs(List<List<Integer>> forest, int sr, int sc, int tr, int tc) {\n    int R = forest.size(), C = forest.get(0).size();\n    Queue<int[]> queue = new LinkedList();\n    queue.add(new int[]{sr, sc, 0});\n    boolean[][] seen = new boolean[R][C];\n    seen[sr][sc] = true;\n    while (!queue.isEmpty()) {\n        int[] cur = queue.poll();\n        if (cur[0] == tr && cur[1] == tc) return cur[2];\n        for (int di = 0; di < 4; ++di) {\n            int r = cur[0] + dr[di];\n            int c = cur[1] + dc[di];\n            if (0 <= r && r < R && 0 <= c && c < C &&\n                    !seen[r][c] && forest.get(r).get(c) > 0) {\n                seen[r][c] = true;\n                queue.add(new int[]{r, c, cur[2]+1});\n            }\n        }\n    }\n    return -1;\n}\n```\n\n---\n\n#### Approach #2: A* Search [Accepted]\n\n**Intuition and Algorithm**\n\nThe A* star algorithm is another path-finding algorithm.  For every node at position `(r, c)`, we have some estimated cost `node.f = node.g + node.h`, where `node.g` is the actual distance from `(sr, sc)` to `(r, c)`, and `node.h` is our *heuristic* (guess) of the distance from `(r, c)` to `(tr, tc)`.  In this case, our guess will be the taxicab distance, `node.h = abs(r-tr) + abs(c-tc)`.\n\nWe keep a priority queue to decide what node to search in (*expand*) next.  We can prove that if we find the target node, we must have travelled the lowest possible distance `node.g`.  By considering the last time where two backwards paths are the same, without loss of generality we could suppose the penultimate square of the two paths are different, and then in this case `node.f = node.g + 1`, showing the path with less actual distance travelled is expanded first as desired.\n\nIt might be useful for solvers familiar with *Dijkstra's Algorithm* to know that *A\\* Search* is a special case of *Dijkstra's* with `node.h = 0` always.\n\n**Python**\n```python\ndef astar(forest, sr, sc, tr, tc):\n    R, C = len(forest), len(forest[0])\n    heap = [(0, 0, sr, sc)]\n    cost = {(sr, sc): 0}\n    while heap:\n        f, g, r, c = heapq.heappop(heap)\n        if r == tr and c == tc: return g\n        for nr, nc in ((r-1,c), (r+1,c), (r,c-1), (r,c+1)):\n            if 0 <= nr < R and 0 <= nc < C and forest[nr][nc]:\n                ncost = g + 1 + abs(nr - tr) + abs(nc - tc)\n                if ncost < cost.get((nr, nc), 9999):\n                    cost[nr, nc] = ncost\n                    heapq.heappush(heap, (ncost, g+1, nr, nc))\n    return -1\n```\n\n**Java**\n```java\npublic int cutOffTree(List<List<Integer>> forest, int sr, int sc, int tr, int tc) {\n    int R = forest.size(), C = forest.get(0).size();\n    PriorityQueue<int[]> heap = new PriorityQueue<int[]>(\n        (a, b) -> Integer.compare(a[0], b[0]));\n    heap.offer(new int[]{0, 0, sr, sc});\n\n    HashMap<Integer, Integer> cost = new HashMap();\n    cost.put(sr * C + sc, 0);\n\n    while (!heap.isEmpty()) {\n        int[] cur = heap.poll();\n        int g = cur[1], r = cur[2], c = cur[3];\n        if (r == tr && c == tc) return g;\n        for (int di = 0; di < 4; ++di) {\n            int nr = r + dr[di], nc = c + dc[di];\n            if (0 <= nr && nr < R && 0 <= nc && nc < C && forest.get(nr).get(nc) > 0) {\n                int ncost = g + 1 + Math.abs(nr-tr) + Math.abs(nc-tr);\n                if (ncost < cost.getOrDefault(nr * C + nc, 9999)) {\n                    cost.put(nr * C + nc, ncost);\n                    heap.offer(new int[]{ncost, g+1, nr, nc});\n                }\n            }\n        }\n    }\n    return -1;\n}\n```\n\n---\n#### Approach #3: Hadlock's Algorithm [Accepted]\n\n**Intuition**\n\nWithout any obstacles, the distance from `source = (sr, sc)` to `target = (tr, tc)` is simply `taxi(source, target) = abs(sr-tr) + abs(sc-tc)`.  This represents a sort of minimum distance that must be travelled.  Whenever we walk \"away\" from the target, we increase this minimum by 2, as we stepped 1 move, plus the taxicab distance from our new location has increased by one.\n\nLet's call such a move that walks away from the target a *detour*.  It can be proven that the distance from source to target is simply `taxi(source, target) + 2 * detours`, where `detours` is the smallest number of detours in any path from `source` to `target`.\n\n**Algorithm**\n\nWith respect to a `source` and `target`, call the *detour number* of a square to be the lowest number of detours possible in any path from `source` to that square.  (Here, detours are defined with respect to `target` - the number of away steps from that target.)\n\nWe will perform a priority-first-search in order of detour number.  If the target is found, it was found with the lowest detour number and therefore the lowest corresponding distance.  This motivates using `processed`, keeping track of when nodes are expanded, not visited - nodes could potentially be visited twice.\n\nAs each neighboring node can only have the same detour number or a detour number one higher, we will only consider at most 2 priority classes at a time.  Thus, we can use a deque (double ended queue) to perform this implementation.  We will place nodes with the same detour number to be expanded first, and nodes with a detour number one higher to be expanded after all nodes with the current number are done.\n\n**Python**\n```python\ndef hadlocks(forest, sr, sc, tr, tc):\n    R, C = len(forest), len(forest[0])\n    processed = set()\n    deque = collections.deque([(0, sr, sc)])\n    while deque:\n        detours, r, c = deque.popleft()\n        if (r, c) not in processed:\n            processed.add((r, c))\n            if r == tr and c == tc:\n                return abs(sr-tr) + abs(sc-tc) + 2*detours\n            for nr, nc, closer in ((r-1, c, r > tr), (r+1, c, r < tr),\n                                   (r, c-1, c > tc), (r, c+1, c < tc)):\n                if 0 <= nr < R and 0 <= nc < C and forest[nr][nc]:\n                    if closer:\n                        deque.appendleft((detours, nr, nc))\n                    else:\n                        deque.append((detours+1, nr, nc))\n    return -1\n```\n\n**Java**\n```java\npublic int hadlocks(List<List<Integer>> forest, int sr, int sc, int tr, int tc) {\n    int R = forest.size(), C = forest.get(0).size();\n    Set<Integer> processed = new HashSet();\n    Deque<int[]> deque = new ArrayDeque();\n    deque.offerFirst(new int[]{0, sr, sc});\n    while (!deque.isEmpty()) {\n        int[] cur = deque.pollFirst();\n        int detours = cur[0], r = cur[1], c = cur[2];\n        if (!processed.contains(r*C + c)) {\n            processed.add(r*C + c);\n            if (r == tr && c == tc) {\n                return Math.abs(sr-tr) + Math.abs(sc-tc) + 2 * detours;\n            }\n            for (int di = 0; di < 4; ++di) {\n                int nr = r + dr[di];\n                int nc = c + dc[di];\n                boolean closer;\n                if (di <= 1) closer = di == 0 ? r > tr : r < tr;\n                else closer = di == 2 ? c > tc : c < tc;\n                if (0 <= nr && nr < R && 0 <= nc && nc < C && forest.get(nr).get(nc) > 0) {\n                    if (closer) deque.offerFirst(new int[]{detours, nr, nc});\n                    else deque.offerLast(new int[]{detours+1, nr, nc});\n                }\n            }\n        }\n    }\n    return -1;\n}\n```\n---\n\nAnalysis written by: [@awice](https://leetcode.com/awice).",
    "contentTypeId": "107",
    "rating": {
      "id": "272",
      "count": 43,
      "average": 2.93,
      "userRating": null
    }
  },
  "status": null,
  "sampleTestCase": "[[1,2,3],[0,0,4],[7,6,5]]",
  "metaData": "{\n  \"name\": \"cutOffTree\",\n  \"params\": [\n    {\n      \"name\": \"forest\",\n      \"type\": \"list<list<integer>>\"\n    }\n  ],\n  \"return\": {\n    \"type\": \"integer\"\n  }\n}\n",
  "judgerAvailable": true,
  "judgeType": "large",
  "mysqlSchemas": [],
  "enableRunCode": true,
  "enableTestMode": false,
  "libraryUrl": null
}
