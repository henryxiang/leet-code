{
  "questionId": "684",
  "questionFrontendId": "684",
  "boundTopicId": null,
  "title": "Redundant Connection",
  "titleSlug": "redundant-connection",
  "categoryTitle": "Algorithms",
  "content": "<p>\r\nIn this problem, a tree is an <b>undirected</b> graph that is connected and has no cycles.\r\n</p><p>\r\nThe given input is a graph that started as a tree with N nodes (with distinct values 1, 2, ..., N), with one additional edge added.  The added edge has two different vertices chosen from 1 to N, and was not an edge that already existed.\r\n</p><p>\r\nThe resulting graph is given as a 2D-array of <code>edges</code>.  Each element of <code>edges</code> is a pair <code>[u, v]</code> with <code>u < v</code>, that represents an <b>undirected</b> edge connecting nodes <code>u</code> and <code>v</code>.\r\n</p><p>\r\nReturn an edge that can be removed so that the resulting graph is a tree of N nodes.  If there are multiple answers, return the answer that occurs last in the given 2D-array.  The answer edge <code>[u, v]</code> should be in the same format, with <code>u < v</code>.\r\n</p><p><b>Example 1:</b><br />\r\n<pre>\r\n<b>Input:</b> [[1,2], [1,3], [2,3]]\r\n<b>Output:</b> [2,3]\r\n<b>Explanation:</b> The given undirected graph will be like this:\r\n  1\r\n / \\\r\n2 - 3\r\n</pre>\r\n</p>\r\n<p><b>Example 2:</b><br />\r\n<pre>\r\n<b>Input:</b> [[1,2], [2,3], [3,4], [1,4], [1,5]]\r\n<b>Output:</b> [1,4]\r\n<b>Explanation:</b> The given undirected graph will be like this:\r\n5 - 1 - 2\r\n    |   |\r\n    4 - 3\r\n</pre>\r\n</p>\r\n<p><b>Note:</b><br />\r\n<li>The size of the input 2D-array will be between 3 and 1000.</li>\r\n<li>Every integer represented in the 2D-array will be between 1 and N, where N is the size of the input array.</li>\r\n</p>\r\n\r\n<br />\r\n\r\n<p>\r\n<b><font color=\"red\">Update (2017-09-26):</font></b><br>\r\nWe have overhauled the problem description + test cases and specified clearly the graph is an <b><i>undirected</i></b> graph. For the <b><i>directed</i></b> graph follow up please see <b><a href=\"https://leetcode.com/problems/redundant-connection-ii/description/\">Redundant Connection II</a></b>). We apologize for any inconvenience caused.\r\n</p>",
  "isPaidOnly": false,
  "difficulty": "Medium",
  "likes": 901,
  "dislikes": 213,
  "isLiked": null,
  "similarQuestions": "[{\"title\": \"Redundant Connection II\", \"titleSlug\": \"redundant-connection-ii\", \"difficulty\": \"Hard\", \"translatedTitle\": null}, {\"title\": \"Accounts Merge\", \"titleSlug\": \"accounts-merge\", \"difficulty\": \"Medium\", \"translatedTitle\": null}]",
  "contributors": [
    {
      "username": "just_not_over_12",
      "profileUrl": "/just_not_over_12/",
      "avatarUrl": "https://www.gravatar.com/avatar/464d04f3923cca7da1660e31335cd246.png?s=200"
    }
  ],
  "topicTags": [
    {
      "name": "Tree",
      "slug": "tree"
    },
    {
      "name": "Union Find",
      "slug": "union-find"
    },
    {
      "name": "Graph",
      "slug": "graph"
    }
  ],
  "companyTagStats": "{\"1\": [{\"taggedByAdmin\": false, \"name\": \"Amazon\", \"slug\": \"amazon\", \"timesEncountered\": 2}], \"2\": [{\"taggedByAdmin\": true, \"name\": \"Google\", \"slug\": \"google\", \"timesEncountered\": 3}], \"3\": []}",
  "codeSnippets": [
    {
      "lang": "C++",
      "code": "class Solution {\npublic:\n    vector<int> findRedundantConnection(vector<vector<int>>& edges) {\n        \n    }\n};"
    },
    {
      "lang": "Java",
      "code": "class Solution {\n    public int[] findRedundantConnection(int[][] edges) {\n        \n    }\n}"
    },
    {
      "lang": "Python",
      "code": "class Solution(object):\n    def findRedundantConnection(self, edges):\n        \"\"\"\n        :type edges: List[List[int]]\n        :rtype: List[int]\n        \"\"\"\n        "
    },
    {
      "lang": "Python3",
      "code": "class Solution:\n    def findRedundantConnection(self, edges: List[List[int]]) -> List[int]:\n        "
    },
    {
      "lang": "C",
      "code": "\n\n/**\n * Note: The returned array must be malloced, assume caller calls free().\n */\nint* findRedundantConnection(int** edges, int edgesSize, int* edgesColSize, int* returnSize){\n\n}\n\n"
    },
    {
      "lang": "C#",
      "code": "public class Solution {\n    public int[] FindRedundantConnection(int[][] edges) {\n        \n    }\n}"
    },
    {
      "lang": "JavaScript",
      "code": "/**\n * @param {number[][]} edges\n * @return {number[]}\n */\nvar findRedundantConnection = function(edges) {\n    \n};"
    },
    {
      "lang": "Ruby",
      "code": "# @param {Integer[][]} edges\n# @return {Integer[]}\ndef find_redundant_connection(edges)\n    \nend"
    },
    {
      "lang": "Swift",
      "code": "class Solution {\n    func findRedundantConnection(_ edges: [[Int]]) -> [Int] {\n        \n    }\n}"
    },
    {
      "lang": "Go",
      "code": "func findRedundantConnection(edges [][]int) []int {\n    \n}"
    },
    {
      "lang": "Scala",
      "code": "object Solution {\n    def findRedundantConnection(edges: Array[Array[Int]]): Array[Int] = {\n        \n    }\n}"
    },
    {
      "lang": "Kotlin",
      "code": "class Solution {\n    fun findRedundantConnection(edges: Array<IntArray>): IntArray {\n        \n    }\n}"
    },
    {
      "lang": "Rust",
      "code": "impl Solution {\n    pub fn find_redundant_connection(edges: Vec<Vec<i32>>) -> Vec<i32> {\n        \n    }\n}"
    },
    {
      "lang": "PHP",
      "code": "class Solution {\n\n    /**\n     * @param Integer[][] $edges\n     * @return Integer[]\n     */\n    function findRedundantConnection($edges) {\n        \n    }\n}"
    }
  ],
  "stats": "{\"totalAccepted\": \"70.4K\", \"totalSubmission\": \"128.8K\", \"totalAcceptedRaw\": 70354, \"totalSubmissionRaw\": 128770, \"acRate\": \"54.6%\"}",
  "hints": [],
  "solution": {
    "id": "250",
    "canSeeDetail": true,
    "url": "/articles/redundant-connection/",
    "content": "[TOC]\n\n#### Approach #1: DFS [Accepted]\n\n**Intuition and Algorithm**\n\nFor each edge `(u, v)`, traverse the graph with a depth-first search to see if we can connect `u` to `v`.  If we can, then it must be the duplicate edge.\n\n<iframe src=\"https://leetcode.com/playground/W7EXu5ND/shared\" frameBorder=\"0\" name=\"W7EXu5ND\" width=\"100%\" height=\"515\"></iframe>\n\n**Complexity Analysis**\n\n* Time Complexity:  $$O(N^2)$$ where $$N$$ is the number of vertices (and also the number of edges) in the graph.  In the worst case, for every edge we include, we have to search every previously-occurring edge of the graph.\n\n* Space Complexity:  $$O(N)$$.  The current construction of the graph has at most $$N$$ nodes.\n\n---\n#### Approach #2: Union-Find [Accepted]\n\n**Intuition and Algorithm**\n\nIf we are familiar with a Disjoint Set Union (DSU) data structure, we can use this in a straightforward manner to solve the problem: we simply find the first edge occurring in the graph that is already connected.  The rest of this explanation will focus on the details of implementing DSU.\n\nA DSU data structure can be used to maintain knowledge of the connected components of a graph, and query for them quickly.  In particular, we would like to support two operations:\n\n* `dsu.find(node x)`, which outputs a unique id so that two nodes have the same id if and only if they are in the same connected component, and:\n\n* `dsu.union(node x, node y)`, which draws an edge `(x, y)` in the graph, connecting the components with id `find(x)` and `find(y)` together.\n\nTo achieve this, we keep track of `parent`, which remembers the `id` of a smaller node in the same connected component.  If the node is it's own parent, we call this the *leader* of that connected component.\n\nA naive implementation of a DSU structure would look something like this:\n\n*Psuedocode*\n\n<iframe src=\"https://leetcode.com/playground/sCjT3wyq/shared\" frameBorder=\"0\" name=\"sCjT3wyq\" width=\"100%\" height=\"190\"></iframe>\n\nWe use two techniques to improve the run-time complexity: *path compression*, and *union-by-rank*.\n\n* Path compression involves changing the `x = parent[x]` in the `find` function to `parent[x] = find(parent[x])`.  Basically, as we compute the correct leader for x, we should remember our calculation.\n\n* Union-by-rank involves distributing the workload of `find` across leaders evenly.  Whenever we `dsu.union(x, y)`, we have two leaders `xr, yr` and we have to choose whether we want `parent[x] = yr` or `parent[y] = xr`.  We choose the leader that has a higher following to pick up a new follower.  \nSpecifically, the meaning of `rank` is that there are less than `2 ^ rank[x]` followers of `x`.  This strategy can be shown to give us better bounds for how long the recursive loop in `dsu.find` could run for.\n\n<iframe src=\"https://leetcode.com/playground/tFfjEuXo/shared\" frameBorder=\"0\" name=\"tFfjEuXo\" width=\"100%\" height=\"515\"></iframe>\n\n*Alternate Implementation of DSU without Union-By-Rank*\n<iframe src=\"https://leetcode.com/playground/DzMVxYRc/shared\" frameBorder=\"0\" name=\"DzMVxYRc\" width=\"100%\" height=\"207\"></iframe>\n\n<iframe src=\"https://leetcode.com/playground/YgdvM9bJ/shared\" frameBorder=\"0\" name=\"YgdvM9bJ\" width=\"100%\" height=\"515\"></iframe>\n\n**Complexity Analysis**\n\n* Time Complexity:  $$O(N\\alpha(N)) \\approx O(N)$$, where $$N$$ is the number of vertices (and also the number of edges) in the graph, and $$\\alpha$$ is the *Inverse-Ackermann* function.  We make up to $$N$$ queries of `dsu.union`, which takes (amortized) $$O(\\alpha(N))$$ time.  Outside the scope of this article, it can be shown why `dsu.union` has $$O(\\alpha(N))$$ complexity, what the Inverse-Ackermann function is, and why $$O(\\alpha(N))$$ is approximately $$O(1)$$.\n\n* Space Complexity:  $$O(N)$$.  The current construction of the graph (embedded in our `dsu` structure) has at most $$N$$ nodes.\n\n---\n\nAnalysis written by: [@awice](https://leetcode.com/awice)",
    "contentTypeId": "107",
    "rating": {
      "id": "245",
      "count": 57,
      "average": 4.596,
      "userRating": null
    }
  },
  "status": null,
  "sampleTestCase": "[[1,2],[1,3],[2,3]]",
  "metaData": "{\r\n  \"name\": \"findRedundantConnection\",\r\n  \"params\": [\r\n    {\r\n      \"name\": \"edges\",\r\n      \"type\": \"integer[][]\"\r\n    }\r\n  ],\r\n  \"return\": {\r\n    \"type\": \"integer[]\"\r\n  }\r\n}\r\n",
  "judgerAvailable": true,
  "judgeType": "large",
  "mysqlSchemas": [],
  "enableRunCode": true,
  "enableTestMode": false,
  "libraryUrl": null
}
