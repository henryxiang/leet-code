{
  "questionId": "723",
  "questionFrontendId": "723",
  "boundTopicId": null,
  "title": "Candy Crush",
  "titleSlug": "candy-crush",
  "categoryTitle": "Algorithms",
  "content": "<p>This question is about implementing a basic elimination algorithm for Candy Crush.</p>\r\n\r\n<p>Given a 2D integer array <code>board</code> representing the grid of candy, different positive integers <code>board[i][j]</code> represent different types of candies. A value of <code>board[i][j] = 0</code> represents that the cell at position <code>(i, j)</code> is empty. The given board represents the state of the game following the player&#39;s move. Now, you need to restore the board to a <i>stable state</i> by crushing candies according to the following rules:</p>\r\n\r\n<ol>\r\n\t<li>If three or more candies of the same type are adjacent vertically or horizontally, &quot;crush&quot; them all at the same time - these positions become empty.</li>\r\n\t<li>After crushing all candies simultaneously, if an empty space on the board has candies on top of itself, then these candies will drop until they hit a candy or bottom at the same time. (No new candies will drop outside the top boundary.)</li>\r\n\t<li>After the above steps, there may exist more candies that can be crushed. If so, you need to repeat the above steps.</li>\r\n\t<li>If there does not exist more candies that can be crushed (ie. the board is <i>stable</i>), then return the current board.</li>\r\n</ol>\r\n\r\n<p>You need to perform the above rules until the board becomes stable, then return the current board.</p>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p><b>Example:</b></p>\r\n\r\n<pre style=\"white-space: pre-line\">\r\n<b>Input:</b>\r\nboard = \r\n[[110,5,112,113,114],[210,211,5,213,214],[310,311,3,313,314],[410,411,412,5,414],[5,1,512,3,3],[610,4,1,613,614],[710,1,2,713,714],[810,1,2,1,1],[1,1,2,2,2],[4,1,4,4,1014]]\r\n\r\n<b>Output:</b>\r\n[[0,0,0,0,0],[0,0,0,0,0],[0,0,0,0,0],[110,0,0,0,114],[210,0,0,0,214],[310,0,0,113,314],[410,0,0,213,414],[610,211,112,313,614],[710,311,412,613,714],[810,411,512,713,1014]]\r\n\r\n<b>Explanation:</b> \r\n<img src=\"https://assets.leetcode.com/uploads/2018/10/12/candy_crush_example_2.png\" style=\"width: 777px; height: 532px;\" />\r\n</pre>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p><b>Note:</b></p>\r\n\r\n<ol>\r\n\t<li>The length of <code>board</code> will be in the range [3, 50].</li>\r\n\t<li>The length of <code>board[i]</code> will be in the range [3, 50].</li>\r\n\t<li>Each <code>board[i][j]</code> will initially start as an integer in the range [1, 2000].</li>\r\n</ol>\r\n",
  "isPaidOnly": true,
  "difficulty": "Medium",
  "likes": 253,
  "dislikes": 104,
  "isLiked": null,
  "similarQuestions": "[]",
  "contributors": [
    {
      "username": "fallcreek",
      "profileUrl": "/fallcreek/",
      "avatarUrl": "https://www.gravatar.com/avatar/043194ec5c4c5d2778049a3fa6d2e1d8.png?s=200"
    }
  ],
  "topicTags": [
    {
      "name": "Array",
      "slug": "array"
    },
    {
      "name": "Two Pointers",
      "slug": "two-pointers"
    }
  ],
  "companyTagStats": "{\"3\": [{\"taggedByAdmin\": true, \"name\": \"Rubrik\", \"slug\": \"rubrik\", \"timesEncountered\": 0}], \"1\": [{\"taggedByAdmin\": false, \"name\": \"Bloomberg\", \"slug\": \"bloomberg\", \"timesEncountered\": 6}, {\"taggedByAdmin\": false, \"name\": \"Google\", \"slug\": \"google\", \"timesEncountered\": 2}], \"2\": []}",
  "codeSnippets": [
    {
      "lang": "C++",
      "code": "class Solution {\npublic:\n    vector<vector<int>> candyCrush(vector<vector<int>>& board) {\n        \n    }\n};"
    },
    {
      "lang": "Java",
      "code": "class Solution {\n    public int[][] candyCrush(int[][] board) {\n        \n    }\n}"
    },
    {
      "lang": "Python",
      "code": "class Solution(object):\n    def candyCrush(self, board):\n        \"\"\"\n        :type board: List[List[int]]\n        :rtype: List[List[int]]\n        \"\"\"\n        "
    },
    {
      "lang": "Python3",
      "code": "class Solution:\n    def candyCrush(self, board: List[List[int]]) -> List[List[int]]:\n        "
    },
    {
      "lang": "C",
      "code": "\n\n/**\n * Return an array of arrays of size *returnSize.\n * The sizes of the arrays are returned as *returnColumnSizes array.\n * Note: Both returned array and *columnSizes array must be malloced, assume caller calls free().\n */\nint** candyCrush(int** board, int boardSize, int* boardColSize, int* returnSize, int** returnColumnSizes){\n\n}\n\n"
    },
    {
      "lang": "C#",
      "code": "public class Solution {\n    public int[][] CandyCrush(int[][] board) {\n        \n    }\n}"
    },
    {
      "lang": "JavaScript",
      "code": "/**\n * @param {number[][]} board\n * @return {number[][]}\n */\nvar candyCrush = function(board) {\n    \n};"
    },
    {
      "lang": "Ruby",
      "code": "# @param {Integer[][]} board\n# @return {Integer[][]}\ndef candy_crush(board)\n    \nend"
    },
    {
      "lang": "Swift",
      "code": "class Solution {\n    func candyCrush(_ board: [[Int]]) -> [[Int]] {\n        \n    }\n}"
    },
    {
      "lang": "Go",
      "code": "func candyCrush(board [][]int) [][]int {\n    \n}"
    },
    {
      "lang": "Scala",
      "code": "object Solution {\n    def candyCrush(board: Array[Array[Int]]): Array[Array[Int]] = {\n        \n    }\n}"
    },
    {
      "lang": "Kotlin",
      "code": "class Solution {\n    fun candyCrush(board: Array<IntArray>): Array<IntArray> {\n        \n    }\n}"
    },
    {
      "lang": "Rust",
      "code": "impl Solution {\n    pub fn candy_crush(board: Vec<Vec<i32>>) -> Vec<Vec<i32>> {\n        \n    }\n}"
    },
    {
      "lang": "PHP",
      "code": "class Solution {\n\n    /**\n     * @param Integer[][] $board\n     * @return Integer[][]\n     */\n    function candyCrush($board) {\n        \n    }\n}"
    }
  ],
  "stats": "{\"totalAccepted\": \"14K\", \"totalSubmission\": \"21.1K\", \"totalAcceptedRaw\": 13981, \"totalSubmissionRaw\": 21057, \"acRate\": \"66.4%\"}",
  "hints": [
    "Carefully perform the \"crush\" and \"gravity\" steps.  In the crush step, flag each candy that should be removed, then go through and crush each flagged candy.  In the gravity step, collect the candy in each column and then rewrite the column appropriately.  Do these steps repeatedly until there's no work left to do."
  ],
  "solution": {
    "id": "283",
    "canSeeDetail": true,
    "url": "/articles/candy-crush/",
    "content": "[TOC]\n\n#### Approach #1: Ad-Hoc [Accepted]\n\n**Intuition**\n\nWe need to simply perform the algorithm as described.  It consists of two major steps: a crush step, and a gravity step.  We work through each step individually.\n\n**Algorithm**\n\n*Crushing Step*\n\nWhen crushing, one difficulty is that we might accidentally crush candy that is part of another row.  For example, if the board is:\n\n```python\n123\n145\n111\n```\nand we crush the vertical row of `1`s early, we may not see there was also a horizontal row.\n\nTo remedy this, we should flag candy that should be crushed first.  We could use an auxillary `toCrush` boolean array, or we could mark it directly on the board by making the entry negative (ie. `board[i][j] = -Math.abs(board[i][j])`)\n\nAs for how to scan the board, we have two approaches.  Let's call a *line* any row or column of the board.  \n\nFor each line, we could use a sliding window (or `itertools.groupby` in Python) to find contiguous segments of the same character.  If any of these segments have length 3 or more, we should flag them.\n\nAlternatively, for each line, we could look at each width-3 slice of the line: if they are all the same, then we should flag those 3.\n\nAfter, we can crush the candy by setting all flagged `board` cells to zero.\n\n*Gravity Step*\n\nFor each column, we want all the candy to go to the bottom.  One way is to iterate through and keep a stack of the (uncrushed) candy, popping and setting as we iterate through the column in reverse order.\n\nAlternatively, we could use a sliding window approach, maintaining a read and write head.  As the read head iterates through the column in reverse order, when the read head sees candy, the write head will write it down and move one place.  Then, the write head will write zeroes to the remainder of the column.\n\nWe showcase the simplest approaches to these steps in the solutions below.\n\n<iframe src=\"https://leetcode.com/playground/NMCdS4xd/shared\" frameBorder=\"0\" width=\"100%\" height=\"500\" name=\"NMCdS4xd\"></iframe>\n**Complexity Analysis**\n\n* Time Complexity: $$O((R*C)^2)$$, where $$R, C$$ is the number of rows and columns in `board`.  We need $$O(R*C)$$ to scan the board, and we might crush only 3 candies repeatedly.\n\n* Space Complexity: $$O(1)$$ additional complexity, as we edit the board in place.\n\n---\n\nAnalysis written by: [@awice](https://leetcode.com/awice).",
    "contentTypeId": "107",
    "rating": {
      "id": "280",
      "count": 14,
      "average": 4.714,
      "userRating": null
    }
  },
  "status": null,
  "sampleTestCase": "[[110,5,112,113,114],[210,211,5,213,214],[310,311,3,313,314],[410,411,412,5,414],[5,1,512,3,3],[610,4,1,613,614],[710,1,2,713,714],[810,1,2,1,1],[1,1,2,2,2],[4,1,4,4,1014]]",
  "metaData": "{\r\n  \"name\": \"candyCrush\",\r\n  \"params\": [\r\n    {\r\n      \"name\": \"board\",\r\n      \"type\": \"integer[][]\"\r\n    }\r\n  ],\r\n  \"return\": {\r\n    \"type\": \"integer[][]\"\r\n  }\r\n}\r\n",
  "judgerAvailable": true,
  "judgeType": "large",
  "mysqlSchemas": [],
  "enableRunCode": true,
  "enableTestMode": false,
  "libraryUrl": null
}
