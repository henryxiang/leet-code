{
  "questionId": "727",
  "questionFrontendId": "727",
  "boundTopicId": null,
  "title": "Minimum Window Subsequence",
  "titleSlug": "minimum-window-subsequence",
  "categoryTitle": "Algorithms",
  "content": "<p>Given strings <code>S</code> and <code>T</code>, find the minimum (contiguous) <b>substring</b> <code>W</code> of <code>S</code>, so that <code>T</code> is a <b>subsequence</b> of <code>W</code>.</p>\r\n\r\n<p>If there is no such window in <code>S</code> that covers all characters in <code>T</code>, return the empty string <code>&quot;&quot;</code>. If there are multiple such minimum-length windows, return the one with the left-most starting index.</p>\r\n\r\n<p><b>Example 1:</b></p>\r\n\r\n<pre>\r\n<b>Input:</b> \r\nS = &quot;abcdebdde&quot;, T = &quot;bde&quot;\r\n<b>Output:</b> &quot;bcde&quot;\r\n<b>Explanation:</b> \r\n&quot;bcde&quot; is the answer because it occurs before &quot;bdde&quot; which has the same length.\r\n&quot;deb&quot; is not a smaller window because the elements of T in the window must occur in order.\r\n</pre>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p><b>Note:</b></p>\r\n\r\n<ul>\r\n\t<li>All the strings in the input will only contain lowercase letters.</li>\r\n\t<li>The length of <code>S</code> will be in the range <code>[1, 20000]</code>.</li>\r\n\t<li>The length of <code>T</code> will be in the range <code>[1, 100]</code>.</li>\r\n</ul>\r\n\r\n<p>&nbsp;</p>",
  "isPaidOnly": true,
  "difficulty": "Hard",
  "likes": 436,
  "dislikes": 20,
  "isLiked": null,
  "similarQuestions": "[{\"title\": \"Minimum Window Substring\", \"titleSlug\": \"minimum-window-substring\", \"difficulty\": \"Hard\", \"translatedTitle\": null}, {\"title\": \"Longest Continuous Increasing Subsequence\", \"titleSlug\": \"longest-continuous-increasing-subsequence\", \"difficulty\": \"Easy\", \"translatedTitle\": null}]",
  "contributors": [
    {
      "username": "Talky",
      "profileUrl": "/talky/",
      "avatarUrl": "https://www.gravatar.com/avatar/28a8b24aab4348fb5408085c24b9ff88.png?s=200"
    }
  ],
  "topicTags": [
    {
      "name": "Dynamic Programming",
      "slug": "dynamic-programming"
    },
    {
      "name": "Sliding Window",
      "slug": "sliding-window"
    }
  ],
  "companyTagStats": "{\"1\": [{\"taggedByAdmin\": true, \"name\": \"Google\", \"slug\": \"google\", \"timesEncountered\": 7}, {\"taggedByAdmin\": false, \"name\": \"Amazon\", \"slug\": \"amazon\", \"timesEncountered\": 2}, {\"taggedByAdmin\": false, \"name\": \"Bloomberg\", \"slug\": \"bloomberg\", \"timesEncountered\": 2}], \"3\": [{\"taggedByAdmin\": false, \"name\": \"Houzz\", \"slug\": \"houzz\", \"timesEncountered\": 2}, {\"taggedByAdmin\": true, \"name\": \"eBay\", \"slug\": \"ebay\", \"timesEncountered\": 0}], \"2\": [{\"taggedByAdmin\": false, \"name\": \"Microsoft\", \"slug\": \"microsoft\", \"timesEncountered\": 2}]}",
  "codeSnippets": [
    {
      "lang": "C++",
      "code": "class Solution {\npublic:\n    string minWindow(string S, string T) {\n        \n    }\n};"
    },
    {
      "lang": "Java",
      "code": "class Solution {\n    public String minWindow(String S, String T) {\n        \n    }\n}"
    },
    {
      "lang": "Python",
      "code": "class Solution(object):\n    def minWindow(self, S, T):\n        \"\"\"\n        :type S: str\n        :type T: str\n        :rtype: str\n        \"\"\"\n        "
    },
    {
      "lang": "Python3",
      "code": "class Solution:\n    def minWindow(self, S: str, T: str) -> str:\n        "
    },
    {
      "lang": "C",
      "code": "\n\nchar * minWindow(char * S, char * T){\n\n}\n\n"
    },
    {
      "lang": "C#",
      "code": "public class Solution {\n    public string MinWindow(string S, string T) {\n        \n    }\n}"
    },
    {
      "lang": "JavaScript",
      "code": "/**\n * @param {string} S\n * @param {string} T\n * @return {string}\n */\nvar minWindow = function(S, T) {\n    \n};"
    },
    {
      "lang": "Ruby",
      "code": "# @param {String} s\n# @param {String} t\n# @return {String}\ndef min_window(s, t)\n    \nend"
    },
    {
      "lang": "Swift",
      "code": "class Solution {\n    func minWindow(_ S: String, _ T: String) -> String {\n        \n    }\n}"
    },
    {
      "lang": "Go",
      "code": "func minWindow(S string, T string) string {\n    \n}"
    },
    {
      "lang": "Scala",
      "code": "object Solution {\n    def minWindow(S: String, T: String): String = {\n        \n    }\n}"
    },
    {
      "lang": "Kotlin",
      "code": "class Solution {\n    fun minWindow(S: String, T: String): String {\n        \n    }\n}"
    },
    {
      "lang": "Rust",
      "code": "impl Solution {\n    pub fn min_window(s: String, t: String) -> String {\n        \n    }\n}"
    },
    {
      "lang": "PHP",
      "code": "class Solution {\n\n    /**\n     * @param String $S\n     * @param String $T\n     * @return String\n     */\n    function minWindow($S, $T) {\n        \n    }\n}"
    }
  ],
  "stats": "{\"totalAccepted\": \"23.9K\", \"totalSubmission\": \"59.9K\", \"totalAcceptedRaw\": 23873, \"totalSubmissionRaw\": 59875, \"acRate\": \"39.9%\"}",
  "hints": [
    "Let dp[j][e] = s be the largest index for which S[s:e+1] has T[:j] as a substring."
  ],
  "solution": {
    "id": "290",
    "canSeeDetail": true,
    "url": "/articles/minimum-window-subsequence/",
    "content": "[TOC]\n\n\n#### Approach #1: Dynamic Programming (Postfix Variation) [Accepted]\n\n**Intuition**\n\nLet's work on a simpler problem: `T = 'ab'`.  Whenever we find some `'b'` in `S`, we look for the most recent `'a'` that occurred before it, and that forms a candidate window `'a' = S[i], ..., S[j] = 'b'`.\n\nA weak solution to that problem would be to just search for `'a'` every time we find a `'b'`.  With a string like `'abbb...bb'` this would be inefficient.  A better approach is to remember the last `'a'` seen.  Then when we see a `'b'`, we know the start of the window is where we last saw `'a'`, and the end of the window is where we are now.\n\nHow can we extend this approach to say, `T = 'abc'`?  Whenever we find some `'c'` in `S`, such as `S[k] = 'c'`, we can remember the most recent window that ended at `'b'`, let's say `[i, j]`.  Then our candidate window (that is, the smallest possible window ending at `k`) would be `[i, k]`.\n\nOur approach in general works this way.  We add characters to `T` one at a time, and for every `S[k] = T[-1]` we always remember the length of the candidate window ending at `k`.  We can calculate this using knowledge of the length of the previous window (so we'll need to remember the last window seen).  This leads to a dynamic programming solution.\n\n**Algorithm**\n\nAs we iterate through `T[j]`, let's maintain `cur[e] = s` as the largest index such that `T[:j]` is a subsequence of `S[s: e+1]`, (or `-1` if impossible.)  Now we want to find `new`, the largest indexes for `T[:j+1]`.\n\nTo update our knowledge as `j += 1`, if `S[i] == T[j]`, then `last` (the largest `s` we have seen so far) represents a new valid window `[s, i]`.\n\nIn Python, we use `cur` and `new`, while in Java we use `dp[j]` and `dp[~j]` to keep track of the last two rows of our dynamic programming.\n\nAt the end, we look at all the windows we have and choose the best.\n\n<iframe src=\"https://leetcode.com/playground/GnETGuLi/shared\" frameBorder=\"0\" width=\"100%\" height=\"500\" name=\"GnETGuLi\"></iframe>\n\n**Complexity Analysis**\n\n* Time Complexity: $$O(ST)$$, where $$S, T$$ are the lengths of `S, T`.  We have two for-loops.\n\n* Space Complexity: $$O(S)$$, the length of `dp`.\n\n---\n#### Approach #2: Dynamic Programming (Next Array Variation) [Accepted]\n\n**Intuition**\n\nLet's guess that the minimum window will start at `S[i]`.  We can assume that `S[i] = T[0]`.  Then, we should find the next occurrence of `T[1]` in `S[i+1:]`, say at `S[j]`.  Then, we should find the next occurrence of `T[2]` in `S[j+1:]`, and so on.\n\nFinding the next occurrence can be precomputed in linear time so that each guess becomes $$O(T)$$ work.\n\n**Algorithm**\n\nWe can precompute (for each `i` and `letter`), `next[i][letter]`: the index of the first occurrence of `letter` in `S[i:]`, or `-1` if it is not found.\n\nThen, we'll maintain a set of minimum windows for `T[:j]` as `j` increases.  At the end, we'll take the best minimum window.\n\n<iframe src=\"https://leetcode.com/playground/iCZWYdoE/shared\" frameBorder=\"0\" width=\"100%\" height=\"500\" name=\"iCZWYdoE\"></iframe>\n\n**Complexity Analysis**\n\n* Time Complexity: $$O(ST)$$, where $$S, T$$ are the lengths of `S, T`, and assuming a fixed-sized alphabet.  The precomputation of `nxt` is $$O(S)$$, and the other work happens in two for-loops.\n\n* Space Complexity: $$O(S)$$, the size of `windows`.\n\n---\n\nAnalysis written by: [@awice](https://leetcode.com/awice).  Approach #1 inspired by [@zestypanda](https://leetcode.com/zestypanda/).",
    "contentTypeId": "107",
    "rating": {
      "id": "285",
      "count": 71,
      "average": 1.549,
      "userRating": null
    }
  },
  "status": null,
  "sampleTestCase": "\"abcdebdde\"\n\"bde\"",
  "metaData": "{\r\n  \"name\": \"minWindow\",\r\n  \"params\": [\r\n    {\r\n      \"name\": \"S\",\r\n      \"type\": \"string\"\r\n    },\r\n    {\r\n      \"name\": \"T\",\r\n      \"type\": \"string\"\r\n    }\r\n  ],\r\n  \"return\": {\r\n    \"type\": \"string\"\r\n  }\r\n}\r\n",
  "judgerAvailable": true,
  "judgeType": "large",
  "mysqlSchemas": [],
  "enableRunCode": true,
  "enableTestMode": false,
  "libraryUrl": null
}
