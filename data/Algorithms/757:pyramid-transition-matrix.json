{
  "questionId": "757",
  "questionFrontendId": "756",
  "boundTopicId": null,
  "title": "Pyramid Transition Matrix",
  "titleSlug": "pyramid-transition-matrix",
  "categoryTitle": "Algorithms",
  "content": "<p>We are stacking blocks to form a pyramid. Each block has a color which is a one letter string.</p>\r\n\r\n<p>We are allowed to place any color block <code>C</code> on top of two adjacent blocks of colors <code>A</code> and <code>B</code>, if and only if <code>ABC</code> is an allowed triple.</p>\r\n\r\n<p>We start with a bottom row of <code>bottom</code>, represented as a single string. We also start with a list of allowed triples <code>allowed</code>. Each allowed triple is represented as a string of length 3.</p>\r\n\r\n<p>Return true if we can build the pyramid all the way to the top, otherwise false.</p>\r\n\r\n<p><b>Example 1:</b></p>\r\n\r\n<pre>\r\n<b>Input:</b> bottom = &quot;BCD&quot;, allowed = [&quot;BCG&quot;, &quot;CDE&quot;, &quot;GEA&quot;, &quot;FFF&quot;]\r\n<b>Output:</b> true\r\n<b>Explanation:</b>\r\nWe can stack the pyramid like this:\r\n    A\r\n   / \\\r\n  G   E\r\n / \\ / \\\r\nB   C   D\r\n\r\nWe are allowed to place G on top of B and C because BCG is an allowed triple.  Similarly, we can place E on top of C and D, then A on top of G and E.</pre>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p><b>Example 2:</b></p>\r\n\r\n<pre>\r\n<b>Input:</b> bottom = &quot;AABA&quot;, allowed = [&quot;AAA&quot;, &quot;AAB&quot;, &quot;ABA&quot;, &quot;ABB&quot;, &quot;BAC&quot;]\r\n<b>Output:</b> false\r\n<b>Explanation:</b>\r\nWe can&#39;t stack the pyramid to the top.\r\nNote that there could be allowed triples (A, B, C) and (A, B, D) with C != D.\r\n</pre>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p><b>Note:</b></p>\r\n\r\n<ol>\r\n\t<li><code>bottom</code> will be a string with length in range <code>[2, 8]</code>.</li>\r\n\t<li><code>allowed</code> will have length in range <code>[0, 200]</code>.</li>\r\n\t<li>Letters in all strings will be chosen from the set <code>{&#39;A&#39;, &#39;B&#39;, &#39;C&#39;, &#39;D&#39;, &#39;E&#39;, &#39;F&#39;, &#39;G&#39;}</code>.</li>\r\n</ol>\r\n\r\n<p>&nbsp;</p>\r\n",
  "isPaidOnly": false,
  "difficulty": "Medium",
  "likes": 229,
  "dislikes": 299,
  "isLiked": null,
  "similarQuestions": "[]",
  "contributors": [
    {
      "username": "1337c0d3r",
      "profileUrl": "/1337c0d3r/",
      "avatarUrl": "https://assets.leetcode.com/users/1337c0d3r/avatar_1547177258.png"
    }
  ],
  "topicTags": [
    {
      "name": "Bit Manipulation",
      "slug": "bit-manipulation"
    },
    {
      "name": "Depth-first Search",
      "slug": "depth-first-search"
    }
  ],
  "companyTagStats": "{\"2\": [{\"taggedByAdmin\": true, \"name\": \"Airbnb\", \"slug\": \"airbnb\", \"timesEncountered\": 2}], \"3\": [{\"taggedByAdmin\": true, \"name\": \"Google\", \"slug\": \"google\", \"timesEncountered\": 0}], \"1\": []}",
  "codeSnippets": [
    {
      "lang": "C++",
      "code": "class Solution {\r\npublic:\r\n    bool pyramidTransition(string bottom, vector<string>& allowed) {\r\n        \r\n    }\r\n};"
    },
    {
      "lang": "Java",
      "code": "class Solution {\n    public boolean pyramidTransition(String bottom, List<String> allowed) {\n        \n    }\n}"
    },
    {
      "lang": "Python",
      "code": "class Solution(object):\n    def pyramidTransition(self, bottom, allowed):\n        \"\"\"\n        :type bottom: str\n        :type allowed: List[str]\n        :rtype: bool\n        \"\"\"\n        "
    },
    {
      "lang": "Python3",
      "code": "class Solution:\n    def pyramidTransition(self, bottom: str, allowed: List[str]) -> bool:\n        "
    },
    {
      "lang": "C",
      "code": "\n\nbool pyramidTransition(char * bottom, char ** allowed, int allowedSize){\n\n}\n\n"
    },
    {
      "lang": "C#",
      "code": "public class Solution {\r\n    public bool PyramidTransition(string bottom, IList<string> allowed) {\r\n        \r\n    }\r\n}"
    },
    {
      "lang": "JavaScript",
      "code": "/**\n * @param {string} bottom\n * @param {string[]} allowed\n * @return {boolean}\n */\nvar pyramidTransition = function(bottom, allowed) {\n    \n};"
    },
    {
      "lang": "Ruby",
      "code": "# @param {String} bottom\r\n# @param {String[]} allowed\r\n# @return {Boolean}\r\ndef pyramid_transition(bottom, allowed)\r\n    \r\nend"
    },
    {
      "lang": "Swift",
      "code": "class Solution {\r\n    func pyramidTransition(_ bottom: String, _ allowed: [String]) -> Bool {\r\n        \r\n    }\r\n}"
    },
    {
      "lang": "Go",
      "code": "func pyramidTransition(bottom string, allowed []string) bool {\r\n    \r\n}"
    },
    {
      "lang": "Scala",
      "code": "object Solution {\r\n    def pyramidTransition(bottom: String, allowed: List[String]): Boolean = {\r\n        \r\n    }\r\n}"
    },
    {
      "lang": "Kotlin",
      "code": "class Solution {\r\n    fun pyramidTransition(bottom: String, allowed: List<String>): Boolean {\r\n        \r\n    }\r\n}"
    },
    {
      "lang": "Rust",
      "code": "impl Solution {\n    pub fn pyramid_transition(bottom: String, allowed: Vec<String>) -> bool {\n        \n    }\n}"
    },
    {
      "lang": "PHP",
      "code": "class Solution {\n\n    /**\n     * @param String $bottom\n     * @param String[] $allowed\n     * @return Boolean\n     */\n    function pyramidTransition($bottom, $allowed) {\n        \n    }\n}"
    }
  ],
  "stats": "{\"totalAccepted\": \"17.2K\", \"totalSubmission\": \"32.4K\", \"totalAcceptedRaw\": 17245, \"totalSubmissionRaw\": 32412, \"acRate\": \"53.2%\"}",
  "hints": [],
  "solution": {
    "id": "363",
    "canSeeDetail": true,
    "url": "/articles/pyramid-transition-matrix/",
    "content": "[TOC]\n\n\n#### Approach #1: State to State Transition [Wrong Answer]\n\n**Intuition and Algorithm**\n\nWe model the states that blocks can be in.  Each state is a binary number where the `k`th bit is set if the `k`th type of block is a possibility.  Then, we create a transition map `T[state1][state2] -> state` that takes a left state and a right state and outputs all possible parent states.\n\nAt the end, applying these transitions is straightforward.  However, this approach is not correct, because the transitions are not independent.  If for example we have states in a row `A, {B or C}, A`, and allowed triples `(A, B, D)`, `(C, A, D)`, then regardless of the choice of `{B or C}` we cannot create the next row of the pyramid.\n\n<iframe src=\"https://leetcode.com/playground/FoBNczLu/shared\" frameBorder=\"0\" width=\"100%\" height=\"429\" name=\"FoBNczLu\"></iframe>\n\n**Complexity Analysis**\n\n* Time Complexity: $$O(2^{2\\mathcal{A}}A + N^2)$$, where $$N$$ is the length of `bottom`, $$A$$ is the length of `allowed`, and $$\\mathcal{A}$$ is the size of the alphabet.\n\n* Space Complexity: $$O(2^{2\\mathcal{A}})$$ in additional space complexity.\n\n---\n#### Approach #2: Depth-First Search [Accepted]\n\n**Intuition**\n\nWe exhaustively try every combination of blocks.\n\n**Algorithm**\n\nWe can work in either strings or integers, but we need to create a transition map `T` from the list of allowed triples.  This map `T[x][y] = {set of z}` will be all possible parent blocks for a left child of `x` and a right child of `y`.  When we work in strings, we use `Set`, and when we work in integers, we will use the set bits of the result integer.\n\nAfterwards, to `solve` a row, we generate every possible combination of the next row and solve them.  If any of those new rows are solvable, we return `True`, otherwise `False`.\n\nWe can also cache intermediate results, saving us time.  This is illustrated in the comments for Python.  For Java, all caching is done with lines of code that mention the integer `R`.\n\n<iframe src=\"https://leetcode.com/playground/W723Lgci/shared\" frameBorder=\"0\" width=\"100%\" height=\"500\" name=\"W723Lgci\"></iframe>\n\n**Complexity Analysis**\n\n* Time Complexity: $$O(\\mathcal{A}^{N})$$, where $$N$$ is the length of `bottom`, and $$\\mathcal{A}$$ is the size of the alphabet, and assuming we cache intermediate results.  We might try every sequence of letters for each row.  [The total complexity is because $$O(\\sum_{k}^n \\mathcal{A}^{k})$$ is a geometric series equal to $$O(\\frac{\\mathcal{A^{n+1}}-1}{\\mathcal{A}-1})$$.]  Without intermediate caching, this would be $$O(\\mathcal{A}^{N^2})$$.\n\n* Space Complexity: $$O(N^2)$$ additional space complexity.\n\n---\n\nAnalysis written by: [@awice](https://leetcode.com/awice).",
    "contentTypeId": "107",
    "rating": {
      "id": "359",
      "count": 42,
      "average": 1.69,
      "userRating": null
    }
  },
  "status": null,
  "sampleTestCase": "\"ABC\"\n[\"ABD\",\"BCE\",\"DEF\",\"FFF\"]",
  "metaData": "{\r\n  \"name\": \"pyramidTransition\",\r\n  \"params\": [\r\n    {\r\n      \"name\": \"bottom\",\r\n      \"type\": \"string\"\r\n    },\r\n    {\r\n      \"name\": \"allowed\",\r\n      \"type\": \"list<string>\"\r\n    }\r\n  ],\r\n  \"return\": {\r\n    \"type\": \"boolean\"\r\n  }\r\n}\r\n",
  "judgerAvailable": true,
  "judgeType": "large",
  "mysqlSchemas": [],
  "enableRunCode": true,
  "enableTestMode": false,
  "libraryUrl": null
}
