{
  "questionId": "771",
  "questionFrontendId": "431",
  "boundTopicId": null,
  "title": "Encode N-ary Tree to Binary Tree",
  "titleSlug": "encode-n-ary-tree-to-binary-tree",
  "categoryTitle": "Algorithms",
  "content": "<p>Design an algorithm to encode an N-ary tree into a binary tree and decode the binary tree to get the original N-ary tree. An N-ary tree is a rooted tree in which each node has no more than N children. Similarly, a binary tree is a rooted tree in which each node has no more than 2 children. There is no restriction on how your encode/decode algorithm should work. You just need to ensure that an N-ary tree can be encoded to a binary tree and this binary tree can be decoded to the original N-nary tree structure.</p>\n\n<p><em>Nary-Tree input serialization&nbsp;is represented in their level order traversal, each group of children is separated by the null value (See following example).</em></p>\n\n<p>For example, you may encode the following&nbsp;<code>3-ary</code>&nbsp;tree to a binary tree in this way:</p>\n\n<p><img src=\"https://assets.leetcode.com/uploads/2018/10/12/narytreebinarytreeexample.png\" style=\"width: 100%; max-width: 640px\" /></p>\n\n<pre>\n<strong>Input:</strong> root = [1,null,3,2,4,null,5,6]\n</pre>\n\n<p>Note that the above is just an example which&nbsp;<em>might or might not</em>&nbsp;work. You do not necessarily need to follow this format, so please be creative and come up with different approaches yourself.</p>\n\n<ol>\n</ol>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li>The height of the n-ary tree is less than or equal to <code>1000</code></li>\n\t<li>The total number of nodes is between <code>[0,&nbsp;10^4]</code></li>\n\t<li>Do not use class member/global/static variables to store states. Your encode and decode algorithms should be stateless.</li>\n</ul>\n",
  "isPaidOnly": true,
  "difficulty": "Hard",
  "likes": 130,
  "dislikes": 7,
  "isLiked": null,
  "similarQuestions": "[{\"title\": \"Serialize and Deserialize N-ary Tree\", \"titleSlug\": \"serialize-and-deserialize-n-ary-tree\", \"difficulty\": \"Hard\", \"translatedTitle\": null}]",
  "contributors": [
    {
      "username": "1337c0d3r",
      "profileUrl": "/1337c0d3r/",
      "avatarUrl": "https://assets.leetcode.com/users/1337c0d3r/avatar_1547177258.png"
    }
  ],
  "topicTags": [
    {
      "name": "Tree",
      "slug": "tree"
    }
  ],
  "companyTagStats": "{\"1\": [{\"taggedByAdmin\": false, \"name\": \"Microsoft\", \"slug\": \"microsoft\", \"timesEncountered\": 2}], \"2\": [], \"3\": []}",
  "codeSnippets": [
    {
      "lang": "C++",
      "code": "/*\n// Definition for a Node.\nclass Node {\npublic:\n    int val;\n    vector<Node*> children;\n\n    Node() {}\n\n    Node(int _val) {\n        val = _val;\n    }\n\n    Node(int _val, vector<Node*> _children) {\n        val = _val;\n        children = _children;\n    }\n};\n*/\n/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\n * };\n */\nclass Codec {\npublic:\n\n    // Encodes an n-ary tree to a binary tree.\n    TreeNode* encode(Node* root) {\n        \n    }\n\n    // Decodes your binary tree to an n-ary tree.\n    Node* decode(TreeNode* root) {\n        \n    }\n};\n\n// Your Codec object will be instantiated and called as such:\n// Codec codec;\n// codec.decode(codec.encode(root));"
    },
    {
      "lang": "Java",
      "code": "/*\n// Definition for a Node.\nclass Node {\n    public int val;\n    public List<Node> children;\n\n    public Node() {}\n\n    public Node(int _val) {\n        val = _val;\n    }\n\n    public Node(int _val, List<Node> _children) {\n        val = _val;\n        children = _children;\n    }\n};\n*/\n/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode(int x) { val = x; }\n * }\n */\nclass Codec {\n\n    // Encodes an n-ary tree to a binary tree.\n    public TreeNode encode(Node root) {\n        \n    }\n\n    // Decodes your binary tree to an n-ary tree.\n    public Node decode(TreeNode root) {\n        \n    }\n}\n\n// Your Codec object will be instantiated and called as such:\n// Codec codec = new Codec();\n// codec.decode(codec.encode(root));"
    },
    {
      "lang": "Python",
      "code": "\"\"\"\n# Definition for a Node.\nclass Node(object):\n    def __init__(self, val=None, children=None):\n        self.val = val\n        self.children = children\n\"\"\"\n\"\"\"\n# Definition for a binary tree node.\nclass TreeNode(object):\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\"\"\"\nclass Codec:\n\n    def encode(self, root):\n        \"\"\"Encodes an n-ary tree to a binary tree.\n        :type root: Node\n        :rtype: TreeNode\n        \"\"\"\n        \n\n    def decode(self, data):\n        \"\"\"Decodes your binary tree to an n-ary tree.\n        :type data: TreeNode\n        :rtype: Node\n        \"\"\"\n        \n\n# Your Codec object will be instantiated and called as such:\n# codec = Codec()\n# codec.decode(codec.encode(root))"
    },
    {
      "lang": "Python3",
      "code": "\"\"\"\n# Definition for a Node.\nclass Node:\n    def __init__(self, val=None, children=None):\n        self.val = val\n        self.children = children\n\"\"\"\n\"\"\"\n# Definition for a binary tree node.\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\"\"\"\nclass Codec:\n\n    # Encodes an n-ary tree to a binary tree.\n    def encode(self, root: 'Node') -> TreeNode:\n        \n\n\t# Decodes your binary tree to an n-ary tree.\n    def decode(self, data: TreeNode) -> 'Node':\n        \n\n# Your Codec object will be instantiated and called as such:\n# codec = Codec()\n# codec.decode(codec.encode(root))"
    },
    {
      "lang": "C#",
      "code": "/*\n// Definition for a Node.\npublic class Node {\n    public int val;\n    public IList<Node> children;\n\n    public Node() {}\n\n    public Node(int _val) {\n        val = _val;\n    }\n\n    public Node(int _val, IList<Node> _children) {\n        val = _val;\n        children = _children;\n    }\n}\n*/\n/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     public int val;\n *     public TreeNode left;\n *     public TreeNode right;\n *     public TreeNode(int x) { val = x; }\n * }\n */\npublic class Codec {\n\n    // Encodes an n-ary tree to a binary tree.\n    public TreeNode encode(Node root) {\n        \n    }\n\n    // Decodes your binary tree to an n-ary tree.\n    public Node decode(TreeNode root) {\n        \n    }\n}\n\n// Your Codec object will be instantiated and called as such:\n// Codec codec = new Codec();\n// codec.decode(codec.encode(root));"
    },
    {
      "lang": "JavaScript",
      "code": "/**\n * // Definition for a Node.\n * function Node(val, children) {\n *    this.val = val;\n *    this.children = children;\n * };\n */\n/**\n * Definition for a binary tree node.\n * function TreeNode(val) {\n *     this.val = val;\n *     this.left = this.right = null;\n * }\n */\n\nclass Codec {\n  \tconstructor() {\n    }\n  \n    /** \n     * @param {Node} root\n     * @return {TreeNode}\n     */\n    // Encodes an n-ary tree to a binary tree.\n    encode = function(root) {\n\n    };\n\n    /** \n     * @param {TreeNode} root \n     * @return {Node}\n     */\n    // Decodes your binary tree to an n-ary tree.\n    decode = function(root) {\n\n    };\n\n}\n/*\n* Your Codec object will be instantiated and called as such:\n* codec = Codec()\n* codec.decode(codec.encode(root))\n*/"
    }
  ],
  "stats": "{\"totalAccepted\": \"4.2K\", \"totalSubmission\": \"6.1K\", \"totalAcceptedRaw\": 4170, \"totalSubmissionRaw\": 6105, \"acRate\": \"68.3%\"}",
  "hints": [],
  "solution": {
    "id": "839",
    "canSeeDetail": true,
    "url": "/articles/encode-n-ary-tree-to-binary-tree/",
    "content": "[TOC]\r\n\r\n## Solution\r\n\r\n---\r\n#### Intuition\r\n\r\nThere are several ways to encode the N-ary tree to a binary tree. However, a majority of the algorithms could all be traced back to the one that is documented on the [Wikipedia](https://en.wikipedia.org/wiki/M-ary_tree#Convert_a_m-ary_tree_to_binary_tree).\r\n\r\nHere we would like to illustrate intuitively the idea first, which we would implement in different manners in the following sections.\r\n\r\n![pic](../Figures/431/431_nary_tree.png)\r\n\r\nTo put it simple, the algorithm can be summarized in two steps. We use the above N-ary tree as an example for demonstration.\r\n\r\n>Step 1). Link all **_siblings_** together, like a singly-linked list.\r\n\r\nEach node in the original N-ary tree would correspond uniquely to a node in the resulting binary tree.\r\n\r\nIn the first step, we first chain up all the sibling nodes together, _i.e._ nodes that share the same parent. By _chaining up_, we would link the nodes via either `left` or `right` child pointers of the binary tree node. Here we choose to do with the _right_ pointer.\r\n\r\n![pic](../Figures/431/431_sibling_list.png)\r\n\r\n>Step 2). Link the **_head_** of the obtained list of siblings with its **_parent_** node. \r\n\r\nNow that the siblings are chained up, we just need to link this sibling list with their parent node. \r\n\r\nAs one can see, we don't have to link each one of the siblings to its parent, and we cannot do so either, since we only got two pointers for a node in binary tree. It suffices to pick one of the siblings. Naturally, we could link the head of the list with its parent node.\r\n\r\n![pic](../Figures/431/431_binary_tree.png)\r\n\r\n_Before one notices, after the above two steps, we have already converted the N-ary tree to a binary tree !_\r\n\r\nIt might not be evident from the above graph. But if one turns the graph 45 degrees clockwise, a binary tree would appear.\r\n\r\n![pic](../Figures/431/431_binary_tree_format.png)\r\n\r\nAs one can imagine, based on the above idea, one can create some variants. For instance, instead of linking the child nodes with the `right` pointers, we could use the `left` pointers. And accordingly, we could start from the last child node to chain up the siblings. Here is the variant.\r\n\r\n![pic](../Figures/431/431_variant.png)\r\n\r\n\r\n<br/>\r\n<br/>\r\n\r\n---\r\n#### Approach 1: BFS (Breadth-First Search) Traversal\r\n\r\n**Intuition**\r\n\r\nThere are generally two strategies to traverse the tree data structure: _BFS (Breadth-First Search)_ and _DFS (Depth-First Search)_.\r\n\r\nBased on the intuition in the above section, one might find it fit well with the BFS strategy, since we are traversing the nodes _level by level_, _i.e._ we chain up the sibling nodes which reside in the same level of the tree. Indeed, we could implement the algorithm with the BFS strategy. But actually, as we would demonstrate later, we could also implement it via the DFS strategy.\r\n\r\n**Algorithm**\r\n\r\nLet us start with the BFS on the `encode(root)` function:\r\n\r\n- Speaking about BFS, one shall recall that it is essentially implemented via the **_queue_** data structure. Indeed, first of all, all the sibling nodes would be pushed into the queue in sequence. And the one at the head of the queue would be processed first, which follows the principle of the queue data structure, **_FIFO_** (_First In, First Out_).\r\n<br/>\r\n- The main body of the algorithm consists of a _**loop**_ that iterates through the queue until it becomes empty. At each step of the loop, we _pop_ out a node from the head of the queue, and process it. \r\n<br/>\r\n- For the popped out node, we then run another **_loop_** over its children nodes. As one notices, this is a nested loop inside the previous loop over the queue. At each step of this _nested loop_, for each child node, we do _two_ things:\r\n    - First, we chain this child node with its previous neighbor sibling node.\r\n    - Second, we append this child node into the queue, in order that it would have its turn to be processed as a parent node to encode its own children nodes.\r\n<br/>\r\n- Voila. That is it. An important note is that we do the traversing of the N-ary tree in parallel with the construction of the desired Binary Tree. As a result, we keep each entry in the queue as a **_tandem_**, _i.e._ `pair(n-ary_tree_node, binary_tree_node)`. \r\n<br/>\r\n- To render the algorithm more robust, we could handle the case where the input N-ary tree is empty at the beginning of the function.\r\n<br/>\r\n\r\n!?!../Documents/431_LIS.json:1000,501!?!\r\n\r\n<iframe src=\"https://leetcode.com/playground/7baCrPV4/shared\" frameBorder=\"0\" width=\"100%\" height=\"500\" name=\"7baCrPV4\"></iframe>\r\n\r\nAs to the `decode(node)` function, similarly with our encoding function, we could implement in the _BFS_ manner.\r\n\r\n- Again, the main algorithm is organized as a loop around a _queue_ data structure. \r\n<br/>\r\n- We start from the root node of the encoded binary tree by pushing it into the queue.\r\n<br/>\r\n- At each step of the iteration, we pop out a binary node from the tree, we then take the `left` child node of the node as its corresponding first child node of the original N-ary node.\r\n<br/>\r\n- We then recover the rest of the child nodes by following the `right` pointer of the binary nodes.\r\n\r\n\r\n**Complexity**\r\n\r\n- Time Complexity: $$\\mathcal{O}(N)$$ where $$N$$ is the number of nodes in the N-ary tree. We traverse each node in the tree once and only once.\r\n<br/>\r\n- Space Complexity: $$\\mathcal{O}(L)$$ where $$L$$ is the maximum number of nodes that reside at the same level.\r\n    - We use a queue data structure to do BFS traversal, _i.e._ visiting the nodes level by level.\r\n    - **At any given moment, the queue contains nodes that are _at most_ spread into _two levels_**. At a result, assuming the maximum number of nodes at one level is $$L$$, the size of the queue would be less than $$2L$$ at any time.\r\n    - Therefore, the space complexity of both `encode()` and `decode()` functions is $$\\mathcal{O}(L)$$. \r\n<br/>\r\n<br/>\r\n\r\n---\r\n#### Approach 2: DFS (Depth-First Search) Traversal\r\n\r\n**Intuition**\r\n\r\nAs it turned out, we could also implement the idea at the beginning of the article through DFS (Depth-First Search) traversal strategy.\r\n\r\nOften the case, we implement the DFS algorithm with the technique of **_recursion_** which could greatly simplify the logic. Instead of ironing out all iterative steps, we could implement the function with the help of the function itself.\r\n\r\n>The idea is that while we traverse the N-ary tree _node by node_ in the DFS manner, we **_weave_** the nodes together into a Binary tree, following the same intuition of encoding in the previous approach.\r\n\r\n\r\n**Algorithm**\r\n\r\nAgain, let's demonstrate the `encode(node)` function as an example.\r\n\r\n>The main idea of the algorithm is that for each node, we only take care the encoding of the node itself, and we invoke the function itself to encode each of its child node, _i.e._ `encode(node.children[i])`.\r\n\r\n- At the beginning of the `encode(node)` function, we create a binary tree node to contain the value of the current node.\r\n<br/>\r\n- Then we put the first child of the N-ary tree node as the left node of the newly-created binary tree node. We call the encoding function recursively to encode the first child node as well.\r\n<br/>\r\n- For the rest of the children nodes of the N-ary tree node, we chain them up with the `right` pointer of the binary tree node. And again, we call recursively the encoding function to encode each of the child node.\r\n\r\n![pic](../Figures/431/431_DFS.png)\r\n\r\n\r\n_Note:_ the following implementation is inspired from the post by [wangzi6147](https://leetcode.com/problems/encode-n-ary-tree-to-binary-tree/discuss/153061/Java-Solution-(Next-Level-greater-left-Same-Level-greater-right)) in the discussion forum.\r\n\r\n<iframe src=\"https://leetcode.com/playground/P39HD8VZ/shared\" frameBorder=\"0\" width=\"100%\" height=\"500\" name=\"P39HD8VZ\"></iframe>\r\n\r\n\r\n**Complexity**\r\n\r\n- Time Complexity: $$\\mathcal{O}(N)$$ where $$N$$ is the number of nodes in the N-ary tree. We traverse each node in the tree once and only once.\r\n<br/>\r\n- Space Complexity: $$\\mathcal{O}(D)$$ where $$D$$ is the depth of the N-ary tree.\r\n\r\n    - Unlike the BFS algorithm, we don't use the queue data structure in the DFS algorithm. However, implicitly the algorithm would consume more space in the function _call stack_ due to the recursive function calls. \r\n    - And this consumption of call stack space is the main space complexity for our DFS algorithm. As we can see, the size of the call stack at any moment is exactly _the number of **level**_ where the currently visited node resides, _e.g._ for the root node (level _0_), the recursive call stack is empty.\r\n<br/>\r\n<br/>\r\n\r\n\r\n---\r\n\r\nAnalysis written by @[liaison](https://leetcode.com/liaison/) and @[andvary](https://leetcode.com/andvary/)",
    "contentTypeId": "107",
    "rating": {
      "id": "797",
      "count": 3,
      "average": 4.667,
      "userRating": null
    }
  },
  "status": null,
  "sampleTestCase": "[1,null,3,2,4,null,5,6]",
  "metaData": "{\n  \"name\": \"CodecDriver\",\n  \"params\": [\n    {\n      \"name\": \"root\",\n      \"type\": \"TreeNode\"\n    }\n  ],\n  \"return\": {\n    \"type\": \"TreeNode\"\n  },\n  \"languages\": [\n    \"cpp\",\n    \"java\",\n    \"python\",\n    \"csharp\",\n    \"python3\",\n    \"javascript\"\n  ],\n  \"manual\": true\n}",
  "judgerAvailable": true,
  "judgeType": "large",
  "mysqlSchemas": [],
  "enableRunCode": true,
  "enableTestMode": false,
  "libraryUrl": null
}
