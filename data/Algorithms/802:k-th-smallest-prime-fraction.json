{
  "questionId": "802",
  "questionFrontendId": "786",
  "boundTopicId": null,
  "title": "K-th Smallest Prime Fraction",
  "titleSlug": "k-th-smallest-prime-fraction",
  "categoryTitle": "Algorithms",
  "content": "<p>A sorted list <code>A</code> contains 1, plus some number of primes.&nbsp; Then, for every p &lt; q in the list, we consider the fraction p/q.</p>\r\n\r\n<p>What is the <code>K</code>-th smallest fraction considered?&nbsp; Return your answer as an array of ints, where <code>answer[0] = p</code> and <code>answer[1] = q</code>.</p>\r\n\r\n<pre>\r\n<strong>Examples:</strong>\r\n<strong>Input:</strong> A = [1, 2, 3, 5], K = 3\r\n<strong>Output:</strong> [2, 5]\r\n<strong>Explanation:</strong>\r\nThe fractions to be considered in sorted order are:\r\n1/5, 1/3, 2/5, 1/2, 3/5, 2/3.\r\nThe third fraction is 2/5.\r\n\r\n<strong>Input:</strong> A = [1, 7], K = 1\r\n<strong>Output:</strong> [1, 7]\r\n</pre>\r\n\r\n<p><strong>Note:</strong></p>\r\n\r\n<ul>\r\n\t<li><code>A</code> will have length between <code>2</code> and <code>2000</code>.</li>\r\n\t<li>Each <code>A[i]</code> will be between <code>1</code> and <code>30000</code>.</li>\r\n\t<li><code>K</code> will be between <code>1</code> and <code>A.length * (A.length - 1) / 2</code>.</li>\r\n</ul>",
  "isPaidOnly": false,
  "difficulty": "Hard",
  "likes": 279,
  "dislikes": 16,
  "isLiked": null,
  "similarQuestions": "[{\"title\": \"Kth Smallest Element in a Sorted Matrix\", \"titleSlug\": \"kth-smallest-element-in-a-sorted-matrix\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Kth Smallest Number in Multiplication Table\", \"titleSlug\": \"kth-smallest-number-in-multiplication-table\", \"difficulty\": \"Hard\", \"translatedTitle\": null}, {\"title\": \"Find K-th Smallest Pair Distance\", \"titleSlug\": \"find-k-th-smallest-pair-distance\", \"difficulty\": \"Hard\", \"translatedTitle\": null}]",
  "contributors": [
    {
      "username": "awice",
      "profileUrl": "/awice/",
      "avatarUrl": "https://assets.leetcode.com/users/awice/avatar_1576905115.png"
    }
  ],
  "topicTags": [
    {
      "name": "Binary Search",
      "slug": "binary-search"
    },
    {
      "name": "Heap",
      "slug": "heap"
    }
  ],
  "companyTagStats": "{\"3\": [{\"taggedByAdmin\": true, \"name\": \"Pony.ai\", \"slug\": \"ponyai\", \"timesEncountered\": 2}], \"1\": [], \"2\": []}",
  "codeSnippets": [
    {
      "lang": "C++",
      "code": "class Solution {\npublic:\n    vector<int> kthSmallestPrimeFraction(vector<int>& A, int K) {\n        \n    }\n};"
    },
    {
      "lang": "Java",
      "code": "class Solution {\n    public int[] kthSmallestPrimeFraction(int[] A, int K) {\n        \n    }\n}"
    },
    {
      "lang": "Python",
      "code": "class Solution(object):\n    def kthSmallestPrimeFraction(self, A, K):\n        \"\"\"\n        :type A: List[int]\n        :type K: int\n        :rtype: List[int]\n        \"\"\"\n        "
    },
    {
      "lang": "Python3",
      "code": "class Solution:\n    def kthSmallestPrimeFraction(self, A: List[int], K: int) -> List[int]:\n        "
    },
    {
      "lang": "C",
      "code": "\n\n/**\n * Note: The returned array must be malloced, assume caller calls free().\n */\nint* kthSmallestPrimeFraction(int* A, int ASize, int K, int* returnSize){\n\n}\n\n"
    },
    {
      "lang": "C#",
      "code": "public class Solution {\n    public int[] KthSmallestPrimeFraction(int[] A, int K) {\n        \n    }\n}"
    },
    {
      "lang": "JavaScript",
      "code": "/**\n * @param {number[]} A\n * @param {number} K\n * @return {number[]}\n */\nvar kthSmallestPrimeFraction = function(A, K) {\n    \n};"
    },
    {
      "lang": "Ruby",
      "code": "# @param {Integer[]} a\n# @param {Integer} k\n# @return {Integer[]}\ndef kth_smallest_prime_fraction(a, k)\n    \nend"
    },
    {
      "lang": "Swift",
      "code": "class Solution {\n    func kthSmallestPrimeFraction(_ A: [Int], _ K: Int) -> [Int] {\n        \n    }\n}"
    },
    {
      "lang": "Go",
      "code": "func kthSmallestPrimeFraction(A []int, K int) []int {\n    \n}"
    },
    {
      "lang": "Scala",
      "code": "object Solution {\n    def kthSmallestPrimeFraction(A: Array[Int], K: Int): Array[Int] = {\n        \n    }\n}"
    },
    {
      "lang": "Kotlin",
      "code": "class Solution {\n    fun kthSmallestPrimeFraction(A: IntArray, K: Int): IntArray {\n        \n    }\n}"
    },
    {
      "lang": "Rust",
      "code": "impl Solution {\n    pub fn kth_smallest_prime_fraction(a: Vec<i32>, k: i32) -> Vec<i32> {\n        \n    }\n}"
    },
    {
      "lang": "PHP",
      "code": "class Solution {\n\n    /**\n     * @param Integer[] $A\n     * @param Integer $K\n     * @return Integer[]\n     */\n    function kthSmallestPrimeFraction($A, $K) {\n        \n    }\n}"
    }
  ],
  "stats": "{\"totalAccepted\": \"10.5K\", \"totalSubmission\": \"25.2K\", \"totalAcceptedRaw\": 10460, \"totalSubmissionRaw\": 25217, \"acRate\": \"41.5%\"}",
  "hints": [],
  "solution": {
    "id": "427",
    "canSeeDetail": true,
    "url": "/articles/k-th-smallest-prime-fraction/",
    "content": "[TOC]\r\n\r\n---\r\n#### Approach #1: Binary Search [Accepted]\r\n\r\n**Intuition**\r\n\r\nLet `under(x)` be the number of fractions below `x`.  It's an increasing function on `x`, so we can binary search for the correct answer.\r\n\r\n**Algorithm**\r\n\r\nLet's binary search for `x` such that there are exactly `K` fractions below `x`.  At the same time, we'll record the largest such fraction seen that was still below `x`.\r\n\r\nOur binary search follows a similar template as other binary searches: we have some interval `[lo, hi]` and a midpoint `mi = (lo + hi) / 2.0`.  If the number of fractions below `mi` is less than `K`, then we will now consider the interval `[mi, hi]`; otherwise we will consider the interval `[lo, mi]`.  For more on Binary Search, please visit the excellent LeetCode Explore card [here](https://leetcode.com/explore/learn/card/binary-search/) on this topic.\r\n\r\nOur `under(x)` function has two objectives: to return the number of fractions below `x`, as well as the maximum such fraction below `x`.  To count this, we will use a sliding window approach: for each `primes[j]`, we'll find the largest `i` so that `primes[i] / primes[j] < x`.  These `i`s are necessarily increasing as `j` (and `primes[j]`) increases, so this check is linear.\r\n\r\n<iframe src=\"https://leetcode.com/playground/482AhkWJ/shared\" frameBorder=\"0\" width=\"100%\" height=\"500\" name=\"482AhkWJ\"></iframe>\r\n\r\n**Complexity Analysis**\r\n\r\n* Time Complexity:  $$O(N \\log W)$$, where $$N$$ is the length of `primes`, and `W` is the width (in quantized units) of our binary search, `(hi - lo) / 1e-9` which is $$10^9$$.\r\n\r\n* Space Complexity:  $$O(1)$$.\r\n\r\n\r\n---\r\n#### Approach #2: Heap [Accepted]\r\n\r\n**Intuition**\r\n\r\nWe'll maintain a heap of potential fractions - the smallest unused fractions with denominator `primes[j]`.  We'll pop `K-1` elements from this heap, then the final fraction will be the answer.\r\n\r\n**Algorithm**\r\n\r\nIn Python, storing the fractions will be done with a tuple `(fraction, i, j)`, representing the fraction `fraction = primes[i] / primes[j]`.  When we use this fraction, we will push the next fraction `(primes[i+1] / primes[j], i+1, j)` onto the heap, assuming that the next fraction is valid (ie., that `i+1 < j`).\r\n\r\nIn Java, storing the fractions will be done as an `int[2]` of `{i, j}` (indexes, not elements of `A`), and we use a custom comparator to ensure the right elements are `pq.offer`ed correctly.\r\n\r\nWith this detail out of the way, the solution is straightforward.\r\n\r\n<iframe src=\"https://leetcode.com/playground/HsHeWDQc/shared\" frameBorder=\"0\" width=\"100%\" height=\"361\" name=\"HsHeWDQc\"></iframe>\r\n\r\n**Complexity Analysis**\r\n\r\n* Time Complexity:  $$O(K \\log N)$$, where $$N$$ is the length of `A`.  The heap has up to $$N$$ elements, which uses $$O(\\log N)$$ work to perform a pop operation on the heap.  We perform $$O(K)$$ such operations.\r\n\r\n* Space Complexity:  $$O(N)$$, the size of the heap.\r\n\r\n---\r\n#### Approach #3: Divide and Conquer [Accepted]\r\n\r\n**Explanation**\r\n\r\nOne approach outside the scope of this article is to perform a divide and conquer, leading to a marvelous $$O(N)$$ time complexity.  We can write the prime fractions in a matrix such that both the rows and columns are increasing, and we are looking for the `K`th element.  The main idea is that this is fairly \"close\" to the `K/4`th element in the matrix where we remove every odd numbered row and column from the original matrix.\r\n\r\nFor more information on this approach, visit @StefanPochmann's forum post [here](https://leetcode.com/problems/k-th-smallest-prime-fraction/discuss/115545/O(n)).\r\n\r\n---\r\n\r\nAnalysis written by: [@awice](https://leetcode.com/awice).",
    "contentTypeId": "107",
    "rating": {
      "id": "422",
      "count": 4,
      "average": 4,
      "userRating": null
    }
  },
  "status": null,
  "sampleTestCase": "[1,2,3,5]\n3",
  "metaData": "{\r\n  \"name\": \"kthSmallestPrimeFraction\",\r\n  \"params\": [\r\n    {\r\n      \"name\": \"A\",\r\n      \"type\": \"integer[]\"\r\n    },\r\n    {\r\n      \"name\": \"K\",\r\n      \"type\": \"integer\"\r\n    }\r\n  ],\r\n  \"return\": {\r\n    \"type\": \"integer[]\"\r\n  }\r\n}\r\n",
  "judgerAvailable": true,
  "judgeType": "large",
  "mysqlSchemas": [],
  "enableRunCode": true,
  "enableTestMode": false,
  "libraryUrl": null
}
