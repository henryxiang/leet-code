{
  "questionId": "817",
  "questionFrontendId": "706",
  "boundTopicId": null,
  "title": "Design HashMap",
  "titleSlug": "design-hashmap",
  "categoryTitle": "Algorithms",
  "content": "<p>Design a HashMap&nbsp;without using any built-in hash table libraries.</p>\r\n\r\n<p>To be specific, your design should include these functions:</p>\r\n\r\n<ul>\r\n\t<li><code>put(key, value)</code> :&nbsp;Insert a (key, value) pair into the HashMap. If the value already exists in the HashMap, update the value.</li>\r\n\t<li><code>get(key)</code>: Returns the value to which the specified key is mapped, or -1 if this map contains no mapping for the key.</li>\r\n\t<li><code>remove(key)</code> :&nbsp;Remove the mapping for the value key if this map contains the mapping for the key.</li>\r\n</ul>\r\n\r\n<p><br />\r\n<strong>Example:</strong></p>\r\n\r\n<pre>\r\nMyHashMap hashMap = new MyHashMap();\r\nhashMap.put(1, 1); &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;\r\nhashMap.put(2, 2); &nbsp; &nbsp; &nbsp; &nbsp; \r\nhashMap.get(1); &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;// returns 1\r\nhashMap.get(3); &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;// returns -1 (not found)\r\nhashMap.put(2, 1); &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;// update the existing value\r\nhashMap.get(2); &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;// returns 1 \r\nhashMap.remove(2); &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;// remove the mapping for 2\r\nhashMap.get(2); &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;// returns -1 (not found) \r\n</pre>\r\n\r\n<p><br />\r\n<strong>Note:</strong></p>\r\n\r\n<ul>\r\n\t<li>All keys and values will be in the range of <code>[0, 1000000]</code>.</li>\r\n\t<li>The number of operations will be in the range of&nbsp;<code>[1, 10000]</code>.</li>\r\n\t<li>Please do not use the built-in HashMap library.</li>\r\n</ul>\r\n",
  "isPaidOnly": false,
  "difficulty": "Easy",
  "likes": 530,
  "dislikes": 80,
  "isLiked": null,
  "similarQuestions": "[{\"title\": \"Design HashSet\", \"titleSlug\": \"design-hashset\", \"difficulty\": \"Easy\", \"translatedTitle\": null}, {\"title\": \"Design Skiplist\", \"titleSlug\": \"design-skiplist\", \"difficulty\": \"Hard\", \"translatedTitle\": null}]",
  "contributors": [
    {
      "username": "1337c0d3r",
      "profileUrl": "/1337c0d3r/",
      "avatarUrl": "https://assets.leetcode.com/users/1337c0d3r/avatar_1547177258.png"
    }
  ],
  "topicTags": [
    {
      "name": "Hash Table",
      "slug": "hash-table"
    },
    {
      "name": "Design",
      "slug": "design"
    }
  ],
  "companyTagStats": "{\"1\": [{\"taggedByAdmin\": false, \"name\": \"Amazon\", \"slug\": \"amazon\", \"timesEncountered\": 7}, {\"taggedByAdmin\": false, \"name\": \"Goldman Sachs\", \"slug\": \"goldman-sachs\", \"timesEncountered\": 3}, {\"taggedByAdmin\": false, \"name\": \"Google\", \"slug\": \"google\", \"timesEncountered\": 3}, {\"taggedByAdmin\": false, \"name\": \"Microsoft\", \"slug\": \"microsoft\", \"timesEncountered\": 2}, {\"taggedByAdmin\": false, \"name\": \"Uber\", \"slug\": \"uber\", \"timesEncountered\": 2}, {\"taggedByAdmin\": false, \"name\": \"Reddit\", \"slug\": \"reddit\", \"timesEncountered\": 2}, {\"taggedByAdmin\": false, \"name\": \"Oracle\", \"slug\": \"oracle\", \"timesEncountered\": 2}], \"3\": [{\"taggedByAdmin\": false, \"name\": \"Salesforce\", \"slug\": \"salesforce\", \"timesEncountered\": 4}, {\"taggedByAdmin\": false, \"name\": \"Twitter\", \"slug\": \"twitter\", \"timesEncountered\": 3}], \"2\": [{\"taggedByAdmin\": false, \"name\": \"LinkedIn\", \"slug\": \"linkedin\", \"timesEncountered\": 4}, {\"taggedByAdmin\": false, \"name\": \"Adobe\", \"slug\": \"adobe\", \"timesEncountered\": 3}, {\"taggedByAdmin\": false, \"name\": \"Apple\", \"slug\": \"apple\", \"timesEncountered\": 2}, {\"taggedByAdmin\": false, \"name\": \"ServiceNow\", \"slug\": \"servicenow\", \"timesEncountered\": 2}]}",
  "codeSnippets": [
    {
      "lang": "C++",
      "code": "class MyHashMap {\npublic:\n    /** Initialize your data structure here. */\n    MyHashMap() {\n        \n    }\n    \n    /** value will always be non-negative. */\n    void put(int key, int value) {\n        \n    }\n    \n    /** Returns the value to which the specified key is mapped, or -1 if this map contains no mapping for the key */\n    int get(int key) {\n        \n    }\n    \n    /** Removes the mapping of the specified value key if this map contains a mapping for the key */\n    void remove(int key) {\n        \n    }\n};\n\n/**\n * Your MyHashMap object will be instantiated and called as such:\n * MyHashMap* obj = new MyHashMap();\n * obj->put(key,value);\n * int param_2 = obj->get(key);\n * obj->remove(key);\n */"
    },
    {
      "lang": "Java",
      "code": "class MyHashMap {\n\n    /** Initialize your data structure here. */\n    public MyHashMap() {\n        \n    }\n    \n    /** value will always be non-negative. */\n    public void put(int key, int value) {\n        \n    }\n    \n    /** Returns the value to which the specified key is mapped, or -1 if this map contains no mapping for the key */\n    public int get(int key) {\n        \n    }\n    \n    /** Removes the mapping of the specified value key if this map contains a mapping for the key */\n    public void remove(int key) {\n        \n    }\n}\n\n/**\n * Your MyHashMap object will be instantiated and called as such:\n * MyHashMap obj = new MyHashMap();\n * obj.put(key,value);\n * int param_2 = obj.get(key);\n * obj.remove(key);\n */"
    },
    {
      "lang": "Python",
      "code": "class MyHashMap(object):\n\n    def __init__(self):\n        \"\"\"\n        Initialize your data structure here.\n        \"\"\"\n        \n\n    def put(self, key, value):\n        \"\"\"\n        value will always be non-negative.\n        :type key: int\n        :type value: int\n        :rtype: None\n        \"\"\"\n        \n\n    def get(self, key):\n        \"\"\"\n        Returns the value to which the specified key is mapped, or -1 if this map contains no mapping for the key\n        :type key: int\n        :rtype: int\n        \"\"\"\n        \n\n    def remove(self, key):\n        \"\"\"\n        Removes the mapping of the specified value key if this map contains a mapping for the key\n        :type key: int\n        :rtype: None\n        \"\"\"\n        \n\n\n# Your MyHashMap object will be instantiated and called as such:\n# obj = MyHashMap()\n# obj.put(key,value)\n# param_2 = obj.get(key)\n# obj.remove(key)"
    },
    {
      "lang": "Python3",
      "code": "class MyHashMap:\n\n    def __init__(self):\n        \"\"\"\n        Initialize your data structure here.\n        \"\"\"\n        \n\n    def put(self, key: int, value: int) -> None:\n        \"\"\"\n        value will always be non-negative.\n        \"\"\"\n        \n\n    def get(self, key: int) -> int:\n        \"\"\"\n        Returns the value to which the specified key is mapped, or -1 if this map contains no mapping for the key\n        \"\"\"\n        \n\n    def remove(self, key: int) -> None:\n        \"\"\"\n        Removes the mapping of the specified value key if this map contains a mapping for the key\n        \"\"\"\n        \n\n\n# Your MyHashMap object will be instantiated and called as such:\n# obj = MyHashMap()\n# obj.put(key,value)\n# param_2 = obj.get(key)\n# obj.remove(key)"
    },
    {
      "lang": "C",
      "code": "\n\n\ntypedef struct {\n    \n} MyHashMap;\n\n/** Initialize your data structure here. */\n\nMyHashMap* myHashMapCreate() {\n    \n}\n\n/** value will always be non-negative. */\nvoid myHashMapPut(MyHashMap* obj, int key, int value) {\n  \n}\n\n/** Returns the value to which the specified key is mapped, or -1 if this map contains no mapping for the key */\nint myHashMapGet(MyHashMap* obj, int key) {\n  \n}\n\n/** Removes the mapping of the specified value key if this map contains a mapping for the key */\nvoid myHashMapRemove(MyHashMap* obj, int key) {\n  \n}\n\nvoid myHashMapFree(MyHashMap* obj) {\n    \n}\n\n/**\n * Your MyHashMap struct will be instantiated and called as such:\n * MyHashMap* obj = myHashMapCreate();\n * myHashMapPut(obj, key, value);\n \n * int param_2 = myHashMapGet(obj, key);\n \n * myHashMapRemove(obj, key);\n \n * myHashMapFree(obj);\n*/"
    },
    {
      "lang": "C#",
      "code": "public class MyHashMap {\n\n    /** Initialize your data structure here. */\n    public MyHashMap() {\n        \n    }\n    \n    /** value will always be non-negative. */\n    public void Put(int key, int value) {\n        \n    }\n    \n    /** Returns the value to which the specified key is mapped, or -1 if this map contains no mapping for the key */\n    public int Get(int key) {\n        \n    }\n    \n    /** Removes the mapping of the specified value key if this map contains a mapping for the key */\n    public void Remove(int key) {\n        \n    }\n}\n\n/**\n * Your MyHashMap object will be instantiated and called as such:\n * MyHashMap obj = new MyHashMap();\n * obj.Put(key,value);\n * int param_2 = obj.Get(key);\n * obj.Remove(key);\n */"
    },
    {
      "lang": "JavaScript",
      "code": "/**\n * Initialize your data structure here.\n */\nvar MyHashMap = function() {\n    \n};\n\n/**\n * value will always be non-negative. \n * @param {number} key \n * @param {number} value\n * @return {void}\n */\nMyHashMap.prototype.put = function(key, value) {\n    \n};\n\n/**\n * Returns the value to which the specified key is mapped, or -1 if this map contains no mapping for the key \n * @param {number} key\n * @return {number}\n */\nMyHashMap.prototype.get = function(key) {\n    \n};\n\n/**\n * Removes the mapping of the specified value key if this map contains a mapping for the key \n * @param {number} key\n * @return {void}\n */\nMyHashMap.prototype.remove = function(key) {\n    \n};\n\n/** \n * Your MyHashMap object will be instantiated and called as such:\n * var obj = new MyHashMap()\n * obj.put(key,value)\n * var param_2 = obj.get(key)\n * obj.remove(key)\n */"
    },
    {
      "lang": "Ruby",
      "code": "class MyHashMap\n\n=begin\n    Initialize your data structure here.\n=end\n    def initialize()\n        \n    end\n\n\n=begin\n    value will always be non-negative.\n    :type key: Integer\n    :type value: Integer\n    :rtype: Void\n=end\n    def put(key, value)\n        \n    end\n\n\n=begin\n    Returns the value to which the specified key is mapped, or -1 if this map contains no mapping for the key\n    :type key: Integer\n    :rtype: Integer\n=end\n    def get(key)\n        \n    end\n\n\n=begin\n    Removes the mapping of the specified value key if this map contains a mapping for the key\n    :type key: Integer\n    :rtype: Void\n=end\n    def remove(key)\n        \n    end\n\n\nend\n\n# Your MyHashMap object will be instantiated and called as such:\n# obj = MyHashMap.new()\n# obj.put(key, value)\n# param_2 = obj.get(key)\n# obj.remove(key)"
    },
    {
      "lang": "Swift",
      "code": "\nclass MyHashMap {\n\n    /** Initialize your data structure here. */\n    init() {\n        \n    }\n    \n    /** value will always be non-negative. */\n    func put(_ key: Int, _ value: Int) {\n        \n    }\n    \n    /** Returns the value to which the specified key is mapped, or -1 if this map contains no mapping for the key */\n    func get(_ key: Int) -> Int {\n        \n    }\n    \n    /** Removes the mapping of the specified value key if this map contains a mapping for the key */\n    func remove(_ key: Int) {\n        \n    }\n}\n\n/**\n * Your MyHashMap object will be instantiated and called as such:\n * let obj = MyHashMap()\n * obj.put(key, value)\n * let ret_2: Int = obj.get(key)\n * obj.remove(key)\n */"
    },
    {
      "lang": "Go",
      "code": "type MyHashMap struct {\n    \n}\n\n\n/** Initialize your data structure here. */\nfunc Constructor() MyHashMap {\n    \n}\n\n\n/** value will always be non-negative. */\nfunc (this *MyHashMap) Put(key int, value int)  {\n    \n}\n\n\n/** Returns the value to which the specified key is mapped, or -1 if this map contains no mapping for the key */\nfunc (this *MyHashMap) Get(key int) int {\n    \n}\n\n\n/** Removes the mapping of the specified value key if this map contains a mapping for the key */\nfunc (this *MyHashMap) Remove(key int)  {\n    \n}\n\n\n/**\n * Your MyHashMap object will be instantiated and called as such:\n * obj := Constructor();\n * obj.Put(key,value);\n * param_2 := obj.Get(key);\n * obj.Remove(key);\n */"
    },
    {
      "lang": "Scala",
      "code": "class MyHashMap() {\n\n    /** Initialize your data structure here. */\n    \n\n    /** value will always be non-negative. */\n    def put(key: Int, value: Int) {\n        \n    }\n\n    /** Returns the value to which the specified key is mapped, or -1 if this map contains no mapping for the key */\n    def get(key: Int): Int = {\n        \n    }\n\n    /** Removes the mapping of the specified value key if this map contains a mapping for the key */\n    def remove(key: Int) {\n        \n    }\n\n}\n\n/**\n * Your MyHashMap object will be instantiated and called as such:\n * var obj = new MyHashMap()\n * obj.put(key,value)\n * var param_2 = obj.get(key)\n * obj.remove(key)\n */"
    },
    {
      "lang": "Kotlin",
      "code": "class MyHashMap() {\n\n    /** Initialize your data structure here. */\n    \n\n    /** value will always be non-negative. */\n    fun put(key: Int, value: Int) {\n        \n    }\n\n    /** Returns the value to which the specified key is mapped, or -1 if this map contains no mapping for the key */\n    fun get(key: Int): Int {\n        \n    }\n\n    /** Removes the mapping of the specified value key if this map contains a mapping for the key */\n    fun remove(key: Int) {\n        \n    }\n\n}\n\n/**\n * Your MyHashMap object will be instantiated and called as such:\n * var obj = MyHashMap()\n * obj.put(key,value)\n * var param_2 = obj.get(key)\n * obj.remove(key)\n */"
    },
    {
      "lang": "Rust",
      "code": "struct MyHashMap {\n\n}\n\n\n/** \n * `&self` means the method takes an immutable reference.\n * If you need a mutable reference, change it to `&mut self` instead.\n */\nimpl MyHashMap {\n\n    /** Initialize your data structure here. */\n    fn new() -> Self {\n        \n    }\n    \n    /** value will always be non-negative. */\n    fn put(&self, key: i32, value: i32) {\n        \n    }\n    \n    /** Returns the value to which the specified key is mapped, or -1 if this map contains no mapping for the key */\n    fn get(&self, key: i32) -> i32 {\n        \n    }\n    \n    /** Removes the mapping of the specified value key if this map contains a mapping for the key */\n    fn remove(&self, key: i32) {\n        \n    }\n}\n\n/**\n * Your MyHashMap object will be instantiated and called as such:\n * let obj = MyHashMap::new();\n * obj.put(key, value);\n * let ret_2: i32 = obj.get(key);\n * obj.remove(key);\n */"
    },
    {
      "lang": "PHP",
      "code": "class MyHashMap {\n    /**\n     * Initialize your data structure here.\n     */\n    function __construct() {\n        \n    }\n  \n    /**\n     * value will always be non-negative.\n     * @param Integer $key\n     * @param Integer $value\n     * @return NULL\n     */\n    function put($key, $value) {\n        \n    }\n  \n    /**\n     * Returns the value to which the specified key is mapped, or -1 if this map contains no mapping for the key\n     * @param Integer $key\n     * @return Integer\n     */\n    function get($key) {\n        \n    }\n  \n    /**\n     * Removes the mapping of the specified value key if this map contains a mapping for the key\n     * @param Integer $key\n     * @return NULL\n     */\n    function remove($key) {\n        \n    }\n}\n\n/**\n * Your MyHashMap object will be instantiated and called as such:\n * $obj = MyHashMap();\n * $obj->put($key, $value);\n * $ret_2 = $obj->get($key);\n * $obj->remove($key);\n */"
    }
  ],
  "stats": "{\"totalAccepted\": \"59.4K\", \"totalSubmission\": \"102.2K\", \"totalAcceptedRaw\": 59371, \"totalSubmissionRaw\": 102197, \"acRate\": \"58.1%\"}",
  "hints": [],
  "solution": {
    "id": "842",
    "canSeeDetail": true,
    "url": "/articles/design-hashmap/",
    "content": "[TOC]\r\n\r\n## Solution\r\n\r\n---\r\n#### Intuition\r\n\r\nHashmap is a common data structure that is implemented in various forms in different programming languages, _e.g._ `dict` in Python and `HashMap` in Java. The most distinguish characteristic about hashmap is that it provides a fast access to a **value** that is associated with a given **key**.\r\n\r\n>There are two main issues that we should tackle, in order to design an _efficient_ hashmap data structure: _1). hash function design_ and _2). collision handling_. \r\n\r\n- **1). hash function design**: the purpose of hash function is to map a key value to an address in the storage space, similarly to the system that we assign a postcode to each mail address.\r\nAs one can image, for a good hash function, it should map different keys **_evenly_** across the storage space, so that we don't end up with the case that the majority of the keys are _concentrated_ in a few spaces.\r\n<br/>\r\n- **2). collision handling**: essentially the hash function reduces the vast key space into a limited address space. As a result, there could be the case where two different keys are mapped to the same address, which is what we call _'collision'_. \r\nSince the collision is inevitable, it is important that we have a strategy to handle the collision. \r\n\r\nDepending on how we deal with each of the above two issues, we could have various implementation of hashmap data structure. \r\n<br/>\r\n<br/>\r\n\r\n---\r\n#### Approach 1: Modulo + Array\r\n\r\n**Intuition**\r\n\r\nAs one of the most intuitive implementations, we could adopt the `modulo` operator as the hash function, since the key value is of integer type. In addition, in order to minimize the potential collisions, it is advisable to use a prime number as the base of modulo, _e.g._ `2069`.\r\n\r\nWe organize the storage space as an **array** where each element is indexed with the output value of the hash function.\r\n\r\nIn case of _collision_, where two different keys are mapped to the same address, we use a **bucket** to hold all the values. The bucket is a container that hold all the values that are assigned by the hash function. We could use either a `LinkedList` or an `Array` to implement the bucket data structure. \r\n\r\n**Algorithm**\r\n\r\nFor each of the methods in hashmap data structure, namely `get()`, `put()` and `remove()`, it all boils down to the method to locate the value that is stored in hashmap, given the key.\r\n\r\nThis localization process can be done in two steps:\r\n\r\n- For a given `key` value, first we apply the hash function to generate a hash key, which corresponds to the address in our main storage. With this hash key, we would find the _bucket_ where the value should be stored. \r\n<br/>\r\n- Now that we found the bucket, we simply iterate through the bucket to check if the desired `<key, value>` pair does exist. \r\n<br/>\r\n\r\n![pic](../Figures/706/706_hashmap.png)\r\n\r\n<iframe src=\"https://leetcode.com/playground/WrZSUncy/shared\" frameBorder=\"0\" width=\"100%\" height=\"500\" name=\"WrZSUncy\"></iframe>\r\n\r\nNote that in the above implementations, we use `Array` to implement the _bucket_ in Python, while we use `LinkedList` in Java.\r\n\r\n**Complexity**\r\n\r\n- Time Complexity: for each of the methods, the time complexity is $$\\mathcal{O}(\\frac{N}{K})$$ where $$N$$ is the number of all possible keys and $$K$$ is the number of predefined buckets in the hashmap, which is `2069` in our case.\r\n    - In the ideal case, the keys are evenly distributed in all buckets. As a result, *on average*, we could consider the size of the bucket is $$\\frac{N}{K}$$.\r\n    - Since in the worst case we need to iterate through a bucket to find the desire value, the time complexity of each method is $$\\mathcal{O}(\\frac{N}{K})$$.\r\n<br/>\r\n- Space Complexity: $$\\mathcal{O}(K+M)$$ where $$K$$ is the number of predefined buckets in the hashmap and $$M$$ is the number of unique keys that have been inserted into the hashmap.\r\n<br/>\r\n<br/>\r\n\r\n---\r\n\r\nAnalysis written by @[liaison](https://leetcode.com/liaison/) and @[andvary](https://leetcode.com/andvary/)",
    "contentTypeId": "107",
    "rating": {
      "id": "800",
      "count": 5,
      "average": 5,
      "userRating": null
    }
  },
  "status": null,
  "sampleTestCase": "[\"MyHashMap\",\"put\",\"put\",\"get\",\"get\",\"put\",\"get\", \"remove\", \"get\"]\n[[],[1,1],[2,2],[1],[3],[2,1],[2],[2],[2]]",
  "metaData": "{\r\n    \"classname\": \"MyHashMap\",\r\n    \"maxbytesperline\": 400000,\r\n    \"constructor\": {\r\n        \"params\": [\r\n        ],\r\n        \"comment\": \"Initialize your data structure here.\"\r\n    },\r\n    \"methods\": [\r\n        {\r\n            \"name\" : \"put\",\r\n            \"params\": [\r\n                {\r\n                    \"type\": \"integer\",\r\n                    \"name\": \"key\"\r\n                },\r\n                {\r\n                    \"type\": \"integer\",\r\n                    \"name\": \"value\"\r\n                }\r\n            ],\r\n            \"return\": {\r\n                \"type\": \"void\"\r\n            },\r\n            \"comment\": \"value will always be non-negative.\"\r\n        },\r\n        {\r\n            \"name\" : \"get\",\r\n            \"params\": [\r\n                {\r\n                    \"type\": \"integer\",\r\n                    \"name\": \"key\"\r\n                }\r\n            ],\r\n            \"return\": {\r\n                \"type\": \"integer\"\r\n            },\r\n            \"comment\": \"Returns the value to which the specified key is mapped, or -1 if this map contains no mapping for the key\"\r\n        },\r\n        {\r\n            \"name\" : \"remove\",\r\n            \"params\": [\r\n                {\r\n                    \"type\": \"integer\",\r\n                    \"name\": \"key\"\r\n                }\r\n            ],\r\n            \"return\": {\r\n                \"type\": \"void\"\r\n            },\r\n            \"comment\": \"Removes the mapping of the specified value key if this map contains a mapping for the key\"\r\n        }\r\n    ],\r\n    \"systemdesign\": true,\r\n    \"params\": [\r\n        {\r\n            \"name\": \"inputs\",\r\n            \"type\": \"integer[]\"\r\n        },\r\n        {\r\n            \"name\": \"inputs\",\r\n            \"type\": \"integer[]\"\r\n        }\r\n    ],\r\n    \"return\": {\r\n        \"type\": \"list<String>\",\r\n        \"dealloc\": true\r\n    }\r\n}",
  "judgerAvailable": true,
  "judgeType": "large",
  "mysqlSchemas": [],
  "enableRunCode": true,
  "enableTestMode": false,
  "libraryUrl": null
}
