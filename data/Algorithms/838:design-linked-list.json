{
  "questionId": "838",
  "questionFrontendId": "707",
  "boundTopicId": null,
  "title": "Design Linked List",
  "titleSlug": "design-linked-list",
  "categoryTitle": "Algorithms",
  "content": "<p>Design your&nbsp;implementation of the linked list. You can choose to use the singly linked list or the doubly linked list. A node in a singly&nbsp;linked list should have two attributes: <code>val</code>&nbsp;and <code>next</code>. <code>val</code> is the value of the current node, and <code>next</code>&nbsp;is&nbsp;a&nbsp;pointer/reference to the next node. If you want to use the doubly linked list,&nbsp;you will need&nbsp;one more attribute <code>prev</code> to indicate the previous node in the linked list. Assume all nodes in the linked list are 0-indexed.</p>\n\n<p>Implement these functions in your linked list class:</p>\n\n<ul>\n\t<li><code>get(index)</code> : Get the value of&nbsp;the <code>index</code>-th&nbsp;node in the linked list. If the index is invalid, return <code>-1</code>.</li>\n\t<li><code>addAtHead(val)</code> : Add a node of value <code>val</code>&nbsp;before the first element of the linked list. After the insertion, the new node will be the first node of the linked list.</li>\n\t<li><code>addAtTail(val)</code> : Append a node of value <code>val</code>&nbsp;to the last element of the linked list.</li>\n\t<li><code>addAtIndex(index, val)</code> : Add a node of value <code>val</code>&nbsp;before the <code>index</code>-th&nbsp;node in the linked list.&nbsp;If <code>index</code>&nbsp;equals&nbsp;to the length of&nbsp;linked list, the node will be appended to the end of linked list. If index is greater than the length, the node will not be inserted.</li>\n\t<li><code>deleteAtIndex(index)</code> : Delete&nbsp;the <code>index</code>-th&nbsp;node in the linked list, if the index is valid.</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>Example:</strong></p>\n\n<pre>\n<b>Input: </b>\n[&quot;MyLinkedList&quot;,&quot;addAtHead&quot;,&quot;addAtTail&quot;,&quot;addAtIndex&quot;,&quot;get&quot;,&quot;deleteAtIndex&quot;,&quot;get&quot;]\n[[],[1],[3],[1,2],[1],[1],[1]]\n<b>Output: </b> \n[null,null,null,null,2,null,3]\n\n<b>Explanation:</b>\nMyLinkedList linkedList = new MyLinkedList(); // Initialize empty LinkedList\nlinkedList.addAtHead(1);\nlinkedList.addAtTail(3);\nlinkedList.addAtIndex(1, 2);  // linked list becomes 1-&gt;2-&gt;3\nlinkedList.get(1);            // returns 2\nlinkedList.deleteAtIndex(1);  // now the linked list is 1-&gt;3\nlinkedList.get(1);&nbsp;&nbsp;&nbsp;         // returns 3\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>0 &lt;= index,val &lt;= 1000</code></li>\n\t<li>Please do not use the built-in LinkedList library.</li>\n\t<li>At most <code>2000</code>&nbsp;calls will be made to&nbsp;<code>get</code>,&nbsp;<code>addAtHead</code>,&nbsp;<code>addAtTail</code>,&nbsp; <code>addAtIndex</code> and&nbsp;<code>deleteAtIndex</code>.</li>\n</ul>\n",
  "isPaidOnly": false,
  "difficulty": "Medium",
  "likes": 402,
  "dislikes": 576,
  "isLiked": null,
  "similarQuestions": "[{\"title\": \"Design Skiplist\", \"titleSlug\": \"design-skiplist\", \"difficulty\": \"Hard\", \"translatedTitle\": null}]",
  "contributors": [
    {
      "username": "1337c0d3r",
      "profileUrl": "/1337c0d3r/",
      "avatarUrl": "https://assets.leetcode.com/users/1337c0d3r/avatar_1547177258.png"
    }
  ],
  "topicTags": [
    {
      "name": "Linked List",
      "slug": "linked-list"
    },
    {
      "name": "Design",
      "slug": "design"
    }
  ],
  "companyTagStats": "{\"3\": [{\"taggedByAdmin\": false, \"name\": \"Oracle\", \"slug\": \"oracle\", \"timesEncountered\": 2}], \"1\": [], \"2\": []}",
  "codeSnippets": [
    {
      "lang": "C++",
      "code": "class MyLinkedList {\r\npublic:\r\n    /** Initialize your data structure here. */\r\n    MyLinkedList() {\r\n        \r\n    }\r\n    \r\n    /** Get the value of the index-th node in the linked list. If the index is invalid, return -1. */\r\n    int get(int index) {\r\n        \r\n    }\r\n    \r\n    /** Add a node of value val before the first element of the linked list. After the insertion, the new node will be the first node of the linked list. */\r\n    void addAtHead(int val) {\r\n        \r\n    }\r\n    \r\n    /** Append a node of value val to the last element of the linked list. */\r\n    void addAtTail(int val) {\r\n        \r\n    }\r\n    \r\n    /** Add a node of value val before the index-th node in the linked list. If index equals to the length of linked list, the node will be appended to the end of linked list. If index is greater than the length, the node will not be inserted. */\r\n    void addAtIndex(int index, int val) {\r\n        \r\n    }\r\n    \r\n    /** Delete the index-th node in the linked list, if the index is valid. */\r\n    void deleteAtIndex(int index) {\r\n        \r\n    }\r\n};\r\n\r\n/**\r\n * Your MyLinkedList object will be instantiated and called as such:\r\n * MyLinkedList* obj = new MyLinkedList();\r\n * int param_1 = obj->get(index);\r\n * obj->addAtHead(val);\r\n * obj->addAtTail(val);\r\n * obj->addAtIndex(index,val);\r\n * obj->deleteAtIndex(index);\r\n */"
    },
    {
      "lang": "Java",
      "code": "class MyLinkedList {\n\n    /** Initialize your data structure here. */\n    public MyLinkedList() {\n        \n    }\n    \n    /** Get the value of the index-th node in the linked list. If the index is invalid, return -1. */\n    public int get(int index) {\n        \n    }\n    \n    /** Add a node of value val before the first element of the linked list. After the insertion, the new node will be the first node of the linked list. */\n    public void addAtHead(int val) {\n        \n    }\n    \n    /** Append a node of value val to the last element of the linked list. */\n    public void addAtTail(int val) {\n        \n    }\n    \n    /** Add a node of value val before the index-th node in the linked list. If index equals to the length of linked list, the node will be appended to the end of linked list. If index is greater than the length, the node will not be inserted. */\n    public void addAtIndex(int index, int val) {\n        \n    }\n    \n    /** Delete the index-th node in the linked list, if the index is valid. */\n    public void deleteAtIndex(int index) {\n        \n    }\n}\n\n/**\n * Your MyLinkedList object will be instantiated and called as such:\n * MyLinkedList obj = new MyLinkedList();\n * int param_1 = obj.get(index);\n * obj.addAtHead(val);\n * obj.addAtTail(val);\n * obj.addAtIndex(index,val);\n * obj.deleteAtIndex(index);\n */"
    },
    {
      "lang": "Python",
      "code": "class MyLinkedList(object):\n\n    def __init__(self):\n        \"\"\"\n        Initialize your data structure here.\n        \"\"\"\n        \n\n    def get(self, index):\n        \"\"\"\n        Get the value of the index-th node in the linked list. If the index is invalid, return -1.\n        :type index: int\n        :rtype: int\n        \"\"\"\n        \n\n    def addAtHead(self, val):\n        \"\"\"\n        Add a node of value val before the first element of the linked list. After the insertion, the new node will be the first node of the linked list.\n        :type val: int\n        :rtype: None\n        \"\"\"\n        \n\n    def addAtTail(self, val):\n        \"\"\"\n        Append a node of value val to the last element of the linked list.\n        :type val: int\n        :rtype: None\n        \"\"\"\n        \n\n    def addAtIndex(self, index, val):\n        \"\"\"\n        Add a node of value val before the index-th node in the linked list. If index equals to the length of linked list, the node will be appended to the end of linked list. If index is greater than the length, the node will not be inserted.\n        :type index: int\n        :type val: int\n        :rtype: None\n        \"\"\"\n        \n\n    def deleteAtIndex(self, index):\n        \"\"\"\n        Delete the index-th node in the linked list, if the index is valid.\n        :type index: int\n        :rtype: None\n        \"\"\"\n        \n\n\n# Your MyLinkedList object will be instantiated and called as such:\n# obj = MyLinkedList()\n# param_1 = obj.get(index)\n# obj.addAtHead(val)\n# obj.addAtTail(val)\n# obj.addAtIndex(index,val)\n# obj.deleteAtIndex(index)"
    },
    {
      "lang": "Python3",
      "code": "class MyLinkedList:\n\n    def __init__(self):\n        \"\"\"\n        Initialize your data structure here.\n        \"\"\"\n        \n\n    def get(self, index: int) -> int:\n        \"\"\"\n        Get the value of the index-th node in the linked list. If the index is invalid, return -1.\n        \"\"\"\n        \n\n    def addAtHead(self, val: int) -> None:\n        \"\"\"\n        Add a node of value val before the first element of the linked list. After the insertion, the new node will be the first node of the linked list.\n        \"\"\"\n        \n\n    def addAtTail(self, val: int) -> None:\n        \"\"\"\n        Append a node of value val to the last element of the linked list.\n        \"\"\"\n        \n\n    def addAtIndex(self, index: int, val: int) -> None:\n        \"\"\"\n        Add a node of value val before the index-th node in the linked list. If index equals to the length of linked list, the node will be appended to the end of linked list. If index is greater than the length, the node will not be inserted.\n        \"\"\"\n        \n\n    def deleteAtIndex(self, index: int) -> None:\n        \"\"\"\n        Delete the index-th node in the linked list, if the index is valid.\n        \"\"\"\n        \n\n\n# Your MyLinkedList object will be instantiated and called as such:\n# obj = MyLinkedList()\n# param_1 = obj.get(index)\n# obj.addAtHead(val)\n# obj.addAtTail(val)\n# obj.addAtIndex(index,val)\n# obj.deleteAtIndex(index)"
    },
    {
      "lang": "C",
      "code": "\n\n\ntypedef struct {\n    \n} MyLinkedList;\n\n/** Initialize your data structure here. */\n\nMyLinkedList* myLinkedListCreate() {\n    \n}\n\n/** Get the value of the index-th node in the linked list. If the index is invalid, return -1. */\nint myLinkedListGet(MyLinkedList* obj, int index) {\n  \n}\n\n/** Add a node of value val before the first element of the linked list. After the insertion, the new node will be the first node of the linked list. */\nvoid myLinkedListAddAtHead(MyLinkedList* obj, int val) {\n  \n}\n\n/** Append a node of value val to the last element of the linked list. */\nvoid myLinkedListAddAtTail(MyLinkedList* obj, int val) {\n  \n}\n\n/** Add a node of value val before the index-th node in the linked list. If index equals to the length of linked list, the node will be appended to the end of linked list. If index is greater than the length, the node will not be inserted. */\nvoid myLinkedListAddAtIndex(MyLinkedList* obj, int index, int val) {\n  \n}\n\n/** Delete the index-th node in the linked list, if the index is valid. */\nvoid myLinkedListDeleteAtIndex(MyLinkedList* obj, int index) {\n  \n}\n\nvoid myLinkedListFree(MyLinkedList* obj) {\n    \n}\n\n/**\n * Your MyLinkedList struct will be instantiated and called as such:\n * MyLinkedList* obj = myLinkedListCreate();\n * int param_1 = myLinkedListGet(obj, index);\n \n * myLinkedListAddAtHead(obj, val);\n \n * myLinkedListAddAtTail(obj, val);\n \n * myLinkedListAddAtIndex(obj, index, val);\n \n * myLinkedListDeleteAtIndex(obj, index);\n \n * myLinkedListFree(obj);\n*/"
    },
    {
      "lang": "C#",
      "code": "public class MyLinkedList {\r\n\r\n    /** Initialize your data structure here. */\r\n    public MyLinkedList() {\r\n        \r\n    }\r\n    \r\n    /** Get the value of the index-th node in the linked list. If the index is invalid, return -1. */\r\n    public int Get(int index) {\r\n        \r\n    }\r\n    \r\n    /** Add a node of value val before the first element of the linked list. After the insertion, the new node will be the first node of the linked list. */\r\n    public void AddAtHead(int val) {\r\n        \r\n    }\r\n    \r\n    /** Append a node of value val to the last element of the linked list. */\r\n    public void AddAtTail(int val) {\r\n        \r\n    }\r\n    \r\n    /** Add a node of value val before the index-th node in the linked list. If index equals to the length of linked list, the node will be appended to the end of linked list. If index is greater than the length, the node will not be inserted. */\r\n    public void AddAtIndex(int index, int val) {\r\n        \r\n    }\r\n    \r\n    /** Delete the index-th node in the linked list, if the index is valid. */\r\n    public void DeleteAtIndex(int index) {\r\n        \r\n    }\r\n}\r\n\r\n/**\r\n * Your MyLinkedList object will be instantiated and called as such:\r\n * MyLinkedList obj = new MyLinkedList();\r\n * int param_1 = obj.Get(index);\r\n * obj.AddAtHead(val);\r\n * obj.AddAtTail(val);\r\n * obj.AddAtIndex(index,val);\r\n * obj.DeleteAtIndex(index);\r\n */"
    },
    {
      "lang": "JavaScript",
      "code": "/**\n * Initialize your data structure here.\n */\nvar MyLinkedList = function() {\n    \n};\n\n/**\n * Get the value of the index-th node in the linked list. If the index is invalid, return -1. \n * @param {number} index\n * @return {number}\n */\nMyLinkedList.prototype.get = function(index) {\n    \n};\n\n/**\n * Add a node of value val before the first element of the linked list. After the insertion, the new node will be the first node of the linked list. \n * @param {number} val\n * @return {void}\n */\nMyLinkedList.prototype.addAtHead = function(val) {\n    \n};\n\n/**\n * Append a node of value val to the last element of the linked list. \n * @param {number} val\n * @return {void}\n */\nMyLinkedList.prototype.addAtTail = function(val) {\n    \n};\n\n/**\n * Add a node of value val before the index-th node in the linked list. If index equals to the length of linked list, the node will be appended to the end of linked list. If index is greater than the length, the node will not be inserted. \n * @param {number} index \n * @param {number} val\n * @return {void}\n */\nMyLinkedList.prototype.addAtIndex = function(index, val) {\n    \n};\n\n/**\n * Delete the index-th node in the linked list, if the index is valid. \n * @param {number} index\n * @return {void}\n */\nMyLinkedList.prototype.deleteAtIndex = function(index) {\n    \n};\n\n/** \n * Your MyLinkedList object will be instantiated and called as such:\n * var obj = new MyLinkedList()\n * var param_1 = obj.get(index)\n * obj.addAtHead(val)\n * obj.addAtTail(val)\n * obj.addAtIndex(index,val)\n * obj.deleteAtIndex(index)\n */"
    },
    {
      "lang": "Ruby",
      "code": "class MyLinkedList\r\n\r\n=begin\r\n    Initialize your data structure here.\r\n=end\r\n    def initialize()\r\n        \r\n    end\r\n\r\n\r\n=begin\r\n    Get the value of the index-th node in the linked list. If the index is invalid, return -1.\r\n    :type index: Integer\r\n    :rtype: Integer\r\n=end\r\n    def get(index)\r\n        \r\n    end\r\n\r\n\r\n=begin\r\n    Add a node of value val before the first element of the linked list. After the insertion, the new node will be the first node of the linked list.\r\n    :type val: Integer\r\n    :rtype: Void\r\n=end\r\n    def add_at_head(val)\r\n        \r\n    end\r\n\r\n\r\n=begin\r\n    Append a node of value val to the last element of the linked list.\r\n    :type val: Integer\r\n    :rtype: Void\r\n=end\r\n    def add_at_tail(val)\r\n        \r\n    end\r\n\r\n\r\n=begin\r\n    Add a node of value val before the index-th node in the linked list. If index equals to the length of linked list, the node will be appended to the end of linked list. If index is greater than the length, the node will not be inserted.\r\n    :type index: Integer\r\n    :type val: Integer\r\n    :rtype: Void\r\n=end\r\n    def add_at_index(index, val)\r\n        \r\n    end\r\n\r\n\r\n=begin\r\n    Delete the index-th node in the linked list, if the index is valid.\r\n    :type index: Integer\r\n    :rtype: Void\r\n=end\r\n    def delete_at_index(index)\r\n        \r\n    end\r\n\r\n\r\nend\r\n\r\n# Your MyLinkedList object will be instantiated and called as such:\r\n# obj = MyLinkedList.new()\r\n# param_1 = obj.get(index)\r\n# obj.add_at_head(val)\r\n# obj.add_at_tail(val)\r\n# obj.add_at_index(index, val)\r\n# obj.delete_at_index(index)"
    },
    {
      "lang": "Swift",
      "code": "\r\nclass MyLinkedList {\r\n\r\n    /** Initialize your data structure here. */\r\n    init() {\r\n        \r\n    }\r\n    \r\n    /** Get the value of the index-th node in the linked list. If the index is invalid, return -1. */\r\n    func get(_ index: Int) -> Int {\r\n        \r\n    }\r\n    \r\n    /** Add a node of value val before the first element of the linked list. After the insertion, the new node will be the first node of the linked list. */\r\n    func addAtHead(_ val: Int) {\r\n        \r\n    }\r\n    \r\n    /** Append a node of value val to the last element of the linked list. */\r\n    func addAtTail(_ val: Int) {\r\n        \r\n    }\r\n    \r\n    /** Add a node of value val before the index-th node in the linked list. If index equals to the length of linked list, the node will be appended to the end of linked list. If index is greater than the length, the node will not be inserted. */\r\n    func addAtIndex(_ index: Int, _ val: Int) {\r\n        \r\n    }\r\n    \r\n    /** Delete the index-th node in the linked list, if the index is valid. */\r\n    func deleteAtIndex(_ index: Int) {\r\n        \r\n    }\r\n}\r\n\r\n/**\r\n * Your MyLinkedList object will be instantiated and called as such:\r\n * let obj = MyLinkedList()\r\n * let ret_1: Int = obj.get(index)\r\n * obj.addAtHead(val)\r\n * obj.addAtTail(val)\r\n * obj.addAtIndex(index, val)\r\n * obj.deleteAtIndex(index)\r\n */"
    },
    {
      "lang": "Go",
      "code": "type MyLinkedList struct {\r\n    \r\n}\r\n\r\n\r\n/** Initialize your data structure here. */\r\nfunc Constructor() MyLinkedList {\r\n    \r\n}\r\n\r\n\r\n/** Get the value of the index-th node in the linked list. If the index is invalid, return -1. */\r\nfunc (this *MyLinkedList) Get(index int) int {\r\n    \r\n}\r\n\r\n\r\n/** Add a node of value val before the first element of the linked list. After the insertion, the new node will be the first node of the linked list. */\r\nfunc (this *MyLinkedList) AddAtHead(val int)  {\r\n    \r\n}\r\n\r\n\r\n/** Append a node of value val to the last element of the linked list. */\r\nfunc (this *MyLinkedList) AddAtTail(val int)  {\r\n    \r\n}\r\n\r\n\r\n/** Add a node of value val before the index-th node in the linked list. If index equals to the length of linked list, the node will be appended to the end of linked list. If index is greater than the length, the node will not be inserted. */\r\nfunc (this *MyLinkedList) AddAtIndex(index int, val int)  {\r\n    \r\n}\r\n\r\n\r\n/** Delete the index-th node in the linked list, if the index is valid. */\r\nfunc (this *MyLinkedList) DeleteAtIndex(index int)  {\r\n    \r\n}\r\n\r\n\r\n/**\r\n * Your MyLinkedList object will be instantiated and called as such:\r\n * obj := Constructor();\r\n * param_1 := obj.Get(index);\r\n * obj.AddAtHead(val);\r\n * obj.AddAtTail(val);\r\n * obj.AddAtIndex(index,val);\r\n * obj.DeleteAtIndex(index);\r\n */"
    },
    {
      "lang": "Scala",
      "code": "class MyLinkedList() {\r\n\r\n    /** Initialize your data structure here. */\r\n    \r\n\r\n    /** Get the value of the index-th node in the linked list. If the index is invalid, return -1. */\r\n    def get(index: Int): Int = {\r\n        \r\n    }\r\n\r\n    /** Add a node of value val before the first element of the linked list. After the insertion, the new node will be the first node of the linked list. */\r\n    def addAtHead(`val`: Int) {\r\n        \r\n    }\r\n\r\n    /** Append a node of value val to the last element of the linked list. */\r\n    def addAtTail(`val`: Int) {\r\n        \r\n    }\r\n\r\n    /** Add a node of value val before the index-th node in the linked list. If index equals to the length of linked list, the node will be appended to the end of linked list. If index is greater than the length, the node will not be inserted. */\r\n    def addAtIndex(index: Int, `val`: Int) {\r\n        \r\n    }\r\n\r\n    /** Delete the index-th node in the linked list, if the index is valid. */\r\n    def deleteAtIndex(index: Int) {\r\n        \r\n    }\r\n\r\n}\r\n\r\n/**\r\n * Your MyLinkedList object will be instantiated and called as such:\r\n * var obj = new MyLinkedList()\r\n * var param_1 = obj.get(index)\r\n * obj.addAtHead(`val`)\r\n * obj.addAtTail(`val`)\r\n * obj.addAtIndex(index,`val`)\r\n * obj.deleteAtIndex(index)\r\n */"
    },
    {
      "lang": "Kotlin",
      "code": "class MyLinkedList() {\r\n\r\n    /** Initialize your data structure here. */\r\n    \r\n\r\n    /** Get the value of the index-th node in the linked list. If the index is invalid, return -1. */\r\n    fun get(index: Int): Int {\r\n        \r\n    }\r\n\r\n    /** Add a node of value val before the first element of the linked list. After the insertion, the new node will be the first node of the linked list. */\r\n    fun addAtHead(`val`: Int) {\r\n        \r\n    }\r\n\r\n    /** Append a node of value val to the last element of the linked list. */\r\n    fun addAtTail(`val`: Int) {\r\n        \r\n    }\r\n\r\n    /** Add a node of value val before the index-th node in the linked list. If index equals to the length of linked list, the node will be appended to the end of linked list. If index is greater than the length, the node will not be inserted. */\r\n    fun addAtIndex(index: Int, `val`: Int) {\r\n        \r\n    }\r\n\r\n    /** Delete the index-th node in the linked list, if the index is valid. */\r\n    fun deleteAtIndex(index: Int) {\r\n        \r\n    }\r\n\r\n}\r\n\r\n/**\r\n * Your MyLinkedList object will be instantiated and called as such:\r\n * var obj = MyLinkedList()\r\n * var param_1 = obj.get(index)\r\n * obj.addAtHead(`val`)\r\n * obj.addAtTail(`val`)\r\n * obj.addAtIndex(index,`val`)\r\n * obj.deleteAtIndex(index)\r\n */"
    },
    {
      "lang": "Rust",
      "code": "struct MyLinkedList {\n\n}\n\n\n/** \n * `&self` means the method takes an immutable reference.\n * If you need a mutable reference, change it to `&mut self` instead.\n */\nimpl MyLinkedList {\n\n    /** Initialize your data structure here. */\n    fn new() -> Self {\n        \n    }\n    \n    /** Get the value of the index-th node in the linked list. If the index is invalid, return -1. */\n    fn get(&self, index: i32) -> i32 {\n        \n    }\n    \n    /** Add a node of value val before the first element of the linked list. After the insertion, the new node will be the first node of the linked list. */\n    fn add_at_head(&self, val: i32) {\n        \n    }\n    \n    /** Append a node of value val to the last element of the linked list. */\n    fn add_at_tail(&self, val: i32) {\n        \n    }\n    \n    /** Add a node of value val before the index-th node in the linked list. If index equals to the length of linked list, the node will be appended to the end of linked list. If index is greater than the length, the node will not be inserted. */\n    fn add_at_index(&self, index: i32, val: i32) {\n        \n    }\n    \n    /** Delete the index-th node in the linked list, if the index is valid. */\n    fn delete_at_index(&self, index: i32) {\n        \n    }\n}\n\n/**\n * Your MyLinkedList object will be instantiated and called as such:\n * let obj = MyLinkedList::new();\n * let ret_1: i32 = obj.get(index);\n * obj.add_at_head(val);\n * obj.add_at_tail(val);\n * obj.add_at_index(index, val);\n * obj.delete_at_index(index);\n */"
    },
    {
      "lang": "PHP",
      "code": "class MyLinkedList {\n    /**\n     * Initialize your data structure here.\n     */\n    function __construct() {\n        \n    }\n  \n    /**\n     * Get the value of the index-th node in the linked list. If the index is invalid, return -1.\n     * @param Integer $index\n     * @return Integer\n     */\n    function get($index) {\n        \n    }\n  \n    /**\n     * Add a node of value val before the first element of the linked list. After the insertion, the new node will be the first node of the linked list.\n     * @param Integer $val\n     * @return NULL\n     */\n    function addAtHead($val) {\n        \n    }\n  \n    /**\n     * Append a node of value val to the last element of the linked list.\n     * @param Integer $val\n     * @return NULL\n     */\n    function addAtTail($val) {\n        \n    }\n  \n    /**\n     * Add a node of value val before the index-th node in the linked list. If index equals to the length of linked list, the node will be appended to the end of linked list. If index is greater than the length, the node will not be inserted.\n     * @param Integer $index\n     * @param Integer $val\n     * @return NULL\n     */\n    function addAtIndex($index, $val) {\n        \n    }\n  \n    /**\n     * Delete the index-th node in the linked list, if the index is valid.\n     * @param Integer $index\n     * @return NULL\n     */\n    function deleteAtIndex($index) {\n        \n    }\n}\n\n/**\n * Your MyLinkedList object will be instantiated and called as such:\n * $obj = MyLinkedList();\n * $ret_1 = $obj->get($index);\n * $obj->addAtHead($val);\n * $obj->addAtTail($val);\n * $obj->addAtIndex($index, $val);\n * $obj->deleteAtIndex($index);\n */"
    }
  ],
  "stats": "{\"totalAccepted\": \"39.7K\", \"totalSubmission\": \"185.5K\", \"totalAcceptedRaw\": 39718, \"totalSubmissionRaw\": 185465, \"acRate\": \"21.4%\"}",
  "hints": [],
  "solution": {
    "id": "776",
    "canSeeDetail": true,
    "url": "/articles/design-linked-list/",
    "content": "[TOC]\r\n\r\n## Solution\r\n\r\n---\r\n\r\n#### Interview Strategy\r\n\r\n[Linked List](https://en.wikipedia.org/wiki/Linked_list#Basic_concepts_and_nomenclature) \r\nis a data structure with zero or several elements. \r\nEach element contains a value and link(s) to the other element(s).\r\nDepending on the number of links, that could be \r\nsingly linked list, doubly linked list and multiply linked list.  \r\n\r\nSingly linked list is the simplest one, it provides `addAtHead` in a constant\r\ntime, and `addAtTail` in a linear time.\r\nThough doubly linked list is the most used one, because it provides both\r\n`addAtHead` and `addAtTail` in a constant time, and optimises insert \r\nand delete operations.\r\n\r\nDoubly linked list is implemented in Java as [LinkedList](https://docs.oracle.com/javase/8/docs/api/java/util/LinkedList.html)\r\nand in Python as [list](https://docs.python.org/3.7/tutorial/datastructures.html).\r\nSince these structures are quite well-known, a good interview strategy would be to mention them during the discussion but not to base the code on them. \r\nBetter to use the limited interview time to work with two ideas:\r\n \r\n- [Sentinel nodes](https://leetcode.com/articles/remove-linked-list-elements/)\r\n\r\n>Sentinel nodes are widely used in the trees and linked lists as _pseudo-heads_, _pseudo-tails_, _etc_. They serve as the guardians, as the name suggests, and usually they do not hold any data.\r\n\r\nSentinels nodes will be used here to simplify insert and delete. We would apply this in both of the following approaches.\r\n\r\n- Bidirectional search for doubly-linked list\r\n\r\nRather than starting from the head, we could search the node in a doubly-linked list from both head and tail.\r\n\r\nIf you are familiar with the concepts, you can start directly from the Approach #2. By the way, the Approach #2 is 90% of what you need to solve the problem of [LRU Cache](https://leetcode.com/articles/lru-cache/).\r\n\r\n#### Approach 1: Singly Linked List\r\n\r\nLet's start from the simplest possible MyLinkedList,\r\nwhich contains just a structure size and a sentinel head.\r\n\r\n![bla](../Figures/707/singly4.png)\r\n\r\n<iframe src=\"https://leetcode.com/playground/ZqvTFfSu/shared\" frameBorder=\"0\" width=\"100%\" height=\"191\" name=\"ZqvTFfSu\"></iframe>\r\n\r\nNote, that sentinel node is used as a pseudo-head and is always present. \r\nThis way the structure could never be empty, it will \r\ncontain at least a sentinel head.\r\nAll nodes in MyLinkedList have a type ListNode: value + \r\nlink to the next element.\r\n\r\n<iframe src=\"https://leetcode.com/playground/7jxrEtnY/shared\" frameBorder=\"0\" width=\"100%\" height=\"140\" name=\"7jxrEtnY\"></iframe>\r\n\r\n**Add at Index, Add at Head and Add at Tail**\r\n\r\nLet's first discuss insert at index operation, \r\nbecause thanks to the sentinel node \r\naddAtTail and addAtHead operations could be reduced to this operation \r\nas well. \r\n\r\nThe idea is straightforward:\r\n\r\n- Find the predecessor of the node to insert. If the node is to be inserted\r\nat head, its predecessor is a sentinel head. If the node is to be inserted\r\nat tail, its predecessor is the last node.\r\n\r\n- Insert the node by changing the link to the next node.\r\n\r\n<iframe src=\"https://leetcode.com/playground/t7SuGV8H/shared\" frameBorder=\"0\" width=\"100%\" height=\"89\" name=\"t7SuGV8H\"></iframe>\r\n\r\n![bla](../Figures/707/singly_insert.png)\r\n\r\n---\r\n\r\n![bla](../Figures/707/singly_insert_head.png)\r\n\r\n**Delete at Index**\r\n\r\nBasically, the same as insert:\r\n\r\n- Find the predecessor.\r\n\r\n- Delete node by changing the links to the next node.\r\n\r\n<iframe src=\"https://leetcode.com/playground/WPSFK6iN/shared\" frameBorder=\"0\" width=\"100%\" height=\"89\" name=\"WPSFK6iN\"></iframe>\r\n\r\n![bla](../Figures/707/singly_delete.png)\r\n\r\n**Get**            \r\n\r\nGet is a very straightforward: start from the sentinel node \r\nand do `index + 1` steps\r\n\r\n<iframe src=\"https://leetcode.com/playground/zgdL3wgj/shared\" frameBorder=\"0\" width=\"100%\" height=\"140\" name=\"zgdL3wgj\"></iframe>\r\n\r\n![bla](../Figures/707/singly_get.png)\r\n\r\n**Implementation**\r\n\r\n<iframe src=\"https://leetcode.com/playground/w2iMJoq8/shared\" frameBorder=\"0\" width=\"100%\" height=\"500\" name=\"w2iMJoq8\"></iframe>\r\n\r\n**Complexity Analysis**\r\n\r\n* Time complexity: $$\\mathcal{O}(1)$$ for addAtHead.\r\n$$\\mathcal{O}(k)$$ for get, addAtIndex, and deleteAtIndex, \r\nwhere $$k$$ is an index of the element to get, add or delete. \r\n$$\\mathcal{O}(N)$$ for addAtTail.\r\n \r\n* Space complexity: $$\\mathcal{O}(1)$$ for all operations.\r\n<br />\r\n<br />\r\n\r\n\r\n---\r\n#### Approach 2: Doubly Linked List\r\n\r\nTime to implement DLL MyLinkedList, \r\nwhich is a much faster (twice faster on the testcase set here) \r\nthough a bit more complex.\r\nIt contains size, sentinel head and sentinel tail.\r\n\r\n![bla](../Figures/707/dll.png)\r\n\r\n<iframe src=\"https://leetcode.com/playground/xmntBWjL/shared\" frameBorder=\"0\" width=\"100%\" height=\"259\" name=\"xmntBWjL\"></iframe>\r\n\r\nNote, that sentinel head and tail are always present. \r\nAll nodes in MyLinkedList have a type ListNode: value + \r\ntwo links: to the next and to the previous elements.\r\n\r\n<iframe src=\"https://leetcode.com/playground/PAHpoQBq/shared\" frameBorder=\"0\" width=\"100%\" height=\"157\" name=\"PAHpoQBq\"></iframe>\r\n\r\n**Add at Index, Add at Head and Add at Tail**\r\n\r\nThe idea is simple:\r\n\r\n- Find the predecessor and the successor of the node to insert. \r\nIf the node is to be inserted\r\nat head, its predecessor is a sentinel head. If the node is to be inserted\r\nat tail, its successor is a sentinel tail.\r\n\r\n> Use bidirectional search to perform faster.\r\n\r\n- Insert the node by changing the links to the next and previous nodes.\r\n\r\n<iframe src=\"https://leetcode.com/playground/JQGUogBG/shared\" frameBorder=\"0\" width=\"100%\" height=\"123\" name=\"JQGUogBG\"></iframe>\r\n\r\n![bla](../Figures/707/dll_insert2.png)\r\n\r\n**Delete at Index**\r\n\r\nBasically, the same as insert:\r\n\r\n- Find the predecessor and successor.\r\n\r\n- Delete node by changing the links to the next and previous nodes.\r\n\r\n<iframe src=\"https://leetcode.com/playground/bCqpre3o/shared\" frameBorder=\"0\" width=\"100%\" height=\"89\" name=\"bCqpre3o\"></iframe>\r\n\r\n![bla](../Figures/707/dll_delete2.png)\r\n\r\n**Get**            \r\n\r\nGet is very straightforward: \r\n\r\n- Compare `index` and `size - index` to define the fastest way:\r\nstarting from the head, or starting from the tail.\r\n\r\n- Go to the wanted node.\r\n\r\n<iframe src=\"https://leetcode.com/playground/byA6XGKN/shared\" frameBorder=\"0\" width=\"100%\" height=\"225\" name=\"byA6XGKN\"></iframe>\r\n\r\n![bla](../Figures/707/dll_get2.png)\r\n\r\n**Implementation**\r\n\r\n<iframe src=\"https://leetcode.com/playground/FTnqA4aq/shared\" frameBorder=\"0\" width=\"100%\" height=\"500\" name=\"FTnqA4aq\"></iframe>\r\n\r\n**Complexity Analysis**\r\n\r\n* Time complexity: $$\\mathcal{O}(1)$$ for addAtHead and addAtTail.\r\n$$\\mathcal{O}(\\min(k, N - k))$$ for get, addAtIndex, and deleteAtIndex, \r\nwhere $$k$$ is an index of the element to get, add or delete. \r\n \r\n* Space complexity: $$\\mathcal{O}(1)$$ for all operations.\r\n\r\nAnalysis written by @[liaison](https://leetcode.com/liaison/)\r\nand @[andvary](https://leetcode.com/andvary/)",
    "contentTypeId": "107",
    "rating": {
      "id": "761",
      "count": 14,
      "average": 3.357,
      "userRating": null
    }
  },
  "status": null,
  "sampleTestCase": "[\"MyLinkedList\",\"addAtHead\",\"addAtTail\",\"addAtIndex\",\"get\",\"deleteAtIndex\",\"get\"]\r\n[[],[1],[3],[1,2],[1],[1],[1]]\r",
  "metaData": "{\r\n    \"classname\": \"MyLinkedList\",\r\n    \"maxbytesperline\": 400000,\r\n    \"constructor\": {\r\n        \"params\": [\r\n        ],\r\n        \"comment\": \"Initialize your data structure here.\"\r\n    },\r\n    \"methods\": [\r\n        {\r\n            \"name\" : \"get\",\r\n            \"params\": [\r\n                {\r\n                    \"type\": \"integer\",\r\n                    \"name\": \"index\"\r\n                }\r\n            ],\r\n            \"return\": {\r\n                \"type\": \"integer\"\r\n            },\r\n            \"comment\": \"Get the value of the index-th node in the linked list. If the index is invalid, return -1.\"\r\n        },\r\n        {\r\n            \"name\" : \"addAtHead\",\r\n            \"params\": [\r\n                {\r\n                    \"type\": \"integer\",\r\n                    \"name\": \"val\"\r\n                }\r\n            ],\r\n            \"return\": {\r\n                \"type\": \"void\"\r\n            },\r\n            \"comment\": \"Add a node of value val before the first element of the linked list. After the insertion, the new node will be the first node of the linked list.\"\r\n        },\r\n        {\r\n            \"name\" : \"addAtTail\",\r\n            \"params\": [\r\n                {\r\n                    \"type\": \"integer\",\r\n                    \"name\": \"val\"\r\n                }\r\n            ],\r\n            \"return\": {\r\n                \"type\": \"void\"\r\n            },\r\n            \"comment\": \"Append a node of value val to the last element of the linked list.\"\r\n        },\r\n        {\r\n            \"name\" : \"addAtIndex\",\r\n            \"params\": [\r\n                {\r\n                    \"type\": \"integer\",\r\n                    \"name\": \"index\"\r\n                },\r\n                {\r\n                    \"type\": \"integer\",\r\n                    \"name\": \"val\"\r\n                }\r\n            ],\r\n            \"return\": {\r\n                \"type\": \"void\"\r\n            },\r\n            \"comment\": \"Add a node of value val before the index-th node in the linked list. If index equals to the length of linked list, the node will be appended to the end of linked list. If index is greater than the length, the node will not be inserted.\"\r\n        },\r\n        {\r\n            \"name\" : \"deleteAtIndex\",\r\n            \"params\": [\r\n                {\r\n                    \"type\": \"integer\",\r\n                    \"name\": \"index\"\r\n                }\r\n            ],\r\n            \"return\": {\r\n                \"type\": \"void\"\r\n            },\r\n            \"comment\": \"Delete the index-th node in the linked list, if the index is valid.\"\r\n        }\r\n    ],\r\n    \"systemdesign\": true,\r\n    \"params\": [\r\n        {\r\n            \"name\": \"inputs\",\r\n            \"type\": \"integer[]\"\r\n        },\r\n        {\r\n            \"name\": \"inputs\",\r\n            \"type\": \"integer[]\"\r\n        }\r\n    ],\r\n    \"return\": {\r\n        \"type\": \"list<String>\",\r\n        \"dealloc\": true\r\n    }\r\n}",
  "judgerAvailable": true,
  "judgeType": "large",
  "mysqlSchemas": [],
  "enableRunCode": true,
  "enableTestMode": false,
  "libraryUrl": null
}
