{
  "questionId": "860",
  "questionFrontendId": "622",
  "boundTopicId": null,
  "title": "Design Circular Queue",
  "titleSlug": "design-circular-queue",
  "categoryTitle": "Algorithms",
  "content": "<p>Design your implementation of the circular queue. The circular queue is a linear data structure in which the operations are performed based on FIFO (First In First Out) principle and the last position is connected back to the first position to make a circle. It is also called &quot;Ring Buffer&quot;.</p>\r\n\r\n<p>One of the benefits of the circular queue is that we can make use of the spaces in front of the queue. In a normal queue, once the queue becomes full, we cannot insert the next element even if there is a space in front of the queue. But using the circular queue, we can use the space to store new values.</p>\r\n\r\n<p>Your implementation should support following operations:</p>\r\n\r\n<ul>\r\n\t<li><code>MyCircularQueue(k)</code>: Constructor, set the size of the queue to be k.</li>\r\n\t<li><code>Front</code>: Get the front item from the queue. If the queue is empty, return -1.</li>\r\n\t<li><code>Rear</code>: Get the last item from the queue. If the queue is empty, return -1.</li>\r\n\t<li><code>enQueue(value)</code>: Insert an element into the circular queue. Return true if the operation is successful.</li>\r\n\t<li><code>deQueue()</code>: Delete an element from the circular queue. Return true if the operation is successful.</li>\r\n\t<li><code>isEmpty()</code>: Checks whether the circular queue is empty or not.</li>\r\n\t<li><code>isFull()</code>: Checks whether the circular queue is full or not.</li>\r\n</ul>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p><strong>Example:</strong></p>\r\n\r\n<pre>\r\nMyCircularQueue circularQueue = new MyCircularQueue(3); // set the size to be 3\r\ncircularQueue.enQueue(1); &nbsp;// return true\r\ncircularQueue.enQueue(2); &nbsp;// return true\r\ncircularQueue.enQueue(3); &nbsp;// return true\r\ncircularQueue.enQueue(4); &nbsp;// return false, the queue is full\r\ncircularQueue.Rear(); &nbsp;// return 3\r\ncircularQueue.isFull(); &nbsp;// return true\r\ncircularQueue.deQueue(); &nbsp;// return true\r\ncircularQueue.enQueue(4); &nbsp;// return true\r\ncircularQueue.Rear(); &nbsp;// return 4\r\n</pre>\r\n&nbsp;\r\n\r\n<p><strong>Note:</strong></p>\r\n\r\n<ul>\r\n\t<li>All values will be in the range of [0, 1000].</li>\r\n\t<li>The number of operations will be in the range of&nbsp;[1, 1000].</li>\r\n\t<li>Please do not use the built-in Queue library.</li>\r\n</ul>\r\n",
  "isPaidOnly": false,
  "difficulty": "Medium",
  "likes": 372,
  "dislikes": 63,
  "isLiked": null,
  "similarQuestions": "[{\"title\": \"Design Circular Deque\", \"titleSlug\": \"design-circular-deque\", \"difficulty\": \"Medium\", \"translatedTitle\": null}]",
  "contributors": [
    {
      "username": "tinylic",
      "profileUrl": "/tinylic/",
      "avatarUrl": "https://www.gravatar.com/avatar/c8f3bf6706478175081358c2ced2ae2f.png?s=200"
    }
  ],
  "topicTags": [
    {
      "name": "Design",
      "slug": "design"
    },
    {
      "name": "Queue",
      "slug": "queue"
    }
  ],
  "companyTagStats": "{\"1\": [{\"taggedByAdmin\": false, \"name\": \"Amazon\", \"slug\": \"amazon\", \"timesEncountered\": 4}, {\"taggedByAdmin\": false, \"name\": \"Microsoft\", \"slug\": \"microsoft\", \"timesEncountered\": 3}, {\"taggedByAdmin\": false, \"name\": \"Facebook\", \"slug\": \"facebook\", \"timesEncountered\": 2}, {\"taggedByAdmin\": false, \"name\": \"Citadel\", \"slug\": \"citadel\", \"timesEncountered\": 2}, {\"taggedByAdmin\": false, \"name\": \"Splunk\", \"slug\": \"splunk\", \"timesEncountered\": 2}], \"2\": [{\"taggedByAdmin\": false, \"name\": \"Google\", \"slug\": \"google\", \"timesEncountered\": 4}, {\"taggedByAdmin\": false, \"name\": \"Airbnb\", \"slug\": \"airbnb\", \"timesEncountered\": 2}], \"3\": []}",
  "codeSnippets": [
    {
      "lang": "C++",
      "code": "class MyCircularQueue {\npublic:\n    /** Initialize your data structure here. Set the size of the queue to be k. */\n    MyCircularQueue(int k) {\n        \n    }\n    \n    /** Insert an element into the circular queue. Return true if the operation is successful. */\n    bool enQueue(int value) {\n        \n    }\n    \n    /** Delete an element from the circular queue. Return true if the operation is successful. */\n    bool deQueue() {\n        \n    }\n    \n    /** Get the front item from the queue. */\n    int Front() {\n        \n    }\n    \n    /** Get the last item from the queue. */\n    int Rear() {\n        \n    }\n    \n    /** Checks whether the circular queue is empty or not. */\n    bool isEmpty() {\n        \n    }\n    \n    /** Checks whether the circular queue is full or not. */\n    bool isFull() {\n        \n    }\n};\n\n/**\n * Your MyCircularQueue object will be instantiated and called as such:\n * MyCircularQueue* obj = new MyCircularQueue(k);\n * bool param_1 = obj->enQueue(value);\n * bool param_2 = obj->deQueue();\n * int param_3 = obj->Front();\n * int param_4 = obj->Rear();\n * bool param_5 = obj->isEmpty();\n * bool param_6 = obj->isFull();\n */"
    },
    {
      "lang": "Java",
      "code": "class MyCircularQueue {\n\n    /** Initialize your data structure here. Set the size of the queue to be k. */\n    public MyCircularQueue(int k) {\n        \n    }\n    \n    /** Insert an element into the circular queue. Return true if the operation is successful. */\n    public boolean enQueue(int value) {\n        \n    }\n    \n    /** Delete an element from the circular queue. Return true if the operation is successful. */\n    public boolean deQueue() {\n        \n    }\n    \n    /** Get the front item from the queue. */\n    public int Front() {\n        \n    }\n    \n    /** Get the last item from the queue. */\n    public int Rear() {\n        \n    }\n    \n    /** Checks whether the circular queue is empty or not. */\n    public boolean isEmpty() {\n        \n    }\n    \n    /** Checks whether the circular queue is full or not. */\n    public boolean isFull() {\n        \n    }\n}\n\n/**\n * Your MyCircularQueue object will be instantiated and called as such:\n * MyCircularQueue obj = new MyCircularQueue(k);\n * boolean param_1 = obj.enQueue(value);\n * boolean param_2 = obj.deQueue();\n * int param_3 = obj.Front();\n * int param_4 = obj.Rear();\n * boolean param_5 = obj.isEmpty();\n * boolean param_6 = obj.isFull();\n */"
    },
    {
      "lang": "Python",
      "code": "class MyCircularQueue(object):\n\n    def __init__(self, k):\n        \"\"\"\n        Initialize your data structure here. Set the size of the queue to be k.\n        :type k: int\n        \"\"\"\n        \n\n    def enQueue(self, value):\n        \"\"\"\n        Insert an element into the circular queue. Return true if the operation is successful.\n        :type value: int\n        :rtype: bool\n        \"\"\"\n        \n\n    def deQueue(self):\n        \"\"\"\n        Delete an element from the circular queue. Return true if the operation is successful.\n        :rtype: bool\n        \"\"\"\n        \n\n    def Front(self):\n        \"\"\"\n        Get the front item from the queue.\n        :rtype: int\n        \"\"\"\n        \n\n    def Rear(self):\n        \"\"\"\n        Get the last item from the queue.\n        :rtype: int\n        \"\"\"\n        \n\n    def isEmpty(self):\n        \"\"\"\n        Checks whether the circular queue is empty or not.\n        :rtype: bool\n        \"\"\"\n        \n\n    def isFull(self):\n        \"\"\"\n        Checks whether the circular queue is full or not.\n        :rtype: bool\n        \"\"\"\n        \n\n\n# Your MyCircularQueue object will be instantiated and called as such:\n# obj = MyCircularQueue(k)\n# param_1 = obj.enQueue(value)\n# param_2 = obj.deQueue()\n# param_3 = obj.Front()\n# param_4 = obj.Rear()\n# param_5 = obj.isEmpty()\n# param_6 = obj.isFull()"
    },
    {
      "lang": "Python3",
      "code": "class MyCircularQueue:\n\n    def __init__(self, k: int):\n        \"\"\"\n        Initialize your data structure here. Set the size of the queue to be k.\n        \"\"\"\n        \n\n    def enQueue(self, value: int) -> bool:\n        \"\"\"\n        Insert an element into the circular queue. Return true if the operation is successful.\n        \"\"\"\n        \n\n    def deQueue(self) -> bool:\n        \"\"\"\n        Delete an element from the circular queue. Return true if the operation is successful.\n        \"\"\"\n        \n\n    def Front(self) -> int:\n        \"\"\"\n        Get the front item from the queue.\n        \"\"\"\n        \n\n    def Rear(self) -> int:\n        \"\"\"\n        Get the last item from the queue.\n        \"\"\"\n        \n\n    def isEmpty(self) -> bool:\n        \"\"\"\n        Checks whether the circular queue is empty or not.\n        \"\"\"\n        \n\n    def isFull(self) -> bool:\n        \"\"\"\n        Checks whether the circular queue is full or not.\n        \"\"\"\n        \n\n\n# Your MyCircularQueue object will be instantiated and called as such:\n# obj = MyCircularQueue(k)\n# param_1 = obj.enQueue(value)\n# param_2 = obj.deQueue()\n# param_3 = obj.Front()\n# param_4 = obj.Rear()\n# param_5 = obj.isEmpty()\n# param_6 = obj.isFull()"
    },
    {
      "lang": "C",
      "code": "\n\n\ntypedef struct {\n    \n} MyCircularQueue;\n\n/** Initialize your data structure here. Set the size of the queue to be k. */\n\nMyCircularQueue* myCircularQueueCreate(int k) {\n    \n}\n\n/** Insert an element into the circular queue. Return true if the operation is successful. */\nbool myCircularQueueEnQueue(MyCircularQueue* obj, int value) {\n  \n}\n\n/** Delete an element from the circular queue. Return true if the operation is successful. */\nbool myCircularQueueDeQueue(MyCircularQueue* obj) {\n  \n}\n\n/** Get the front item from the queue. */\nint myCircularQueueFront(MyCircularQueue* obj) {\n  \n}\n\n/** Get the last item from the queue. */\nint myCircularQueueRear(MyCircularQueue* obj) {\n  \n}\n\n/** Checks whether the circular queue is empty or not. */\nbool myCircularQueueIsEmpty(MyCircularQueue* obj) {\n  \n}\n\n/** Checks whether the circular queue is full or not. */\nbool myCircularQueueIsFull(MyCircularQueue* obj) {\n  \n}\n\nvoid myCircularQueueFree(MyCircularQueue* obj) {\n    \n}\n\n/**\n * Your MyCircularQueue struct will be instantiated and called as such:\n * MyCircularQueue* obj = myCircularQueueCreate(k);\n * bool param_1 = myCircularQueueEnQueue(obj, value);\n \n * bool param_2 = myCircularQueueDeQueue(obj);\n \n * int param_3 = myCircularQueueFront(obj);\n \n * int param_4 = myCircularQueueRear(obj);\n \n * bool param_5 = myCircularQueueIsEmpty(obj);\n \n * bool param_6 = myCircularQueueIsFull(obj);\n \n * myCircularQueueFree(obj);\n*/"
    },
    {
      "lang": "C#",
      "code": "public class MyCircularQueue {\n\n    /** Initialize your data structure here. Set the size of the queue to be k. */\n    public MyCircularQueue(int k) {\n        \n    }\n    \n    /** Insert an element into the circular queue. Return true if the operation is successful. */\n    public bool EnQueue(int value) {\n        \n    }\n    \n    /** Delete an element from the circular queue. Return true if the operation is successful. */\n    public bool DeQueue() {\n        \n    }\n    \n    /** Get the front item from the queue. */\n    public int Front() {\n        \n    }\n    \n    /** Get the last item from the queue. */\n    public int Rear() {\n        \n    }\n    \n    /** Checks whether the circular queue is empty or not. */\n    public bool IsEmpty() {\n        \n    }\n    \n    /** Checks whether the circular queue is full or not. */\n    public bool IsFull() {\n        \n    }\n}\n\n/**\n * Your MyCircularQueue object will be instantiated and called as such:\n * MyCircularQueue obj = new MyCircularQueue(k);\n * bool param_1 = obj.EnQueue(value);\n * bool param_2 = obj.DeQueue();\n * int param_3 = obj.Front();\n * int param_4 = obj.Rear();\n * bool param_5 = obj.IsEmpty();\n * bool param_6 = obj.IsFull();\n */"
    },
    {
      "lang": "JavaScript",
      "code": "/**\n * Initialize your data structure here. Set the size of the queue to be k.\n * @param {number} k\n */\nvar MyCircularQueue = function(k) {\n    \n};\n\n/**\n * Insert an element into the circular queue. Return true if the operation is successful. \n * @param {number} value\n * @return {boolean}\n */\nMyCircularQueue.prototype.enQueue = function(value) {\n    \n};\n\n/**\n * Delete an element from the circular queue. Return true if the operation is successful.\n * @return {boolean}\n */\nMyCircularQueue.prototype.deQueue = function() {\n    \n};\n\n/**\n * Get the front item from the queue.\n * @return {number}\n */\nMyCircularQueue.prototype.Front = function() {\n    \n};\n\n/**\n * Get the last item from the queue.\n * @return {number}\n */\nMyCircularQueue.prototype.Rear = function() {\n    \n};\n\n/**\n * Checks whether the circular queue is empty or not.\n * @return {boolean}\n */\nMyCircularQueue.prototype.isEmpty = function() {\n    \n};\n\n/**\n * Checks whether the circular queue is full or not.\n * @return {boolean}\n */\nMyCircularQueue.prototype.isFull = function() {\n    \n};\n\n/** \n * Your MyCircularQueue object will be instantiated and called as such:\n * var obj = new MyCircularQueue(k)\n * var param_1 = obj.enQueue(value)\n * var param_2 = obj.deQueue()\n * var param_3 = obj.Front()\n * var param_4 = obj.Rear()\n * var param_5 = obj.isEmpty()\n * var param_6 = obj.isFull()\n */"
    },
    {
      "lang": "Ruby",
      "code": "class MyCircularQueue\n\n=begin\n    Initialize your data structure here. Set the size of the queue to be k.\n    :type k: Integer\n=end\n    def initialize(k)\n        \n    end\n\n\n=begin\n    Insert an element into the circular queue. Return true if the operation is successful.\n    :type value: Integer\n    :rtype: Boolean\n=end\n    def en_queue(value)\n        \n    end\n\n\n=begin\n    Delete an element from the circular queue. Return true if the operation is successful.\n    :rtype: Boolean\n=end\n    def de_queue()\n        \n    end\n\n\n=begin\n    Get the front item from the queue.\n    :rtype: Integer\n=end\n    def front()\n        \n    end\n\n\n=begin\n    Get the last item from the queue.\n    :rtype: Integer\n=end\n    def rear()\n        \n    end\n\n\n=begin\n    Checks whether the circular queue is empty or not.\n    :rtype: Boolean\n=end\n    def is_empty()\n        \n    end\n\n\n=begin\n    Checks whether the circular queue is full or not.\n    :rtype: Boolean\n=end\n    def is_full()\n        \n    end\n\n\nend\n\n# Your MyCircularQueue object will be instantiated and called as such:\n# obj = MyCircularQueue.new(k)\n# param_1 = obj.en_queue(value)\n# param_2 = obj.de_queue()\n# param_3 = obj.front()\n# param_4 = obj.rear()\n# param_5 = obj.is_empty()\n# param_6 = obj.is_full()"
    },
    {
      "lang": "Swift",
      "code": "\nclass MyCircularQueue {\n\n    /** Initialize your data structure here. Set the size of the queue to be k. */\n    init(_ k: Int) {\n        \n    }\n    \n    /** Insert an element into the circular queue. Return true if the operation is successful. */\n    func enQueue(_ value: Int) -> Bool {\n        \n    }\n    \n    /** Delete an element from the circular queue. Return true if the operation is successful. */\n    func deQueue() -> Bool {\n        \n    }\n    \n    /** Get the front item from the queue. */\n    func Front() -> Int {\n        \n    }\n    \n    /** Get the last item from the queue. */\n    func Rear() -> Int {\n        \n    }\n    \n    /** Checks whether the circular queue is empty or not. */\n    func isEmpty() -> Bool {\n        \n    }\n    \n    /** Checks whether the circular queue is full or not. */\n    func isFull() -> Bool {\n        \n    }\n}\n\n/**\n * Your MyCircularQueue object will be instantiated and called as such:\n * let obj = MyCircularQueue(k)\n * let ret_1: Bool = obj.enQueue(value)\n * let ret_2: Bool = obj.deQueue()\n * let ret_3: Int = obj.Front()\n * let ret_4: Int = obj.Rear()\n * let ret_5: Bool = obj.isEmpty()\n * let ret_6: Bool = obj.isFull()\n */"
    },
    {
      "lang": "Go",
      "code": "type MyCircularQueue struct {\n    \n}\n\n\n/** Initialize your data structure here. Set the size of the queue to be k. */\nfunc Constructor(k int) MyCircularQueue {\n    \n}\n\n\n/** Insert an element into the circular queue. Return true if the operation is successful. */\nfunc (this *MyCircularQueue) EnQueue(value int) bool {\n    \n}\n\n\n/** Delete an element from the circular queue. Return true if the operation is successful. */\nfunc (this *MyCircularQueue) DeQueue() bool {\n    \n}\n\n\n/** Get the front item from the queue. */\nfunc (this *MyCircularQueue) Front() int {\n    \n}\n\n\n/** Get the last item from the queue. */\nfunc (this *MyCircularQueue) Rear() int {\n    \n}\n\n\n/** Checks whether the circular queue is empty or not. */\nfunc (this *MyCircularQueue) IsEmpty() bool {\n    \n}\n\n\n/** Checks whether the circular queue is full or not. */\nfunc (this *MyCircularQueue) IsFull() bool {\n    \n}\n\n\n/**\n * Your MyCircularQueue object will be instantiated and called as such:\n * obj := Constructor(k);\n * param_1 := obj.EnQueue(value);\n * param_2 := obj.DeQueue();\n * param_3 := obj.Front();\n * param_4 := obj.Rear();\n * param_5 := obj.IsEmpty();\n * param_6 := obj.IsFull();\n */"
    },
    {
      "lang": "Scala",
      "code": "class MyCircularQueue(_k: Int) {\n\n    /** Initialize your data structure here. Set the size of the queue to be k. */\n    \n\n    /** Insert an element into the circular queue. Return true if the operation is successful. */\n    def enQueue(value: Int): Boolean = {\n        \n    }\n\n    /** Delete an element from the circular queue. Return true if the operation is successful. */\n    def deQueue(): Boolean = {\n        \n    }\n\n    /** Get the front item from the queue. */\n    def Front(): Int = {\n        \n    }\n\n    /** Get the last item from the queue. */\n    def Rear(): Int = {\n        \n    }\n\n    /** Checks whether the circular queue is empty or not. */\n    def isEmpty(): Boolean = {\n        \n    }\n\n    /** Checks whether the circular queue is full or not. */\n    def isFull(): Boolean = {\n        \n    }\n\n}\n\n/**\n * Your MyCircularQueue object will be instantiated and called as such:\n * var obj = new MyCircularQueue(k)\n * var param_1 = obj.enQueue(value)\n * var param_2 = obj.deQueue()\n * var param_3 = obj.Front()\n * var param_4 = obj.Rear()\n * var param_5 = obj.isEmpty()\n * var param_6 = obj.isFull()\n */"
    },
    {
      "lang": "Kotlin",
      "code": "class MyCircularQueue(k: Int) {\n\n    /** Initialize your data structure here. Set the size of the queue to be k. */\n    \n\n    /** Insert an element into the circular queue. Return true if the operation is successful. */\n    fun enQueue(value: Int): Boolean {\n        \n    }\n\n    /** Delete an element from the circular queue. Return true if the operation is successful. */\n    fun deQueue(): Boolean {\n        \n    }\n\n    /** Get the front item from the queue. */\n    fun Front(): Int {\n        \n    }\n\n    /** Get the last item from the queue. */\n    fun Rear(): Int {\n        \n    }\n\n    /** Checks whether the circular queue is empty or not. */\n    fun isEmpty(): Boolean {\n        \n    }\n\n    /** Checks whether the circular queue is full or not. */\n    fun isFull(): Boolean {\n        \n    }\n\n}\n\n/**\n * Your MyCircularQueue object will be instantiated and called as such:\n * var obj = MyCircularQueue(k)\n * var param_1 = obj.enQueue(value)\n * var param_2 = obj.deQueue()\n * var param_3 = obj.Front()\n * var param_4 = obj.Rear()\n * var param_5 = obj.isEmpty()\n * var param_6 = obj.isFull()\n */"
    },
    {
      "lang": "Rust",
      "code": "struct MyCircularQueue {\n\n}\n\n\n/** \n * `&self` means the method takes an immutable reference.\n * If you need a mutable reference, change it to `&mut self` instead.\n */\nimpl MyCircularQueue {\n\n    /** Initialize your data structure here. Set the size of the queue to be k. */\n    fn new(k: i32) -> Self {\n        \n    }\n    \n    /** Insert an element into the circular queue. Return true if the operation is successful. */\n    fn en_queue(&self, value: i32) -> bool {\n        \n    }\n    \n    /** Delete an element from the circular queue. Return true if the operation is successful. */\n    fn de_queue(&self) -> bool {\n        \n    }\n    \n    /** Get the front item from the queue. */\n    fn front(&self) -> i32 {\n        \n    }\n    \n    /** Get the last item from the queue. */\n    fn rear(&self) -> i32 {\n        \n    }\n    \n    /** Checks whether the circular queue is empty or not. */\n    fn is_empty(&self) -> bool {\n        \n    }\n    \n    /** Checks whether the circular queue is full or not. */\n    fn is_full(&self) -> bool {\n        \n    }\n}\n\n/**\n * Your MyCircularQueue object will be instantiated and called as such:\n * let obj = MyCircularQueue::new(k);\n * let ret_1: bool = obj.en_queue(value);\n * let ret_2: bool = obj.de_queue();\n * let ret_3: i32 = obj.front();\n * let ret_4: i32 = obj.rear();\n * let ret_5: bool = obj.is_empty();\n * let ret_6: bool = obj.is_full();\n */"
    },
    {
      "lang": "PHP",
      "code": "class MyCircularQueue {\n    /**\n     * Initialize your data structure here. Set the size of the queue to be k.\n     * @param Integer $k\n     */\n    function __construct($k) {\n        \n    }\n  \n    /**\n     * Insert an element into the circular queue. Return true if the operation is successful.\n     * @param Integer $value\n     * @return Boolean\n     */\n    function enQueue($value) {\n        \n    }\n  \n    /**\n     * Delete an element from the circular queue. Return true if the operation is successful.\n     * @return Boolean\n     */\n    function deQueue() {\n        \n    }\n  \n    /**\n     * Get the front item from the queue.\n     * @return Integer\n     */\n    function Front() {\n        \n    }\n  \n    /**\n     * Get the last item from the queue.\n     * @return Integer\n     */\n    function Rear() {\n        \n    }\n  \n    /**\n     * Checks whether the circular queue is empty or not.\n     * @return Boolean\n     */\n    function isEmpty() {\n        \n    }\n  \n    /**\n     * Checks whether the circular queue is full or not.\n     * @return Boolean\n     */\n    function isFull() {\n        \n    }\n}\n\n/**\n * Your MyCircularQueue object will be instantiated and called as such:\n * $obj = MyCircularQueue($k);\n * $ret_1 = $obj->enQueue($value);\n * $ret_2 = $obj->deQueue();\n * $ret_3 = $obj->Front();\n * $ret_4 = $obj->Rear();\n * $ret_5 = $obj->isEmpty();\n * $ret_6 = $obj->isFull();\n */"
    }
  ],
  "stats": "{\"totalAccepted\": \"42.3K\", \"totalSubmission\": \"101.8K\", \"totalAcceptedRaw\": 42330, \"totalSubmissionRaw\": 101779, \"acRate\": \"41.6%\"}",
  "hints": [],
  "solution": {
    "id": "811",
    "canSeeDetail": true,
    "url": "/articles/design-circular-queue/",
    "content": "[TOC]\n\n## Solution\n\n---\n\n#### Approach 1: Array\n\n**Intuition**\n\nBased on the description of the problem, an intuitive data structure that meets all the requirements would be a **_ring_** where the head and the tail are adjacent to each other.\n\nHowever, there does not exist a ring data structure in any programming language. A similar data structure at our disposal is the one called **_Array_** which is a collection of elements that reside continuously in one dimensional space.\n\nThe essence of many design problems, is how one can build more advanced data structures with the basic building blocks such as Array.\n\n>In this case, to build a circular queue, we could form a _virtual_ ring structure with the Array, via the manipulation of index.\n\nGiven a fixed size array, any of the elements could be considered as a head in a queue. As long as we know the length of the queue, we then can instantly locate its tail, based on the following formula:\n\n$$\n\\text{tailIndex} = (\\text{headIndex} + \\text{count} - 1) \\mod \\text{capacity}\n$$\n\nwhere the variable `capacity` is the size of the array, the `count` is the length of the queue and the `headIndex` and `tailIndex` are the indice of head and tail elements respectively in the array. Here we showcase a few examples how a circular queue could reside in a fixed size array.\n\n![pic](../Figures/622/622_queue_with_array.png)\n\n\n**Algorithm**\n\nThe procedure to design a data structure lies essentially on how we design the _attributes_ within the data structure.\n\nOne of the traits of a good design is to have as less attributes as possible, which arguably could bring several benefits. \n\n- Less attributes usually implies little or no redundancy among the attributes.\n<br/>\n- The less redundant the attributes are, the simpler the manipulation logic, which eventually could be less error-prone.\n</br>\n- Less attributes also requires less space and therefore it could also bring efficiency to the runtime performance.\n\n_However, it is not advisable to seek for the minimum set of attributes._ Sometimes, a bit of redundancy could help with the time complexity. After all, like many other problems, we are trying to strike a balance between the space and the time.\n\nFollowing the above principles, here we give a list of attributes and the thoughts behind each attribute.\n\n- `queue`: a fixed size array to hold the elements for the circular queue.\n</br>\n- `headIndex`: an integer which indicates the current head element in the circular queue.\n</br>\n- `count`: the current length of the circular queue, _i.e._ the number of elements in the circular queue. Together with the `headIndex`, we could locate the current tail element in the circular queue, based on the formula we gave previously. Therefore, we choose not to add another attribute for the index of tail.\n<br/>\n- `capacity`: the capacity of the circular queue, _i.e._ the maximum number of elements that can be hold in the queue. One might argument that it is not absolutely necessary to add this attribute, since we could obtain the capacity from the `queue` attribute. It is true. Yet, since we would frequently use this `capacity` in our algorithm, we choose to keep it as an attribute, instead of invoking function `len(queue)` in Python at every occasion. Though in other programming languages such as Java, it might be more efficient to omit this attribute, since it is part of the attributes (`queue.length`) in Java array. _Note: for the sake of consistency, we keep this attribute for all implementations._\n\n\n<iframe src=\"https://leetcode.com/playground/ict5MKdY/shared\" frameBorder=\"0\" width=\"100%\" height=\"500\" name=\"ict5MKdY\"></iframe>\n\n**Complexity**\n\n- Time complexity: $$\\mathcal{O}(1)$$. All of the methods in our circular data structure is of constant time complexity.\n<br/>\n- Space Complexity: $$\\mathcal{O}(N)$$. The overall space complexity of the data structure is linear, where $$N$$ is the pre-assigned capacity of the queue. _However, it is worth mentioning that the memory consumption of the data structure remains as its pre-assigned capacity during its entire life cycle._\n\n\n**Improvement: Thread-Safe**\n\nOne might be happy with the above implementation, after all it meets all the requirements of the problem.\n\n>As a followup question though, an interviewer might ask one to point out a _potential defect_ about the implementation and the solution.\n\nThis time, it is not about the space or time complexity, but **_concurrency_**. Our circular queue is NOT _thread-safe_. One could end up with _corrupting_ our data structure in a multi-threaded environment.\n\nFor example, here is an execution sequence where we exceed the designed capacity of the queue and overwrite the tail element undesirably.\n\n![pic](../Figures/622/622_concurrency.png)\n\nThe above scenario is called race conditions as described in the problem of [Print in Order](https://leetcode.com/problems/print-in-order/solution/). One can find more [concurrency problems](https://leetcode.com/problemset/concurrency/) to practice on LeetCode.\n\nThere are several ways to mitigate the above concurrency problem. \nTake the function `enQueue(int value)` as an example, we show how we can make the function thread-safe in the following implementation:\n\n<iframe src=\"https://leetcode.com/playground/BUYoD5Gc/shared\" frameBorder=\"0\" width=\"100%\" height=\"500\" name=\"BUYoD5Gc\"></iframe>\n\nWith the protection of locks, we now feel more confident to apply our circular queue in critical scenarios.\n\nThe above improvement does not alter the time and space complexity of the original data structure, though overall the thread-safe measures do incur some extra costs.\n<br/>\n<br/>\n\n---\n\n#### Approach 2: Singly-Linked List\n\n**Intuition**\n\nSimilar with Array, the _Linked List_ is another common building block for more advanced data structures.\n\n>Different than a fixed size Array, a linked list could be more memory efficient, since it does not pre-allocate memory for unused capacity. \n\nWith a singly-linked list, we could design a circular queue with the same time and space complexity as the approach with Array. But we could gain some memory efficiency, since we don't need to pre-allocate the memory upfront.\n\nIn the following graph, we show how the operations of `enQueue()` and `deQueue()` can be done via singly-linked list.\n\n![pic](../Figures/622/622_queue_linked_list.png)\n\n\n**Algorithm**\n\nHere we give a list of attributes in our circular queue data structure and the thoughts behind each attribute.\n\n- `capacity`: the maximum number of elements that the circular queue will hold.\n<br/>\n- `head`: the reference to the head element in the queue.\n</br>\n- `count`: the current length of the queue. This is a critical attribute that helps us to do the boundary check in each method.\n<br/>\n- `tail`: the reference to the tail element in the queue. Unlike the Array approach, we need to explicitly keep the reference to the tail element. Without this attribute, it would take us $$\\mathcal{O}(N)$$ time complexity to locate the tail element from the head element.\n</br>\n\n<iframe src=\"https://leetcode.com/playground/MDN9TRSH/shared\" frameBorder=\"0\" width=\"100%\" height=\"500\" name=\"MDN9TRSH\"></iframe>\n\n\n**Complexity**\n\n- Time complexity: $$\\mathcal{O}(1)$$ for each method in our circular queue.\n<br/>\n- Space Complexity: The upper bound of the memory consumption for our circular queue would be $$\\mathcal{O}(N)$$, same as the Array approach. However, it should be more memory efficient as we discussed in the intuition section.\n<br/>\n<br/>\n\n---\n\nAnalysis written by @[liaison](https://leetcode.com/liaison/) and @[andvary](https://leetcode.com/andvary/)",
    "contentTypeId": "107",
    "rating": {
      "id": "779",
      "count": 9,
      "average": 4.889,
      "userRating": null
    }
  },
  "status": null,
  "sampleTestCase": "[\"MyCircularQueue\",\"enQueue\",\"enQueue\",\"enQueue\",\"enQueue\",\"Rear\",\"isFull\",\"deQueue\",\"enQueue\",\"Rear\"]\n[[3],[1],[2],[3],[4],[],[],[],[4],[]]",
  "metaData": "{\r\n    \"classname\": \"MyCircularQueue\",\r\n    \"maxbytesperline\": 400000,\r\n    \"constructor\": {\r\n        \"params\": [\r\n            {\r\n                \"type\": \"integer\",\r\n                \"name\": \"k\"\r\n            }\r\n        ],\r\n        \"comment\": \"Initialize your data structure here. Set the size of the queue to be k.\"\r\n    },\r\n    \"methods\": [\r\n        {\r\n            \"name\" : \"enQueue\",\r\n            \"params\": [\r\n                {\r\n                    \"type\": \"integer\",\r\n                    \"name\": \"value\"\r\n                }\r\n            ],\r\n            \"return\": {\r\n                \"type\": \"boolean\"\r\n            },\r\n            \"comment\": \"Insert an element into the circular queue. Return true if the operation is successful.\"\r\n        },\r\n        {\r\n            \"name\" : \"deQueue\",\r\n            \"params\": [\r\n                \r\n            ],\r\n            \"return\": {\r\n                \"type\": \"boolean\"\r\n            },\r\n            \"comment\": \"Delete an element from the circular queue. Return true if the operation is successful.\"\r\n        },\r\n        {\r\n            \"name\" : \"Front\",\r\n            \"params\": [\r\n                \r\n            ],\r\n            \"return\": {\r\n                \"type\": \"integer\"\r\n            },\r\n            \"comment\": \"Get the front item from the queue.\"\r\n        },\r\n        {\r\n            \"name\" : \"Rear\",\r\n            \"params\": [\r\n                \r\n            ],\r\n            \"return\": {\r\n                \"type\": \"integer\"\r\n            },\r\n            \"comment\": \"Get the last item from the queue.\"\r\n        },\r\n        {\r\n            \"name\" : \"isEmpty\",\r\n            \"params\": [\r\n                \r\n            ],\r\n            \"return\": {\r\n                \"type\": \"boolean\"\r\n            },\r\n            \"comment\": \"Checks whether the circular queue is empty or not.\"\r\n        },\r\n        {\r\n            \"name\" : \"isFull\",\r\n            \"params\": [\r\n                \r\n            ],\r\n            \"return\": {\r\n                \"type\": \"boolean\"\r\n            },\r\n            \"comment\": \"Checks whether the circular queue is full or not.\"\r\n        }\r\n    ],\r\n    \"systemdesign\": true,\r\n    \"params\": [\r\n        {\r\n            \"name\": \"inputs\",\r\n            \"type\": \"integer[]\"\r\n        },\r\n        {\r\n            \"name\": \"inputs\",\r\n            \"type\": \"integer[]\"\r\n        }\r\n    ],\r\n    \"return\": {\r\n        \"type\": \"list<String>\",\r\n        \"dealloc\": true\r\n    }\r\n}",
  "judgerAvailable": true,
  "judgeType": "large",
  "mysqlSchemas": [],
  "enableRunCode": true,
  "enableTestMode": false,
  "libraryUrl": null
}
