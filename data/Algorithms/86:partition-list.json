{
  "questionId": "86",
  "questionFrontendId": "86",
  "boundTopicId": null,
  "title": "Partition List",
  "titleSlug": "partition-list",
  "categoryTitle": "Algorithms",
  "content": "<p>Given a linked list and a value <em>x</em>, partition it such that all nodes less than <em>x</em> come before nodes greater than or equal to <em>x</em>.</p>\r\n\r\n<p>You should preserve the original relative order of the nodes in each of the two partitions.</p>\r\n\r\n<p><strong>Example:</strong></p>\r\n\r\n<pre>\r\n<strong>Input:</strong> head = 1-&gt;4-&gt;3-&gt;2-&gt;5-&gt;2, <em>x</em> = 3\r\n<strong>Output:</strong> 1-&gt;2-&gt;2-&gt;4-&gt;3-&gt;5\r\n</pre>\r\n",
  "isPaidOnly": false,
  "difficulty": "Medium",
  "likes": 915,
  "dislikes": 244,
  "isLiked": null,
  "similarQuestions": "[]",
  "contributors": [],
  "topicTags": [
    {
      "name": "Linked List",
      "slug": "linked-list"
    },
    {
      "name": "Two Pointers",
      "slug": "two-pointers"
    }
  ],
  "companyTagStats": "{\"2\": [{\"taggedByAdmin\": false, \"name\": \"Amazon\", \"slug\": \"amazon\", \"timesEncountered\": 6}, {\"taggedByAdmin\": false, \"name\": \"Microsoft\", \"slug\": \"microsoft\", \"timesEncountered\": 2}], \"1\": [], \"3\": []}",
  "codeSnippets": [
    {
      "lang": "C++",
      "code": "/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode(int x) : val(x), next(NULL) {}\n * };\n */\nclass Solution {\npublic:\n    ListNode* partition(ListNode* head, int x) {\n        \n    }\n};"
    },
    {
      "lang": "Java",
      "code": "/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode(int x) { val = x; }\n * }\n */\nclass Solution {\n    public ListNode partition(ListNode head, int x) {\n        \n    }\n}"
    },
    {
      "lang": "Python",
      "code": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, x):\n#         self.val = x\n#         self.next = None\n\nclass Solution(object):\n    def partition(self, head, x):\n        \"\"\"\n        :type head: ListNode\n        :type x: int\n        :rtype: ListNode\n        \"\"\"\n        "
    },
    {
      "lang": "Python3",
      "code": "# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, x):\n#         self.val = x\n#         self.next = None\n\nclass Solution:\n    def partition(self, head: ListNode, x: int) -> ListNode:\n        "
    },
    {
      "lang": "C",
      "code": "/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     struct ListNode *next;\n * };\n */\n\n\nstruct ListNode* partition(struct ListNode* head, int x){\n\n}\n\n"
    },
    {
      "lang": "C#",
      "code": "/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     public int val;\n *     public ListNode next;\n *     public ListNode(int x) { val = x; }\n * }\n */\npublic class Solution {\n    public ListNode Partition(ListNode head, int x) {\n        \n    }\n}"
    },
    {
      "lang": "JavaScript",
      "code": "/**\n * Definition for singly-linked list.\n * function ListNode(val) {\n *     this.val = val;\n *     this.next = null;\n * }\n */\n/**\n * @param {ListNode} head\n * @param {number} x\n * @return {ListNode}\n */\nvar partition = function(head, x) {\n    \n};"
    },
    {
      "lang": "Ruby",
      "code": "# Definition for singly-linked list.\n# class ListNode\n#     attr_accessor :val, :next\n#     def initialize(val)\n#         @val = val\n#         @next = nil\n#     end\n# end\n\n# @param {ListNode} head\n# @param {Integer} x\n# @return {ListNode}\ndef partition(head, x)\n    \nend"
    },
    {
      "lang": "Swift",
      "code": "/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     public var val: Int\n *     public var next: ListNode?\n *     public init(_ val: Int) {\n *         self.val = val\n *         self.next = nil\n *     }\n * }\n */\nclass Solution {\n    func partition(_ head: ListNode?, _ x: Int) -> ListNode? {\n        \n    }\n}"
    },
    {
      "lang": "Go",
      "code": "/**\n * Definition for singly-linked list.\n * type ListNode struct {\n *     Val int\n *     Next *ListNode\n * }\n */\nfunc partition(head *ListNode, x int) *ListNode {\n    \n}"
    },
    {
      "lang": "Scala",
      "code": "/**\n * Definition for singly-linked list.\n * class ListNode(var _x: Int = 0) {\n *   var next: ListNode = null\n *   var x: Int = _x\n * }\n */\nobject Solution {\n    def partition(head: ListNode, x: Int): ListNode = {\n        \n    }\n}"
    },
    {
      "lang": "Kotlin",
      "code": "/**\n * Example:\n * var li = ListNode(5)\n * var v = li.`val`\n * Definition for singly-linked list.\n * class ListNode(var `val`: Int) {\n *     var next: ListNode? = null\n * }\n */\nclass Solution {\n    fun partition(head: ListNode?, x: Int): ListNode? {\n        \n    }\n}"
    },
    {
      "lang": "Rust",
      "code": "// Definition for singly-linked list.\n// #[derive(PartialEq, Eq, Clone, Debug)]\n// pub struct ListNode {\n//   pub val: i32,\n//   pub next: Option<Box<ListNode>>\n// }\n// \n// impl ListNode {\n//   #[inline]\n//   fn new(val: i32) -> Self {\n//     ListNode {\n//       next: None,\n//       val\n//     }\n//   }\n// }\nimpl Solution {\n    pub fn partition(head: Option<Box<ListNode>>, x: i32) -> Option<Box<ListNode>> {\n        \n    }\n}"
    },
    {
      "lang": "PHP",
      "code": "/**\n * Definition for a singly-linked list.\n * class ListNode {\n *     public $val = 0;\n *     public $next = null;\n *     function __construct($val) { $this->val = $val; }\n * }\n */\nclass Solution {\n\n    /**\n     * @param ListNode $head\n     * @param Integer $x\n     * @return ListNode\n     */\n    function partition($head, $x) {\n        \n    }\n}"
    }
  ],
  "stats": "{\"totalAccepted\": \"188.2K\", \"totalSubmission\": \"479.9K\", \"totalAcceptedRaw\": 188175, \"totalSubmissionRaw\": 479873, \"acRate\": \"39.2%\"}",
  "hints": [],
  "solution": {
    "id": "654",
    "canSeeDetail": true,
    "url": "/articles/partition-list/",
    "content": "[TOC]\n\n## Solution\n\nThe problem wants us to reform the linked list structure, such that the\nelements lesser that a certain value `x`, come before the elements greater or\nequal to `x`. This essentially means in this reformed list, there would be a\npoint in the linked list `before` which all the elements would be smaller than\n`x` and `after` which all the elements would be greater or equal to `x`.\nLet's call this point as the `JOINT`.\n\n<center>\n<img src=\"../Figures/86/86_Partition_List_1.png\" width=\"700\"/>\n</center>\n\nReverse engineering the question tells us that if we break the reformed list\nat the `JOINT`, we will get two smaller linked lists, one with lesser elements\nand the other with elements greater or equal to `x`. In the solution, our main aim\nis to create these two linked lists and join them.\n\n#### Approach 1: Two Pointer Approach\n\n**Intuition**\n\nWe can take two pointers `before` and `after` to keep track of the two linked\nlists as described above. These two pointers could be\nused two create two separate lists and then these lists could be combined to\nform the desired reformed list.\n\n**Algorithm**\n\n1. Initialize two pointers `before` and `after`. In the implementation we have\ninitialized these two with a dummy `ListNode`. This helps to reduce the number\nof conditional checks we would need otherwise. You can try an implementation\nwhere you don't initialize with a dummy node and see it yourself!\n\n    <center>\n    <img src=\"../Figures/86/86_Partition_List_2.png\" width=\"400\"/>\n    </center>\n    <center>Dummy Node Initialization</center><br/>\n\n2. Iterate the original linked list, using the `head` pointer.\n3. If the node's value pointed by `head` is *lesser* than `x`, the node should\nbe part of the `before` list. So we move it to `before` list.\n\n    <center>\n    <img src=\"../Figures/86/86_Partition_List_3.png\" width=\"700\"/>\n    </center>\n\n4. Else, the node should be part of `after` list. So we move it to `after` list.\n\n    <center>\n    <img src=\"../Figures/86/86_Partition_List_4.png\" width=\"700\"/>\n    </center>\n\n5. Once we are done with all the nodes in the original linked list, we would\nhave two list `before` and `after`. The original list nodes are either part of\n`before` list or `after` list, depending on its value.\n\n    <center>\n    <img src=\"../Figures/86/86_Partition_List_5.png\" width=\"700\"/>\n    </center>\n\n    *`Note:` Since we traverse the original linked list from left to right,\n    at no point would the order of nodes change relatively in the two lists. Another important thing to note here is that we show the original linked list intact in the above diagrams. However, in the implementation, we remove the nodes from the original linked list and attach them in the before or after list. We don't utilize any additional space. We simply move the nodes from the original list around.*\n\n6. Now, these two lists `before` and `after` can be combined to form the reformed list.\n\n    <center>\n    <img src=\"../Figures/86/86_Partition_List_6.png\" width=\"700\"/>\n    </center>\n\nWe did a dummy node initialization at the start to make implementation\neasier, you don't want that to be part of the returned list, hence just\nmove ahead one node in both the lists while combining the two list. Since both\nbefore and after have an extra node at the front.\n\n<iframe src=\"https://leetcode.com/playground/EjKysw9Z/shared\" frameBorder=\"0\" width=\"100%\" height=\"500\" name=\"EjKysw9Z\"></iframe>\n\n**Complexity Analysis**\n\n* Time Complexity: $$O(N)$$, where $$N$$ is the number of nodes in the original\nlinked list and we iterate the original list.\n* Space Complexity: $$O(1)$$, we have not utilized any extra space, the point to\nnote is that we are reforming the original list, by moving the original nodes, we\nhave not used any extra space as such.\n\n---\nAnalysis written by: [@godayaldivya](https://leetcode.com/godayaldivya/).",
    "contentTypeId": "107",
    "rating": {
      "id": "640",
      "count": 52,
      "average": 4.712,
      "userRating": null
    }
  },
  "status": null,
  "sampleTestCase": "[1,4,3,2,5,2]\n3",
  "metaData": "{\r\n  \"name\": \"partition\",\r\n  \"params\": [\r\n    {\r\n      \"name\": \"head\",\r\n      \"type\": \"ListNode\",\r\n      \"dealloc\": false\r\n    },\r\n    {\r\n      \"name\": \"x\",\r\n      \"type\": \"integer\"\r\n    }\r\n  ],\r\n  \"return\": {\r\n    \"type\": \"ListNode\",\r\n    \"dealloc\": true\r\n  }\r\n}",
  "judgerAvailable": true,
  "judgeType": "large",
  "mysqlSchemas": [],
  "enableRunCode": true,
  "enableTestMode": false,
  "libraryUrl": null
}
