{
  "questionId": "929",
  "questionFrontendId": "893",
  "boundTopicId": null,
  "title": "Groups of Special-Equivalent Strings",
  "titleSlug": "groups-of-special-equivalent-strings",
  "categoryTitle": "Algorithms",
  "content": "<p>You are given an array <code>A</code> of strings.</p>\r\n\r\n<p>A <em>move&nbsp;onto <code>S</code></em> consists of swapping any two even indexed characters of <code>S</code>, or any two odd indexed characters of <code>S</code>.</p>\r\n\r\n<p>Two strings <code>S</code> and <code>T</code> are&nbsp;<em>special-equivalent</em>&nbsp;if after any number of <em>moves onto <code>S</code></em>, <code>S == T</code>.</p>\r\n\r\n<p>For example, <code>S = &quot;zzxy&quot;</code> and <code>T = &quot;xyzz&quot;</code> are special-equivalent because we may make the moves <code>&quot;zzxy&quot; -&gt; &quot;xzzy&quot; -&gt; &quot;xyzz&quot;</code>&nbsp;that swap <code>S[0]</code> and <code>S[2]</code>, then <code>S[1]</code> and <code>S[3]</code>.</p>\r\n\r\n<p>Now, a <em>group of special-equivalent strings from <code>A</code></em>&nbsp;is a non-empty subset of&nbsp;A such that:</p>\r\n\r\n<ol>\r\n\t<li>Every pair of strings in the group are special equivalent, and;</li>\r\n\t<li>The group is the largest size possible (ie., there isn&#39;t a string S not in the group such that S is special equivalent to every string in the group)</li>\r\n</ol>\r\n\r\n<p>Return the number of groups of special-equivalent strings from <code>A</code>.</p>\r\n\r\n<div>&nbsp;</div>\r\n\r\n<div>\r\n<p><strong>Example 1:</strong></p>\r\n\r\n<pre>\r\n<strong>Input: </strong><span id=\"example-input-1-1\">[&quot;abcd&quot;,&quot;cdab&quot;,&quot;cbad&quot;,&quot;xyzz&quot;,&quot;zzxy&quot;,&quot;zzyx&quot;]</span>\r\n<strong>Output: </strong><span id=\"example-output-1\">3</span>\r\n<strong>Explanation: </strong>\r\nOne group is [&quot;abcd&quot;, &quot;cdab&quot;, &quot;cbad&quot;], since they are all pairwise special equivalent, and none of the other strings are all pairwise special equivalent to these.\r\n\r\nThe other two groups are [&quot;xyzz&quot;, &quot;zzxy&quot;] and [&quot;zzyx&quot;].  Note that in particular, &quot;zzxy&quot; is not special equivalent to &quot;zzyx&quot;.\r\n</pre>\r\n\r\n<div>\r\n<p><strong>Example 2:</strong></p>\r\n\r\n<pre>\r\n<strong>Input: </strong><span id=\"example-input-2-1\">[&quot;abc&quot;,&quot;acb&quot;,&quot;bac&quot;,&quot;bca&quot;,&quot;cab&quot;,&quot;cba&quot;]</span>\r\n<strong>Output: </strong><span id=\"example-output-2\">3</span></pre>\r\n\r\n<p>&nbsp;</p>\r\n</div>\r\n</div>\r\n\r\n<div>\r\n<div>\r\n<div>\r\n<div>\r\n<p><strong>Note:</strong></p>\r\n\r\n<ul>\r\n\t<li><code>1 &lt;= A.length &lt;= 1000</code></li>\r\n\t<li><code>1 &lt;= A[i].length &lt;= 20</code></li>\r\n\t<li>All <code>A[i]</code> have the same length.</li>\r\n\t<li>All <code>A[i]</code> consist of only lowercase letters.</li>\r\n</ul>\r\n</div>\r\n</div>\r\n</div>\r\n</div>\r\n",
  "isPaidOnly": false,
  "difficulty": "Easy",
  "likes": 187,
  "dislikes": 899,
  "isLiked": null,
  "similarQuestions": "[]",
  "contributors": [],
  "topicTags": [
    {
      "name": "String",
      "slug": "string"
    }
  ],
  "companyTagStats": "{\"3\": [{\"taggedByAdmin\": true, \"name\": \"Facebook\", \"slug\": \"facebook\", \"timesEncountered\": 0}], \"1\": [], \"2\": []}",
  "codeSnippets": [
    {
      "lang": "C++",
      "code": "class Solution {\r\npublic:\r\n    int numSpecialEquivGroups(vector<string>& A) {\r\n        \r\n    }\r\n};"
    },
    {
      "lang": "Java",
      "code": "class Solution {\n    public int numSpecialEquivGroups(String[] A) {\n        \n    }\n}"
    },
    {
      "lang": "Python",
      "code": "class Solution(object):\n    def numSpecialEquivGroups(self, A):\n        \"\"\"\n        :type A: List[str]\n        :rtype: int\n        \"\"\"\n        "
    },
    {
      "lang": "Python3",
      "code": "class Solution:\n    def numSpecialEquivGroups(self, A: List[str]) -> int:\n        "
    },
    {
      "lang": "C",
      "code": "\n\nint numSpecialEquivGroups(char ** A, int ASize){\n\n}\n\n"
    },
    {
      "lang": "C#",
      "code": "public class Solution {\r\n    public int NumSpecialEquivGroups(string[] A) {\r\n        \r\n    }\r\n}"
    },
    {
      "lang": "JavaScript",
      "code": "/**\n * @param {string[]} A\n * @return {number}\n */\nvar numSpecialEquivGroups = function(A) {\n    \n};"
    },
    {
      "lang": "Ruby",
      "code": "# @param {String[]} a\r\n# @return {Integer}\r\ndef num_special_equiv_groups(a)\r\n    \r\nend"
    },
    {
      "lang": "Swift",
      "code": "class Solution {\r\n    func numSpecialEquivGroups(_ A: [String]) -> Int {\r\n        \r\n    }\r\n}"
    },
    {
      "lang": "Go",
      "code": "func numSpecialEquivGroups(A []string) int {\r\n    \r\n}"
    },
    {
      "lang": "Scala",
      "code": "object Solution {\r\n    def numSpecialEquivGroups(A: Array[String]): Int = {\r\n        \r\n    }\r\n}"
    },
    {
      "lang": "Kotlin",
      "code": "class Solution {\r\n    fun numSpecialEquivGroups(A: Array<String>): Int {\r\n        \r\n    }\r\n}"
    },
    {
      "lang": "Rust",
      "code": "impl Solution {\n    pub fn num_special_equiv_groups(a: Vec<String>) -> i32 {\n        \n    }\n}"
    },
    {
      "lang": "PHP",
      "code": "class Solution {\n\n    /**\n     * @param String[] $A\n     * @return Integer\n     */\n    function numSpecialEquivGroups($A) {\n        \n    }\n}"
    }
  ],
  "stats": "{\"totalAccepted\": \"20.5K\", \"totalSubmission\": \"31.8K\", \"totalAcceptedRaw\": 20485, \"totalSubmissionRaw\": 31825, \"acRate\": \"64.4%\"}",
  "hints": [],
  "solution": {
    "id": "537",
    "canSeeDetail": true,
    "url": "/articles/groups-of-special-equivalent-strings/",
    "content": "[TOC]\n\n## Solution\n---\n#### Approach 1: Counting\n\n**Intuition and Algorithm**\n\nLet's try to characterize a special-equivalent string $$S$$, by finding a function $$\\mathcal{C}$$ so that $$S \\equiv T \\iff \\mathcal{C}(S) = \\mathcal{C}(T)$$.\n\nThrough swapping, we can permute the even indexed letters, and the odd indexed letters.  What characterizes these permutations is the count of the letters: all such permutations have the same count, and different counts have different permutations.\n\nThus, the function $$\\mathcal{C}(S) =$$ (the count of the even indexed letters in S, followed by the count of the odd indexed letters in S) successfully characterizes the equivalence relation.\n\nAfterwards, we count the number of unique $$\\mathcal{C}(S)$$ for $$S \\in A$$.\n\n<iframe src=\"https://leetcode.com/playground/VUyxHYTk/shared\" frameBorder=\"0\" width=\"100%\" height=\"259\" name=\"VUyxHYTk\"></iframe>\n\n**Complexity Analysis**\n\n* Time Complexity:  $$O(\\sum\\limits_{i} (A_i)\\text{.length})$$\n\n* Space Complexity:  $$O(N)$$, where $$N$$ is the length of `A`.\n<br />\n<br />\n\n\n---\n\n\nAnalysis written by: [@awice](https://leetcode.com/awice).",
    "contentTypeId": "107",
    "rating": {
      "id": "529",
      "count": 36,
      "average": 2.722,
      "userRating": null
    }
  },
  "status": null,
  "sampleTestCase": "[\"abcd\",\"cdab\",\"cbad\",\"xyzz\",\"zzxy\",\"zzyx\"]",
  "metaData": "{\r\n  \"name\": \"numSpecialEquivGroups\",\r\n  \"params\": [\r\n    {\r\n      \"name\": \"A\",\r\n      \"type\": \"string[]\"\r\n    }\r\n  ],\r\n  \"return\": {\r\n    \"type\": \"integer\"\r\n  }\r\n}\r\n",
  "judgerAvailable": true,
  "judgeType": "large",
  "mysqlSchemas": [],
  "enableRunCode": true,
  "enableTestMode": false,
  "libraryUrl": null
}
