{
  "questionId": "933",
  "questionFrontendId": "897",
  "boundTopicId": null,
  "title": "Increasing Order Search Tree",
  "titleSlug": "increasing-order-search-tree",
  "categoryTitle": "Algorithms",
  "content": "<p>Given a binary search tree, rearrange the tree in <strong>in-order</strong> so that the leftmost node in the tree is now the root of the tree, and every node has no left child and only 1 right child.</p>\r\n\r\n<pre>\r\n<strong>Example 1:</strong>\r\n<strong>Input:</strong> [5,3,6,2,4,null,8,1,null,null,null,7,9]\r\n\r\n       5\r\n      / \\\r\n    3    6\r\n   / \\    \\\r\n  2   4    8\r\n&nbsp;/        / \\ \r\n1        7   9\r\n\r\n<strong>Output:</strong> [1,null,2,null,3,null,4,null,5,null,6,null,7,null,8,null,9]\r\n\r\n 1\r\n&nbsp; \\\r\n&nbsp;  2\r\n&nbsp;   \\\r\n&nbsp;    3\r\n&nbsp;     \\\r\n&nbsp;      4\r\n&nbsp;       \\\r\n&nbsp;        5\r\n&nbsp;         \\\r\n&nbsp;          6\r\n&nbsp;           \\\r\n&nbsp;            7\r\n&nbsp;             \\\r\n&nbsp;              8\r\n&nbsp;               \\\r\n                 9  </pre>\r\n\r\n<p><strong>Note:</strong></p>\r\n\r\n<ol>\r\n\t<li>The number of nodes in the given tree will be between 1 and 100.</li>\r\n\t<li>Each node will have a unique integer value from 0 to 1000.</li>\r\n</ol>\r\n",
  "isPaidOnly": false,
  "difficulty": "Easy",
  "likes": 417,
  "dislikes": 395,
  "isLiked": null,
  "similarQuestions": "[]",
  "contributors": [
    {
      "username": "kool814",
      "profileUrl": "/kool814/",
      "avatarUrl": "https://assets.leetcode.com/users/karthiks814/avatar_1525448909.png"
    }
  ],
  "topicTags": [
    {
      "name": "Tree",
      "slug": "tree"
    },
    {
      "name": "Depth-first Search",
      "slug": "depth-first-search"
    }
  ],
  "companyTagStats": "{\"1\": [], \"2\": [], \"3\": []}",
  "codeSnippets": [
    {
      "lang": "C++",
      "code": "/**\r\n * Definition for a binary tree node.\r\n * struct TreeNode {\r\n *     int val;\r\n *     TreeNode *left;\r\n *     TreeNode *right;\r\n *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\r\n * };\r\n */\r\nclass Solution {\r\npublic:\r\n    TreeNode* increasingBST(TreeNode* root) {\r\n        \r\n    }\r\n};"
    },
    {
      "lang": "Java",
      "code": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode(int x) { val = x; }\n * }\n */\nclass Solution {\n    public TreeNode increasingBST(TreeNode root) {\n        \n    }\n}"
    },
    {
      "lang": "Python",
      "code": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, x):\n#         self.val = x\n#         self.left = None\n#         self.right = None\n\nclass Solution(object):\n    def increasingBST(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: TreeNode\n        \"\"\"\n        "
    },
    {
      "lang": "Python3",
      "code": "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, x):\n#         self.val = x\n#         self.left = None\n#         self.right = None\n\nclass Solution:\n    def increasingBST(self, root: TreeNode) -> TreeNode:\n        "
    },
    {
      "lang": "C",
      "code": "/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     struct TreeNode *left;\n *     struct TreeNode *right;\n * };\n */\n\n\nstruct TreeNode* increasingBST(struct TreeNode* root){\n\n}\n\n"
    },
    {
      "lang": "C#",
      "code": "/**\r\n * Definition for a binary tree node.\r\n * public class TreeNode {\r\n *     public int val;\r\n *     public TreeNode left;\r\n *     public TreeNode right;\r\n *     public TreeNode(int x) { val = x; }\r\n * }\r\n */\r\npublic class Solution {\r\n    public TreeNode IncreasingBST(TreeNode root) {\r\n        \r\n    }\r\n}"
    },
    {
      "lang": "JavaScript",
      "code": "/**\n * Definition for a binary tree node.\n * function TreeNode(val) {\n *     this.val = val;\n *     this.left = this.right = null;\n * }\n */\n/**\n * @param {TreeNode} root\n * @return {TreeNode}\n */\nvar increasingBST = function(root) {\n    \n};"
    },
    {
      "lang": "Ruby",
      "code": "# Definition for a binary tree node.\r\n# class TreeNode\r\n#     attr_accessor :val, :left, :right\r\n#     def initialize(val)\r\n#         @val = val\r\n#         @left, @right = nil, nil\r\n#     end\r\n# end\r\n\r\n# @param {TreeNode} root\r\n# @return {TreeNode}\r\ndef increasing_bst(root)\r\n    \r\nend"
    },
    {
      "lang": "Swift",
      "code": "/**\r\n * Definition for a binary tree node.\r\n * public class TreeNode {\r\n *     public var val: Int\r\n *     public var left: TreeNode?\r\n *     public var right: TreeNode?\r\n *     public init(_ val: Int) {\r\n *         self.val = val\r\n *         self.left = nil\r\n *         self.right = nil\r\n *     }\r\n * }\r\n */\r\nclass Solution {\r\n    func increasingBST(_ root: TreeNode?) -> TreeNode? {\r\n        \r\n    }\r\n}"
    },
    {
      "lang": "Go",
      "code": "/**\r\n * Definition for a binary tree node.\r\n * type TreeNode struct {\r\n *     Val int\r\n *     Left *TreeNode\r\n *     Right *TreeNode\r\n * }\r\n */\r\nfunc increasingBST(root *TreeNode) *TreeNode {\r\n    \r\n}"
    },
    {
      "lang": "Scala",
      "code": "/**\r\n * Definition for a binary tree node.\r\n * class TreeNode(var _value: Int) {\r\n *   var value: Int = _value\r\n *   var left: TreeNode = null\r\n *   var right: TreeNode = null\r\n * }\r\n */\r\nobject Solution {\r\n    def increasingBST(root: TreeNode): TreeNode = {\r\n        \r\n    }\r\n}"
    },
    {
      "lang": "Kotlin",
      "code": "/**\r\n * Example:\r\n * var ti = TreeNode(5)\r\n * var v = ti.`val`\r\n * Definition for a binary tree node.\r\n * class TreeNode(var `val`: Int) {\r\n *     var left: TreeNode? = null\r\n *     var right: TreeNode? = null\r\n * }\r\n */\r\nclass Solution {\r\n    fun increasingBST(root: TreeNode?): TreeNode? {\r\n        \r\n    }\r\n}"
    },
    {
      "lang": "Rust",
      "code": "// Definition for a binary tree node.\n// #[derive(Debug, PartialEq, Eq)]\n// pub struct TreeNode {\n//   pub val: i32,\n//   pub left: Option<Rc<RefCell<TreeNode>>>,\n//   pub right: Option<Rc<RefCell<TreeNode>>>,\n// }\n// \n// impl TreeNode {\n//   #[inline]\n//   pub fn new(val: i32) -> Self {\n//     TreeNode {\n//       val,\n//       left: None,\n//       right: None\n//     }\n//   }\n// }\nuse std::rc::Rc;\nuse std::cell::RefCell;\nimpl Solution {\n    pub fn increasing_bst(root: Option<Rc<RefCell<TreeNode>>>) -> Option<Rc<RefCell<TreeNode>>> {\n        \n    }\n}"
    },
    {
      "lang": "PHP",
      "code": "/**\n * Definition for a binary tree node.\n * class TreeNode {\n *     public $val = null;\n *     public $left = null;\n *     public $right = null;\n *     function __construct($value) { $this->val = $value; }\n * }\n */\nclass Solution {\n\n    /**\n     * @param TreeNode $root\n     * @return TreeNode\n     */\n    function increasingBST($root) {\n        \n    }\n}"
    }
  ],
  "stats": "{\"totalAccepted\": \"48.3K\", \"totalSubmission\": \"72.5K\", \"totalAcceptedRaw\": 48340, \"totalSubmissionRaw\": 72517, \"acRate\": \"66.7%\"}",
  "hints": [],
  "solution": {
    "id": "547",
    "canSeeDetail": true,
    "url": "/articles/increasing-order-search-tree/",
    "content": "[TOC]\n\n## Solution\n---\n#### Approach 1: In-Order Traversal\n\n**Intuition**\n\nThe definition of a binary search tree is that for every node, all the values of the left branch are less than the value at the root, and all the values of the right branch are greater than the value at the root.\n\nBecause of this, an *in-order traversal* of the nodes will yield all the values in increasing order.\n\n**Algorithm**\n\nOnce we have traversed all the nodes in increasing order, we can construct new nodes using those values to form the answer.\n\n<iframe src=\"https://leetcode.com/playground/RonWhYrN/shared\" frameBorder=\"0\" width=\"100%\" height=\"378\" name=\"RonWhYrN\"></iframe>\n\n**Complexity Analysis**\n\n* Time Complexity:  $$O(N)$$, where $$N$$ is the number of nodes in the given tree.\n\n* Space Complexity:  $$O(N)$$, the size of the answer.\n<br />\n<br />\n\n\n---\n#### Approach 2: Traversal with Relinking\n\n**Intuition and Algorithm**\n\nWe can perform the same in-order traversal as in *Approach 1*.  During the traversal, we'll construct the answer on the fly, reusing the nodes of the given tree by cutting their left child and adjoining them to the answer.\n\n<iframe src=\"https://leetcode.com/playground/5M7CYgmK/shared\" frameBorder=\"0\" width=\"100%\" height=\"361\" name=\"5M7CYgmK\"></iframe>\n\n**Complexity Analysis**\n\n* Time Complexity:  $$O(N)$$, where $$N$$ is the number of nodes in the given tree.\n\n* Space Complexity:  $$O(H)$$ in *additional* space complexity, where $$H$$ is the height of the given tree, and the size of the implicit call stack in our in-order traversal.\n<br />\n<br />\n\n\n---\n\n\nAnalysis written by: [@awice](https://leetcode.com/awice).",
    "contentTypeId": "107",
    "rating": {
      "id": "538",
      "count": 22,
      "average": 4.591,
      "userRating": null
    }
  },
  "status": null,
  "sampleTestCase": "[5,3,6,2,4,null,8,1,null,null,null,7,9]",
  "metaData": "{\r\n  \"name\": \"increasingBST\",\r\n  \"params\": [\r\n    {\r\n      \"name\": \"root\",\r\n      \"type\": \"TreeNode\"\r\n    }\r\n  ],\r\n  \"return\": {\r\n    \"type\": \"TreeNode\"\r\n  }\r\n}\r\n",
  "judgerAvailable": true,
  "judgeType": "large",
  "mysqlSchemas": [],
  "enableRunCode": true,
  "enableTestMode": false,
  "libraryUrl": null
}
