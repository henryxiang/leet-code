{
  "questionId": "940",
  "questionFrontendId": "904",
  "boundTopicId": null,
  "title": "Fruit Into Baskets",
  "titleSlug": "fruit-into-baskets",
  "categoryTitle": "Algorithms",
  "content": "<p>In a row of trees, the <code>i</code>-th tree&nbsp;produces&nbsp;fruit with type&nbsp;<code>tree[i]</code>.</p>\r\n\r\n<p>You <strong>start at any tree&nbsp;of your choice</strong>, then repeatedly perform the following steps:</p>\r\n\r\n<ol>\r\n\t<li>Add one piece of fruit from this tree to your baskets.&nbsp; If you cannot, stop.</li>\r\n\t<li>Move to the next tree to the right of the current tree.&nbsp; If there is no tree to the right, stop.</li>\r\n</ol>\r\n\r\n<p>Note that you do not have any choice after the initial choice of starting tree:&nbsp;you must perform step 1, then step 2, then back to step 1, then step 2, and so on until you stop.</p>\r\n\r\n<p>You have two baskets, and each basket can carry any quantity of fruit, but you want each basket to only carry one type of fruit each.</p>\r\n\r\n<p>What is the total amount of fruit you can collect with this procedure?</p>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p><strong>Example 1:</strong></p>\r\n\r\n<pre>\r\n<strong>Input: </strong><span id=\"example-input-1-1\">[1,2,1]</span>\r\n<strong>Output: </strong><span id=\"example-output-1\">3</span>\r\n<strong><span>Explanation: </span></strong><span>We can collect [1,2,1].</span>\r\n</pre>\r\n\r\n<div>\r\n<p><strong>Example 2:</strong></p>\r\n\r\n<pre>\r\n<strong>Input: </strong><span id=\"example-input-2-1\">[0,1,2,2]</span>\r\n<strong>Output: </strong><span id=\"example-output-2\">3\r\n</span><strong><span>Explanation: </span></strong><span>We can collect [1,2,2].\r\nIf we started at the first tree, we would only collect [0, 1].</span>\r\n</pre>\r\n\r\n<div>\r\n<p><strong>Example 3:</strong></p>\r\n\r\n<pre>\r\n<strong>Input: </strong><span id=\"example-input-3-1\">[1,2,3,2,2]</span>\r\n<strong>Output: </strong><span id=\"example-output-3\">4\r\n</span><strong><span>Explanation: </span></strong><span>We can collect [2,3,2,2].</span>\r\n<span>If we started at the first tree, we would only collect [1, 2].</span>\r\n</pre>\r\n\r\n<div>\r\n<p><strong>Example 4:</strong></p>\r\n\r\n<pre>\r\n<strong>Input: </strong><span id=\"example-input-4-1\">[3,3,3,1,2,1,1,2,3,3,4]</span>\r\n<strong>Output: </strong>5<span id=\"example-output-4\">\r\n</span><strong><span>Explanation: </span></strong><span>We can collect [1,2,1,1,2].</span>\r\n<span>If we started at the first tree or the eighth tree, we would only collect 4 fruits.</span>\r\n</pre>\r\n\r\n<p>&nbsp;</p>\r\n</div>\r\n</div>\r\n</div>\r\n\r\n<p><strong>Note:</strong></p>\r\n\r\n<ol>\r\n\t<li><code>1 &lt;= tree.length &lt;= 40000</code></li>\r\n\t<li><code>0 &lt;= tree[i] &lt; tree.length</code></li>\r\n</ol>\r\n",
  "isPaidOnly": false,
  "difficulty": "Medium",
  "likes": 596,
  "dislikes": 927,
  "isLiked": null,
  "similarQuestions": "[]",
  "contributors": [
    {
      "username": "ruanjingru",
      "profileUrl": "/ruanjingru/",
      "avatarUrl": "https://assets.leetcode.com/users/ruanjingru/avatar_1527966394.png"
    }
  ],
  "topicTags": [
    {
      "name": "Two Pointers",
      "slug": "two-pointers"
    }
  ],
  "companyTagStats": "{\"1\": [{\"taggedByAdmin\": true, \"name\": \"Google\", \"slug\": \"google\", \"timesEncountered\": 3}], \"2\": [{\"taggedByAdmin\": false, \"name\": \"Amazon\", \"slug\": \"amazon\", \"timesEncountered\": 4}], \"3\": []}",
  "codeSnippets": [
    {
      "lang": "C++",
      "code": "class Solution {\npublic:\n    int totalFruit(vector<int>& tree) {\n        \n    }\n};"
    },
    {
      "lang": "Java",
      "code": "class Solution {\n    public int totalFruit(int[] tree) {\n        \n    }\n}"
    },
    {
      "lang": "Python",
      "code": "class Solution(object):\n    def totalFruit(self, tree):\n        \"\"\"\n        :type tree: List[int]\n        :rtype: int\n        \"\"\"\n        "
    },
    {
      "lang": "Python3",
      "code": "class Solution:\n    def totalFruit(self, tree: List[int]) -> int:\n        "
    },
    {
      "lang": "C",
      "code": "\n\nint totalFruit(int* tree, int treeSize){\n\n}\n\n"
    },
    {
      "lang": "C#",
      "code": "public class Solution {\n    public int TotalFruit(int[] tree) {\n        \n    }\n}"
    },
    {
      "lang": "JavaScript",
      "code": "/**\n * @param {number[]} tree\n * @return {number}\n */\nvar totalFruit = function(tree) {\n    \n};"
    },
    {
      "lang": "Ruby",
      "code": "# @param {Integer[]} tree\n# @return {Integer}\ndef total_fruit(tree)\n    \nend"
    },
    {
      "lang": "Swift",
      "code": "class Solution {\n    func totalFruit(_ tree: [Int]) -> Int {\n        \n    }\n}"
    },
    {
      "lang": "Go",
      "code": "func totalFruit(tree []int) int {\n    \n}"
    },
    {
      "lang": "Scala",
      "code": "object Solution {\n    def totalFruit(tree: Array[Int]): Int = {\n        \n    }\n}"
    },
    {
      "lang": "Kotlin",
      "code": "class Solution {\n    fun totalFruit(tree: IntArray): Int {\n        \n    }\n}"
    },
    {
      "lang": "Rust",
      "code": "impl Solution {\n    pub fn total_fruit(tree: Vec<i32>) -> i32 {\n        \n    }\n}"
    },
    {
      "lang": "PHP",
      "code": "class Solution {\n\n    /**\n     * @param Integer[] $tree\n     * @return Integer\n     */\n    function totalFruit($tree) {\n        \n    }\n}"
    }
  ],
  "stats": "{\"totalAccepted\": \"74.1K\", \"totalSubmission\": \"176.5K\", \"totalAcceptedRaw\": 74136, \"totalSubmissionRaw\": 176535, \"acRate\": \"42.0%\"}",
  "hints": [],
  "solution": {
    "id": "558",
    "canSeeDetail": true,
    "url": "/articles/fruit-into-baskets/",
    "content": "[TOC]\n\n## Solution\n---\n#### Approach 1: Scan Through Blocks\n\n**Intuition**\n\nEquivalently, we want the longest subarray with at most two \"types\" (values of `tree[i]`).\n\nInstead of considering each element individually, we can consider blocks of adjacent elements of the same type.\n\nFor example, instead of `tree = [1, 1, 1, 1, 2, 2, 3, 3, 3]`, we can say this is `blocks = [(1, weight = 4), (2, weight = 2), (3, weight = 3)]`.\n\nNow say we brute forced, scanning from left to right.  We'll have something like `blocks = [1, _2_, 1, 2, 1, 2, _1_, 3, ...]` (with various weights).\n\nThe key insight is that when we encounter a `3`, we do not need to start from the second element `2` (marked `_2_` for convenience); we can start from the first element (`_1_`) before the `3`.  This is because if we started two or more elements before, the sequence must have types `1` and `2`, and that sequence is going to end at the `3`, and thus be shorter than anything we've already considered.\n\nSince every starting point (that is the left-most index of a block) was considered, this solution is correct.\n\n**Algorithm**\n\nAs the notation and strategy around implementing this differs between Python and Java, please see the inline comments for more details.\n\n<iframe src=\"https://leetcode.com/playground/pvsyyXLb/shared\" frameBorder=\"0\" width=\"100%\" height=\"500\" name=\"pvsyyXLb\"></iframe>\n\n**Complexity Analysis**\n\n* Time Complexity:  $$O(N)$$, where $$N$$ is the length of `tree`.\n\n* Space Complexity:  $$O(N)$$.\n<br />\n<br />\n\n\n---\n#### Approach 2: Sliding Window\n\n**Intuition**\n\nAs in *Approach 1*, we want the longest subarray with at most two different \"types\" (values of `tree[i]`).  Call these subarrays *valid*.\n\nSay we consider all valid subarrays that end at index `j`.  There must be one with the smallest possible starting index `i`: lets say `opt(j) = i`.\n\nNow the key idea is that `opt(j)` is a monotone increasing function.  This is because any subarray of a valid subarray is valid.\n\n**Algorithm**\n\nLet's perform a sliding window, keeping the loop invariant that `i` will be the smallest index for which `[i, j]` is a valid subarray.\n\nWe'll maintain `count`, the count of all the elements in the subarray.  This allows us to quickly query whether there are 3 types in the subarray or not.\n\n<iframe src=\"https://leetcode.com/playground/tZWTV9pU/shared\" frameBorder=\"0\" width=\"100%\" height=\"500\" name=\"tZWTV9pU\"></iframe>\n\n**Complexity Analysis**\n\n* Time Complexity:  $$O(N)$$, where $$N$$ is the length of `tree`.\n\n* Space Complexity:  $$O(N)$$.\n<br />\n<br />\n\n\n---\n\nAnalysis written by: [@awice](https://leetcode.com/awice).",
    "contentTypeId": "107",
    "rating": {
      "id": "548",
      "count": 120,
      "average": 1.942,
      "userRating": null
    }
  },
  "status": null,
  "sampleTestCase": "[1,2,1]",
  "metaData": "{\r\n  \"name\": \"totalFruit\",\r\n  \"params\": [\r\n    {\r\n      \"name\": \"tree\",\r\n      \"type\": \"integer[]\"\r\n    }\r\n  ],\r\n  \"return\": {\r\n    \"type\": \"integer\"\r\n  }\r\n}\r\n",
  "judgerAvailable": true,
  "judgeType": "large",
  "mysqlSchemas": [],
  "enableRunCode": true,
  "enableTestMode": false,
  "libraryUrl": null
}
