{
  "questionId": "949",
  "questionFrontendId": "913",
  "boundTopicId": null,
  "title": "Cat and Mouse",
  "titleSlug": "cat-and-mouse",
  "categoryTitle": "Algorithms",
  "content": "<p>A game on an <strong>undirected</strong> graph is played by two players, Mouse and Cat, who alternate turns.</p>\r\n\r\n<p>The graph is given as follows: <code>graph[a]</code> is a list of all nodes <code>b</code> such that <code>ab</code> is an edge of the graph.</p>\r\n\r\n<p>Mouse starts at node 1 and goes first, Cat starts at node 2 and goes second, and there is a Hole at node 0.</p>\r\n\r\n<p>During each player&#39;s turn, they <strong>must</strong> travel along one&nbsp;edge of the graph that meets where they are.&nbsp; For example, if the Mouse is at node <code>1</code>, it <strong>must</strong> travel to any node in <code>graph[1]</code>.</p>\r\n\r\n<p>Additionally, it is not allowed for the Cat to travel to the Hole (node 0.)</p>\r\n\r\n<p>Then, the game can end in 3 ways:</p>\r\n\r\n<ul>\r\n\t<li>If ever the Cat occupies the same node as the Mouse, the Cat wins.</li>\r\n\t<li>If ever the Mouse reaches the Hole, the Mouse wins.</li>\r\n\t<li>If ever a position is repeated (ie.&nbsp;the players are in the same position as a previous turn, and&nbsp;it is the same player&#39;s turn to move), the game is a draw.</li>\r\n</ul>\r\n\r\n<p>Given a <code>graph</code>, and assuming both players play optimally, return <code>1</code>&nbsp;if the game is won by Mouse, <code>2</code>&nbsp;if the game is won by Cat, and <code>0</code>&nbsp;if the game is a draw.</p>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<ol>\r\n</ol>\r\n\r\n<div>\r\n<p><strong>Example 1:</strong></p>\r\n\r\n<pre>\r\n<strong>Input: </strong><span id=\"example-input-1-1\">[[2,5],[3],[0,4,5],[1,4,5],[2,3],[0,2,3]]</span>\r\n<strong>Output: </strong><span id=\"example-output-1\">0\r\n<strong>Explanation:</strong>\r\n</span>4---3---1\r\n|&nbsp; &nbsp;|\r\n2---5\r\n&nbsp;\\&nbsp;/\r\n&nbsp; 0\r\n</pre>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p><strong>Note:</strong></p>\r\n\r\n<ol>\r\n\t<li><code>3 &lt;= graph.length &lt;= 50</code></li>\r\n\t<li>It is guaranteed that <code>graph[1]</code> is non-empty.</li>\r\n\t<li>It is guaranteed that <code>graph[2]</code> contains a non-zero element.&nbsp;</li>\r\n</ol>\r\n</div>\r\n",
  "isPaidOnly": false,
  "difficulty": "Hard",
  "likes": 246,
  "dislikes": 52,
  "isLiked": null,
  "similarQuestions": "[]",
  "contributors": [],
  "topicTags": [
    {
      "name": "Breadth-first Search",
      "slug": "breadth-first-search"
    },
    {
      "name": "Minimax",
      "slug": "minimax"
    }
  ],
  "companyTagStats": "{\"2\": [{\"taggedByAdmin\": true, \"name\": \"Google\", \"slug\": \"google\", \"timesEncountered\": 5}], \"1\": [], \"3\": []}",
  "codeSnippets": [
    {
      "lang": "C++",
      "code": "class Solution {\r\npublic:\r\n    int catMouseGame(vector<vector<int>>& graph) {\r\n        \r\n    }\r\n};"
    },
    {
      "lang": "Java",
      "code": "class Solution {\n    public int catMouseGame(int[][] graph) {\n        \n    }\n}"
    },
    {
      "lang": "Python",
      "code": "class Solution(object):\n    def catMouseGame(self, graph):\n        \"\"\"\n        :type graph: List[List[int]]\n        :rtype: int\n        \"\"\"\n        "
    },
    {
      "lang": "Python3",
      "code": "class Solution:\n    def catMouseGame(self, graph: List[List[int]]) -> int:\n        "
    },
    {
      "lang": "C",
      "code": "\n\nint catMouseGame(int** graph, int graphSize, int* graphColSize){\n\n}\n\n"
    },
    {
      "lang": "C#",
      "code": "public class Solution {\r\n    public int CatMouseGame(int[][] graph) {\r\n        \r\n    }\r\n}"
    },
    {
      "lang": "JavaScript",
      "code": "/**\n * @param {number[][]} graph\n * @return {number}\n */\nvar catMouseGame = function(graph) {\n    \n};"
    },
    {
      "lang": "Ruby",
      "code": "# @param {Integer[][]} graph\r\n# @return {Integer}\r\ndef cat_mouse_game(graph)\r\n    \r\nend"
    },
    {
      "lang": "Swift",
      "code": "class Solution {\r\n    func catMouseGame(_ graph: [[Int]]) -> Int {\r\n        \r\n    }\r\n}"
    },
    {
      "lang": "Go",
      "code": "func catMouseGame(graph [][]int) int {\r\n    \r\n}"
    },
    {
      "lang": "Scala",
      "code": "object Solution {\r\n    def catMouseGame(graph: Array[Array[Int]]): Int = {\r\n        \r\n    }\r\n}"
    },
    {
      "lang": "Kotlin",
      "code": "class Solution {\r\n    fun catMouseGame(graph: Array<IntArray>): Int {\r\n        \r\n    }\r\n}"
    },
    {
      "lang": "Rust",
      "code": "impl Solution {\n    pub fn cat_mouse_game(graph: Vec<Vec<i32>>) -> i32 {\n        \n    }\n}"
    },
    {
      "lang": "PHP",
      "code": "class Solution {\n\n    /**\n     * @param Integer[][] $graph\n     * @return Integer\n     */\n    function catMouseGame($graph) {\n        \n    }\n}"
    }
  ],
  "stats": "{\"totalAccepted\": \"6K\", \"totalSubmission\": \"20K\", \"totalAcceptedRaw\": 6007, \"totalSubmissionRaw\": 20001, \"acRate\": \"30.0%\"}",
  "hints": [],
  "solution": {
    "id": "572",
    "canSeeDetail": true,
    "url": "/articles/cat-and-mouse-game/",
    "content": "[TOC]\n\n## Solution\n---\n#### Approach 1: Minimax / Percolate from Resolved States\n\n**Intuition**\n\nThe state of the game can be represented as `(m, c, t)` where `m` is the location of the mouse, `c` is the location of the cat, and `t` is `1` if it is the mouse's move, else `2`.  Let's call these states *nodes*.  These states form a directed graph: the player whose turn it is has various moves which can be considered as outgoing edges from this node to other nodes.\n\nSome of these nodes are already resolved: if the mouse is at the hole `(m = 0)`, then the mouse wins; if the cat is where the mouse is `(c = m)`, then the cat wins.  Let's say that nodes will either be colored $$\\small\\text{MOUSE}$$, $$\\small\\text{CAT}$$, or $$\\small\\text{DRAW}$$ depending on which player is assured victory.\n\nAs in a standard minimax algorithm, the Mouse player will prefer $$\\small\\text{MOUSE}$$ nodes first, $$\\small\\text{DRAW}$$ nodes second, and $$\\small\\text{CAT}$$ nodes last, and the Cat player prefers these nodes in the opposite order.\n\n**Algorithm**\n\nWe will color each `node` marked $$\\small\\text{DRAW}$$ according to the following rule.  (We'll suppose the `node` has `node.turn = Mouse`: the other case is similar.)\n\n* (\"Immediate coloring\"):  If there is a child that is colored $$\\small\\text{MOUSE}$$, then this node will also be colored $$\\small\\text{MOUSE}$$.\n\n* (\"Eventual coloring\"):  If all children are colored $$\\small\\text{CAT}$$, then this node will also be colored $$\\small\\text{CAT}$$.\n\nWe will repeatedly do this kind of coloring until no `node` satisfies the above conditions.  To perform this coloring efficiently, we will use a queue and perform a *bottom-up percolation*:\n\n* Enqueue any node initially colored (because the Mouse is at the Hole, or the Cat is at the Mouse.)\n\n* For every `node` in the queue, for each `parent` of that `node`:\n\n  * Do an immediate coloring of `parent` if you can.\n\n  * If you can't, then decrement the side-count of the number of children marked $$\\small\\text{DRAW}$$.  If it becomes zero, then do an \"eventual coloring\" of this parent.\n\n  * All `parents` that were colored in this manner get enqueued to the queue.\n\n**Proof of Correctness**\n\nOur proof is similar to a proof that minimax works.\n\nSay we cannot color any nodes any more, and say from any node colored $$\\small\\text{CAT}$$ or $$\\small\\text{MOUSE}$$ we need at most $$K$$ moves to win.  If say, some node marked $$\\small\\text{DRAW}$$ is actually a win for Mouse, it must have been with $$> K$$ moves.  Then, a path along optimal play (that tries to prolong the loss as long as possible) must arrive at a node colored $$\\small\\text{MOUSE}$$ (as eventually the Mouse reaches the Hole.)  Thus, there must have been some transition $$\\small\\text{DRAW} \\rightarrow \\small\\text{MOUSE}$$ along this path.\n\nIf this transition occurred at a `node` with `node.turn = Mouse`, then it breaks our immediate coloring rule.  If it occured with `node.turn = Cat`, and all children of `node` have color $$\\small\\text{MOUSE}$$, then it breaks our eventual coloring rule.  If some child has color $$\\small\\text{CAT}$$, then it breaks our immediate coloring rule.  Thus, in this case `node` will have some child with $$\\small\\text{DRAW}$$, which breaks our optimal play assumption, as moving to this child ends the game in $$> K$$ moves, whereas moving to the colored neighbor ends the game in $$\\leq K$$ moves.\n\n<iframe src=\"https://leetcode.com/playground/sEZarXgw/shared\" frameBorder=\"0\" width=\"100%\" height=\"500\" name=\"sEZarXgw\"></iframe>\n\n**Complexity Analysis**\n\n* Time Complexity:  $$O(N^3)$$, where $$N$$ is the number of nodes in the graph.  There are $$O(N^2)$$ states, and each state has an outdegree of $$N$$, as there are at most $$N$$ different moves.\n\n* Space Complexity:  $$O(N^2)$$.\n<br />\n<br />\n\n\n---\n\n\nAnalysis written by: [@awice](https://leetcode.com/awice).",
    "contentTypeId": "107",
    "rating": {
      "id": "560",
      "count": 33,
      "average": 3.788,
      "userRating": null
    }
  },
  "status": null,
  "sampleTestCase": "[[2,5],[3],[0,4,5],[1,4,5],[2,3],[0,2,3]]",
  "metaData": "{\r\n  \"name\": \"catMouseGame\",\r\n  \"params\": [\r\n    {\r\n      \"name\": \"graph\",\r\n      \"type\": \"integer[][]\"\r\n    }\r\n  ],\r\n  \"return\": {\r\n    \"type\": \"integer\"\r\n  }\r\n}\r\n",
  "judgerAvailable": true,
  "judgeType": "large",
  "mysqlSchemas": [],
  "enableRunCode": true,
  "enableTestMode": false,
  "libraryUrl": null
}
