{
  "questionId": "964",
  "questionFrontendId": "928",
  "boundTopicId": null,
  "title": "Minimize Malware Spread II",
  "titleSlug": "minimize-malware-spread-ii",
  "categoryTitle": "Algorithms",
  "content": "<p>(This problem is the same as <em>Minimize Malware Spread</em>, with the differences bolded.)</p>\r\n\r\n<p>In a network of nodes, each node <code>i</code> is directly connected to another node <code>j</code> if and only if&nbsp;<code>graph[i][j] = 1</code>.</p>\r\n\r\n<p>Some nodes <code>initial</code> are initially infected by malware.&nbsp; Whenever two nodes are directly connected and at least one of those two nodes is infected by malware, both nodes will be infected by malware.&nbsp; This spread of malware will continue until no more nodes can be infected in this manner.</p>\r\n\r\n<p>Suppose <code>M(initial)</code>&nbsp;is the final number of nodes infected with malware in the entire network, after the spread of malware stops.</p>\r\n\r\n<p>We will&nbsp;remove one node from the initial list, <strong>completely removing it and any connections from this node to any other node</strong>.&nbsp; Return the node that if removed, would minimize&nbsp;<code>M(initial)</code>.&nbsp; If multiple nodes could be removed to minimize <code>M(initial)</code>, return such a node with the smallest index.</p>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<ol>\r\n</ol>\r\n\r\n<div>\r\n<p><strong>Example 1:</strong></p>\r\n\r\n<pre>\r\n<strong>Input: </strong>graph = <span id=\"example-input-1-1\">[[1,1,0],[1,1,0],[0,0,1]]</span>, initial = <span id=\"example-input-1-2\">[0,1]</span>\r\n<strong>Output: </strong><span id=\"example-output-1\">0</span>\r\n</pre>\r\n\r\n<div>\r\n<p><strong>Example 2:</strong></p>\r\n\r\n<pre>\r\n<strong>Input: </strong>graph = <span id=\"example-input-2-1\">[[1,1,0],[1,1,1],[0,1,1]]</span>, initial = <span id=\"example-input-2-2\">[0,1]</span>\r\n<strong>Output: </strong><span id=\"example-output-2\">1</span>\r\n</pre>\r\n\r\n<div>\r\n<p><strong>Example 3:</strong></p>\r\n\r\n<pre>\r\n<strong>Input: </strong>graph = <span id=\"example-input-3-1\">[[1,1,0,0],[1,1,1,0],[0,1,1,1],[0,0,1,1]]</span>, initial = <span id=\"example-input-3-2\">[0,1]</span>\r\n<strong>Output: </strong><span id=\"example-output-3\">1</span>\r\n</pre>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p><strong>Note:</strong></p>\r\n\r\n<ol>\r\n\t<li><code>1 &lt; graph.length = graph[0].length &lt;= 300</code></li>\r\n\t<li><code>0 &lt;= graph[i][j] == graph[j][i] &lt;= 1</code></li>\r\n\t<li><code>graph[i][i] = 1</code></li>\r\n\t<li><code>1 &lt;= initial.length &lt; graph.length</code></li>\r\n\t<li><code>0 &lt;= initial[i] &lt; graph.length</code></li>\r\n</ol>\r\n</div>\r\n</div>\r\n</div>",
  "isPaidOnly": false,
  "difficulty": "Hard",
  "likes": 128,
  "dislikes": 35,
  "isLiked": null,
  "similarQuestions": "[]",
  "contributors": [
    {
      "username": "laiden",
      "profileUrl": "/laiden/",
      "avatarUrl": "https://www.gravatar.com/avatar/da5b31fc40120c709be663929906e707.png?s=200"
    }
  ],
  "topicTags": [
    {
      "name": "Depth-first Search",
      "slug": "depth-first-search"
    },
    {
      "name": "Union Find",
      "slug": "union-find"
    },
    {
      "name": "Graph",
      "slug": "graph"
    }
  ],
  "companyTagStats": "{\"2\": [{\"taggedByAdmin\": true, \"name\": \"Dropbox\", \"slug\": \"dropbox\", \"timesEncountered\": 2}], \"1\": [], \"3\": []}",
  "codeSnippets": [
    {
      "lang": "C++",
      "code": "class Solution {\npublic:\n    int minMalwareSpread(vector<vector<int>>& graph, vector<int>& initial) {\n        \n    }\n};"
    },
    {
      "lang": "Java",
      "code": "class Solution {\n    public int minMalwareSpread(int[][] graph, int[] initial) {\n        \n    }\n}"
    },
    {
      "lang": "Python",
      "code": "class Solution(object):\n    def minMalwareSpread(self, graph, initial):\n        \"\"\"\n        :type graph: List[List[int]]\n        :type initial: List[int]\n        :rtype: int\n        \"\"\"\n        "
    },
    {
      "lang": "Python3",
      "code": "class Solution:\n    def minMalwareSpread(self, graph: List[List[int]], initial: List[int]) -> int:\n        "
    },
    {
      "lang": "C",
      "code": "\n\nint minMalwareSpread(int** graph, int graphSize, int* graphColSize, int* initial, int initialSize){\n\n}\n\n"
    },
    {
      "lang": "C#",
      "code": "public class Solution {\n    public int MinMalwareSpread(int[][] graph, int[] initial) {\n        \n    }\n}"
    },
    {
      "lang": "JavaScript",
      "code": "/**\n * @param {number[][]} graph\n * @param {number[]} initial\n * @return {number}\n */\nvar minMalwareSpread = function(graph, initial) {\n    \n};"
    },
    {
      "lang": "Ruby",
      "code": "# @param {Integer[][]} graph\n# @param {Integer[]} initial\n# @return {Integer}\ndef min_malware_spread(graph, initial)\n    \nend"
    },
    {
      "lang": "Swift",
      "code": "class Solution {\n    func minMalwareSpread(_ graph: [[Int]], _ initial: [Int]) -> Int {\n        \n    }\n}"
    },
    {
      "lang": "Go",
      "code": "func minMalwareSpread(graph [][]int, initial []int) int {\n    \n}"
    },
    {
      "lang": "Scala",
      "code": "object Solution {\n    def minMalwareSpread(graph: Array[Array[Int]], initial: Array[Int]): Int = {\n        \n    }\n}"
    },
    {
      "lang": "Kotlin",
      "code": "class Solution {\n    fun minMalwareSpread(graph: Array<IntArray>, initial: IntArray): Int {\n        \n    }\n}"
    },
    {
      "lang": "Rust",
      "code": "impl Solution {\n    pub fn min_malware_spread(graph: Vec<Vec<i32>>, initial: Vec<i32>) -> i32 {\n        \n    }\n}"
    },
    {
      "lang": "PHP",
      "code": "class Solution {\n\n    /**\n     * @param Integer[][] $graph\n     * @param Integer[] $initial\n     * @return Integer\n     */\n    function minMalwareSpread($graph, $initial) {\n        \n    }\n}"
    }
  ],
  "stats": "{\"totalAccepted\": \"7K\", \"totalSubmission\": \"17.5K\", \"totalAcceptedRaw\": 6968, \"totalSubmissionRaw\": 17478, \"acRate\": \"39.9%\"}",
  "hints": [],
  "solution": {
    "id": "593",
    "canSeeDetail": true,
    "url": "/articles/minimize-malware-spread-ii/",
    "content": "[TOC]\n\n## Solution\n---\n#### Approach 1: Depth First Search\n\n**Intuition and Algorithm**\n\nLet `G` be the graph with all the nodes from `initial` removed.\n\nFor each node `v` not in `initial`, we want to know which nodes `u` from `initial` can reach `v` in the graph `G` [with `u` (and its edges) added to `G`].  Let's say these nodes `u` \"infect\" `v`.\n\nAfterwards, we want to know which nodes `v` are uniquely infected by only one `u`.  For each such pair, it contributes 1 to the answer for `u`.\n\nPlease see the inline comments for more details.\n\n<iframe src=\"https://leetcode.com/playground/zWWFjBM4/shared\" frameBorder=\"0\" width=\"100%\" height=\"500\" name=\"zWWFjBM4\"></iframe>\n\n**Complexity Analysis**\n\n* Time Complexity:  $$O(N^2)$$, where $$N$$ is the length of `graph`, as the graph is given in adjacent matrix form.\n\n* Space Complexity:  $$O(N)$$.\n<br />\n<br />\n\n\n---\n#### Approach 2: Union-Find\n\n**Intuition**\n\nLet `G` be the graph with all the nodes in `initial` removed.  For each component of `G`, either it neighbors `0`, `1`, or `>= 2` nodes from `initial`.  The result only changes if there is exactly 1 neighbor from `initial`, so we need a way to count this.\n\n**Algorithm**\n\nIt is clear that we will need to consider components of the graph.  A \"Disjoint Set Union\" (DSU) data structure is ideal for this.\n\nWe will skip the explanation of how a DSU structure is implemented.  Please refer to [https://leetcode.com/problems/redundant-connection/solution/](https://leetcode.com/problems/redundant-connection/solution/) for a tutorial on DSU.\n\nAs above, lets consider the components of `G`: the graph without any nodes from `initial`.\n\nThen, for every edge `uv` in the original graph, where `u` is in initial and `v` is not, we can count that the component at `v` of `G` neighbors 1 more infected node.\n\nNow, for each node `u` in initial, for each component of `G` it neighbors, if that component would only be infected by `u` (\"uniquely infected\"), then the size of that component contributes to the answer for removing `u`.\n\nWe take the best possible answer.\n\n<iframe src=\"https://leetcode.com/playground/Bov23LZs/shared\" frameBorder=\"0\" width=\"100%\" height=\"500\" name=\"Bov23LZs\"></iframe>\n\n**Complexity Analysis**\n\n* Time Complexity:  $$O(N^2)$$, where $$N$$ is the length of `graph`, as the graph is given in adjacent matrix form.\n\n* Space Complexity:  $$O(N)$$.\n<br />\n<br />\n\n\n---\n\n\nAnalysis written by: [@awice](https://leetcode.com/awice).",
    "contentTypeId": "107",
    "rating": {
      "id": "579",
      "count": 14,
      "average": 3.357,
      "userRating": null
    }
  },
  "status": null,
  "sampleTestCase": "[[1,1,0],[1,1,0],[0,0,1]]\n[0,1]",
  "metaData": "{\r\n  \"name\": \"minMalwareSpread\",\r\n  \"params\": [\r\n    {\r\n      \"name\": \"graph\",\r\n      \"type\": \"integer[][]\"\r\n    },\r\n    {\r\n      \"name\": \"initial\",\r\n      \"type\": \"integer[]\"\r\n    }\r\n  ],\r\n  \"return\": {\r\n    \"type\": \"integer\"\r\n  }\r\n}\r\n",
  "judgerAvailable": true,
  "judgeType": "large",
  "mysqlSchemas": [],
  "enableRunCode": true,
  "enableTestMode": false,
  "libraryUrl": null
}
