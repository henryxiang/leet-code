{
  "questionId": "988",
  "questionFrontendId": "951",
  "boundTopicId": null,
  "title": "Flip Equivalent Binary Trees",
  "titleSlug": "flip-equivalent-binary-trees",
  "categoryTitle": "Algorithms",
  "content": "<p>For a binary tree T, we can define a flip operation as follows: choose any node, and swap the left and right child subtrees.</p>\r\n\r\n<p>A binary tree X&nbsp;is <em>flip equivalent</em> to a binary tree Y if and only if we can make X equal to Y after some number of flip operations.</p>\r\n\r\n<p>Write a function that determines whether two binary trees&nbsp;are <em>flip equivalent</em>.&nbsp; The trees are given by root nodes <code>root1</code> and <code>root2</code>.</p>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p><strong>Example 1:</strong></p>\r\n\r\n<pre>\r\n<strong>Input: </strong>root1 = <span id=\"example-input-1-1\">[1,2,3,4,5,6,null,null,null,7,8]</span>, root2 = <span id=\"example-input-1-2\">[1,3,2,null,6,4,5,null,null,null,null,8,7]</span>\r\n<strong>Output: </strong><span id=\"example-output-1\">true</span>\r\n<strong>Explanation: </strong>We flipped at nodes with values 1, 3, and 5.\r\n<img alt=\"Flipped Trees Diagram\" src=\"https://assets.leetcode.com/uploads/2018/11/29/tree_ex.png\" style=\"font-family: sans-serif, Arial, Verdana, &quot;Trebuchet MS&quot;; width: 455px; height: 200px;\" />\r\n</pre>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p><strong>Note:</strong></p>\r\n\r\n<ol>\r\n\t<li>Each tree will have at most <code>100</code> nodes.</li>\r\n\t<li>Each value in each tree will be a unique&nbsp;integer in the range <code>[0, 99]</code>.</li>\r\n</ol>\r\n\r\n<div>\r\n<p>&nbsp;</p>\r\n</div>\r\n",
  "isPaidOnly": false,
  "difficulty": "Medium",
  "likes": 402,
  "dislikes": 17,
  "isLiked": null,
  "similarQuestions": "[]",
  "contributors": [
    {
      "username": "boganc",
      "profileUrl": "/boganc/",
      "avatarUrl": "https://www.gravatar.com/avatar/aa3cc39bc7e0c8e4f2ba3a622d16e428.png?s=200"
    }
  ],
  "topicTags": [
    {
      "name": "Tree",
      "slug": "tree"
    }
  ],
  "companyTagStats": "{\"1\": [{\"taggedByAdmin\": true, \"name\": \"Google\", \"slug\": \"google\", \"timesEncountered\": 7}], \"2\": [{\"taggedByAdmin\": false, \"name\": \"Amazon\", \"slug\": \"amazon\", \"timesEncountered\": 2}], \"3\": []}",
  "codeSnippets": [
    {
      "lang": "C++",
      "code": "/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\n * };\n */\nclass Solution {\npublic:\n    bool flipEquiv(TreeNode* root1, TreeNode* root2) {\n        \n    }\n};"
    },
    {
      "lang": "Java",
      "code": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode(int x) { val = x; }\n * }\n */\nclass Solution {\n    public boolean flipEquiv(TreeNode root1, TreeNode root2) {\n        \n    }\n}"
    },
    {
      "lang": "Python",
      "code": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, x):\n#         self.val = x\n#         self.left = None\n#         self.right = None\n\nclass Solution(object):\n    def flipEquiv(self, root1, root2):\n        \"\"\"\n        :type root1: TreeNode\n        :type root2: TreeNode\n        :rtype: bool\n        \"\"\"\n        "
    },
    {
      "lang": "Python3",
      "code": "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, x):\n#         self.val = x\n#         self.left = None\n#         self.right = None\n\nclass Solution:\n    def flipEquiv(self, root1: TreeNode, root2: TreeNode) -> bool:\n        "
    },
    {
      "lang": "C",
      "code": "/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     struct TreeNode *left;\n *     struct TreeNode *right;\n * };\n */\n\n\nbool flipEquiv(struct TreeNode* root1, struct TreeNode* root2){\n\n}\n\n"
    },
    {
      "lang": "C#",
      "code": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     public int val;\n *     public TreeNode left;\n *     public TreeNode right;\n *     public TreeNode(int x) { val = x; }\n * }\n */\npublic class Solution {\n    public bool FlipEquiv(TreeNode root1, TreeNode root2) {\n        \n    }\n}"
    },
    {
      "lang": "JavaScript",
      "code": "/**\n * Definition for a binary tree node.\n * function TreeNode(val) {\n *     this.val = val;\n *     this.left = this.right = null;\n * }\n */\n/**\n * @param {TreeNode} root1\n * @param {TreeNode} root2\n * @return {boolean}\n */\nvar flipEquiv = function(root1, root2) {\n    \n};"
    },
    {
      "lang": "Ruby",
      "code": "# Definition for a binary tree node.\n# class TreeNode\n#     attr_accessor :val, :left, :right\n#     def initialize(val)\n#         @val = val\n#         @left, @right = nil, nil\n#     end\n# end\n\n# @param {TreeNode} root1\n# @param {TreeNode} root2\n# @return {Boolean}\ndef flip_equiv(root1, root2)\n    \nend"
    },
    {
      "lang": "Swift",
      "code": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     public var val: Int\n *     public var left: TreeNode?\n *     public var right: TreeNode?\n *     public init(_ val: Int) {\n *         self.val = val\n *         self.left = nil\n *         self.right = nil\n *     }\n * }\n */\nclass Solution {\n    func flipEquiv(_ root1: TreeNode?, _ root2: TreeNode?) -> Bool {\n        \n    }\n}"
    },
    {
      "lang": "Go",
      "code": "/**\n * Definition for a binary tree node.\n * type TreeNode struct {\n *     Val int\n *     Left *TreeNode\n *     Right *TreeNode\n * }\n */\nfunc flipEquiv(root1 *TreeNode, root2 *TreeNode) bool {\n    \n}"
    },
    {
      "lang": "Scala",
      "code": "/**\n * Definition for a binary tree node.\n * class TreeNode(var _value: Int) {\n *   var value: Int = _value\n *   var left: TreeNode = null\n *   var right: TreeNode = null\n * }\n */\nobject Solution {\n    def flipEquiv(root1: TreeNode, root2: TreeNode): Boolean = {\n        \n    }\n}"
    },
    {
      "lang": "Kotlin",
      "code": "/**\n * Example:\n * var ti = TreeNode(5)\n * var v = ti.`val`\n * Definition for a binary tree node.\n * class TreeNode(var `val`: Int) {\n *     var left: TreeNode? = null\n *     var right: TreeNode? = null\n * }\n */\nclass Solution {\n    fun flipEquiv(root1: TreeNode?, root2: TreeNode?): Boolean {\n        \n    }\n}"
    },
    {
      "lang": "Rust",
      "code": "// Definition for a binary tree node.\n// #[derive(Debug, PartialEq, Eq)]\n// pub struct TreeNode {\n//   pub val: i32,\n//   pub left: Option<Rc<RefCell<TreeNode>>>,\n//   pub right: Option<Rc<RefCell<TreeNode>>>,\n// }\n// \n// impl TreeNode {\n//   #[inline]\n//   pub fn new(val: i32) -> Self {\n//     TreeNode {\n//       val,\n//       left: None,\n//       right: None\n//     }\n//   }\n// }\nuse std::rc::Rc;\nuse std::cell::RefCell;\nimpl Solution {\n    pub fn flip_equiv(root1: Option<Rc<RefCell<TreeNode>>>, root2: Option<Rc<RefCell<TreeNode>>>) -> bool {\n        \n    }\n}"
    },
    {
      "lang": "PHP",
      "code": "/**\n * Definition for a binary tree node.\n * class TreeNode {\n *     public $val = null;\n *     public $left = null;\n *     public $right = null;\n *     function __construct($value) { $this->val = $value; }\n * }\n */\nclass Solution {\n\n    /**\n     * @param TreeNode $root1\n     * @param TreeNode $root2\n     * @return Boolean\n     */\n    function flipEquiv($root1, $root2) {\n        \n    }\n}"
    }
  ],
  "stats": "{\"totalAccepted\": \"29.8K\", \"totalSubmission\": \"45.5K\", \"totalAcceptedRaw\": 29759, \"totalSubmissionRaw\": 45483, \"acRate\": \"65.4%\"}",
  "hints": [],
  "solution": {
    "id": "630",
    "canSeeDetail": true,
    "url": "/articles/flip-equivalent-binary-trees/",
    "content": "[TOC]\n\n## Solution\n---\n#### Approach 1: Recursion\n\n**Intuition**\n\nIf `root1` and `root2` have the same root value, then we only need to check if their children are equal (up to ordering.)\n\n**Algorithm**\n\nThere are 3 cases:\n\n* If `root1` or `root2` is `null`, then they are equivalent if and only if they are both `null`.\n\n* Else, if `root1` and `root2` have different values, they aren't equivalent.\n\n* Else, let's check whether the children of `root1` are equivalent to the children of `root2`.  There are two different ways to pair these children.\n\n<iframe src=\"https://leetcode.com/playground/wjoLqdDo/shared\" frameBorder=\"0\" width=\"100%\" height=\"242\" name=\"wjoLqdDo\"></iframe>\n\n**Complexity Analysis**\n\n* Time Complexity:  $$O(min(N_1, N_2))$$, where $$N_1, N_2$$ are the lengths of `root1` and `root2`.\n\n* Space Complexity:  $$O(min(H_1, H_2))$$, where $$H_1, H_2$$ are the heights of the trees of `root1` and `root2`.\n<br />\n<br />\n\n\n---\n#### Approach 2: Canonical Traversal\n\n**Intuition**\n\nFlip each node so that the left child is smaller than the right, and call this the *canonical representation*.  All equivalent trees have exactly one canonical representation.\n\n**Algorithm**\n\nWe can use a depth-first search to compare the canonical representation of each tree.  If the traversals are the same, the representations are equal.\n\nWhen traversing, we should be careful to encode both when we enter or leave a node.\n\n<iframe src=\"https://leetcode.com/playground/PZJH2Hcn/shared\" frameBorder=\"0\" width=\"100%\" height=\"500\" name=\"PZJH2Hcn\"></iframe>\n\n**Complexity Analysis**\n\n* Time Complexity:  $$O(N_1 + N_2)$$, where $$N_1, N_2$$ are the lengths of `root1` and `root2`.  (In Python, this is $$\\min(N_1, N_2)$$.)\n\n* Space Complexity:  $$O(N_1 + N_2)$$.  (In Python, this is $$\\min(H_1, H_2)$$, where $$H_1, H_2$$ are the heights of the trees of `root1` and `root2`.)\n<br />\n<br />\n\n\n---\n\n\nAnalysis written by: [@awice](https://leetcode.com/awice).",
    "contentTypeId": "107",
    "rating": {
      "id": "617",
      "count": 20,
      "average": 4.05,
      "userRating": null
    }
  },
  "status": null,
  "sampleTestCase": "[1,2,3,4,5,6,null,null,null,7,8]\n[1,3,2,null,6,4,5,null,null,null,null,8,7]",
  "metaData": "{\r\n  \"name\": \"flipEquiv\",\r\n  \"params\": [\r\n    {\r\n      \"name\": \"root1\",\r\n      \"type\": \"TreeNode\"\r\n    },\r\n    {\r\n      \"name\": \"root2\",\r\n      \"type\": \"TreeNode\"\r\n    }\r\n  ],\r\n  \"return\": {\r\n    \"type\": \"boolean\"\r\n  }\r\n}\r\n",
  "judgerAvailable": true,
  "judgeType": "large",
  "mysqlSchemas": [],
  "enableRunCode": true,
  "enableTestMode": false,
  "libraryUrl": null
}
