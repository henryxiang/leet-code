{
  "questionId": "98",
  "questionFrontendId": "98",
  "boundTopicId": null,
  "title": "Validate Binary Search Tree",
  "titleSlug": "validate-binary-search-tree",
  "categoryTitle": "Algorithms",
  "content": "<p>Given a binary tree, determine if it is a valid binary search tree (BST).</p>\r\n\r\n<p>Assume a BST is defined as follows:</p>\r\n\r\n<ul>\r\n\t<li>The left subtree of a node contains only nodes with keys <strong>less than</strong> the node&#39;s key.</li>\r\n\t<li>The right subtree of a node contains only nodes with keys <strong>greater than</strong> the node&#39;s key.</li>\r\n\t<li>Both the left and right subtrees must also be binary search trees.</li>\r\n</ul>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p><strong>Example 1:</strong></p>\r\n\r\n<pre>\r\n    2\r\n   / \\\r\n  1   3\r\n\r\n<strong>Input:</strong>&nbsp;[2,1,3]\r\n<strong>Output:</strong> true\r\n</pre>\r\n\r\n<p><strong>Example 2:</strong></p>\r\n\r\n<pre>\r\n    5\r\n   / \\\r\n  1   4\r\n&nbsp;    / \\\r\n&nbsp;   3   6\r\n\r\n<strong>Input:</strong> [5,1,4,null,null,3,6]\r\n<strong>Output:</strong> false\r\n<strong>Explanation:</strong> The root node&#39;s value is 5 but its right child&#39;s value is 4.\r\n</pre>\r\n",
  "isPaidOnly": false,
  "difficulty": "Medium",
  "likes": 2778,
  "dislikes": 404,
  "isLiked": null,
  "similarQuestions": "[{\"title\": \"Binary Tree Inorder Traversal\", \"titleSlug\": \"binary-tree-inorder-traversal\", \"difficulty\": \"Medium\", \"translatedTitle\": null}, {\"title\": \"Find Mode in Binary Search Tree\", \"titleSlug\": \"find-mode-in-binary-search-tree\", \"difficulty\": \"Easy\", \"translatedTitle\": null}]",
  "contributors": [],
  "topicTags": [
    {
      "name": "Tree",
      "slug": "tree"
    },
    {
      "name": "Depth-first Search",
      "slug": "depth-first-search"
    }
  ],
  "companyTagStats": "{\"1\": [{\"taggedByAdmin\": true, \"name\": \"Facebook\", \"slug\": \"facebook\", \"timesEncountered\": 33}, {\"taggedByAdmin\": true, \"name\": \"Amazon\", \"slug\": \"amazon\", \"timesEncountered\": 16}, {\"taggedByAdmin\": true, \"name\": \"Microsoft\", \"slug\": \"microsoft\", \"timesEncountered\": 15}, {\"taggedByAdmin\": false, \"name\": \"Asana\", \"slug\": \"asana\", \"timesEncountered\": 7}, {\"taggedByAdmin\": true, \"name\": \"Bloomberg\", \"slug\": \"bloomberg\", \"timesEncountered\": 5}, {\"taggedByAdmin\": false, \"name\": \"Google\", \"slug\": \"google\", \"timesEncountered\": 3}, {\"taggedByAdmin\": false, \"name\": \"Apple\", \"slug\": \"apple\", \"timesEncountered\": 3}, {\"taggedByAdmin\": false, \"name\": \"Yandex\", \"slug\": \"yandex\", \"timesEncountered\": 3}, {\"taggedByAdmin\": false, \"name\": \"Oracle\", \"slug\": \"oracle\", \"timesEncountered\": 3}, {\"taggedByAdmin\": false, \"name\": \"Salesforce\", \"slug\": \"salesforce\", \"timesEncountered\": 2}], \"3\": [{\"taggedByAdmin\": false, \"name\": \"Uber\", \"slug\": \"uber\", \"timesEncountered\": 4}, {\"taggedByAdmin\": false, \"name\": \"LinkedIn\", \"slug\": \"linkedin\", \"timesEncountered\": 3}, {\"taggedByAdmin\": false, \"name\": \"TripAdvisor\", \"slug\": \"tripadvisor\", \"timesEncountered\": 3}, {\"taggedByAdmin\": false, \"name\": \"Capital One\", \"slug\": \"capital-one\", \"timesEncountered\": 2}, {\"taggedByAdmin\": false, \"name\": \"Walmart Labs\", \"slug\": \"walmart-labs\", \"timesEncountered\": 2}], \"2\": [{\"taggedByAdmin\": false, \"name\": \"Adobe\", \"slug\": \"adobe\", \"timesEncountered\": 5}, {\"taggedByAdmin\": false, \"name\": \"Visa\", \"slug\": \"visa\", \"timesEncountered\": 3}, {\"taggedByAdmin\": false, \"name\": \"Mathworks\", \"slug\": \"mathworks\", \"timesEncountered\": 2}, {\"taggedByAdmin\": false, \"name\": \"VMware\", \"slug\": \"vmware\", \"timesEncountered\": 2}, {\"taggedByAdmin\": false, \"name\": \"Goldman Sachs\", \"slug\": \"goldman-sachs\", \"timesEncountered\": 2}]}",
  "codeSnippets": [
    {
      "lang": "C++",
      "code": "/**\r\n * Definition for a binary tree node.\r\n * struct TreeNode {\r\n *     int val;\r\n *     TreeNode *left;\r\n *     TreeNode *right;\r\n *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\r\n * };\r\n */\r\nclass Solution {\r\npublic:\r\n    bool isValidBST(TreeNode* root) {\r\n        \r\n    }\r\n};"
    },
    {
      "lang": "Java",
      "code": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode(int x) { val = x; }\n * }\n */\nclass Solution {\n    public boolean isValidBST(TreeNode root) {\n        \n    }\n}"
    },
    {
      "lang": "Python",
      "code": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, x):\n#         self.val = x\n#         self.left = None\n#         self.right = None\n\nclass Solution(object):\n    def isValidBST(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: bool\n        \"\"\"\n        "
    },
    {
      "lang": "Python3",
      "code": "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, x):\n#         self.val = x\n#         self.left = None\n#         self.right = None\n\nclass Solution:\n    def isValidBST(self, root: TreeNode) -> bool:\n        "
    },
    {
      "lang": "C",
      "code": "/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     struct TreeNode *left;\n *     struct TreeNode *right;\n * };\n */\n\n\nbool isValidBST(struct TreeNode* root){\n\n}\n\n"
    },
    {
      "lang": "C#",
      "code": "/**\r\n * Definition for a binary tree node.\r\n * public class TreeNode {\r\n *     public int val;\r\n *     public TreeNode left;\r\n *     public TreeNode right;\r\n *     public TreeNode(int x) { val = x; }\r\n * }\r\n */\r\npublic class Solution {\r\n    public bool IsValidBST(TreeNode root) {\r\n        \r\n    }\r\n}"
    },
    {
      "lang": "JavaScript",
      "code": "/**\n * Definition for a binary tree node.\n * function TreeNode(val) {\n *     this.val = val;\n *     this.left = this.right = null;\n * }\n */\n/**\n * @param {TreeNode} root\n * @return {boolean}\n */\nvar isValidBST = function(root) {\n    \n};"
    },
    {
      "lang": "Ruby",
      "code": "# Definition for a binary tree node.\r\n# class TreeNode\r\n#     attr_accessor :val, :left, :right\r\n#     def initialize(val)\r\n#         @val = val\r\n#         @left, @right = nil, nil\r\n#     end\r\n# end\r\n\r\n# @param {TreeNode} root\r\n# @return {Boolean}\r\ndef is_valid_bst(root)\r\n    \r\nend"
    },
    {
      "lang": "Swift",
      "code": "/**\r\n * Definition for a binary tree node.\r\n * public class TreeNode {\r\n *     public var val: Int\r\n *     public var left: TreeNode?\r\n *     public var right: TreeNode?\r\n *     public init(_ val: Int) {\r\n *         self.val = val\r\n *         self.left = nil\r\n *         self.right = nil\r\n *     }\r\n * }\r\n */\r\nclass Solution {\r\n    func isValidBST(_ root: TreeNode?) -> Bool {\r\n        \r\n    }\r\n}"
    },
    {
      "lang": "Go",
      "code": "/**\r\n * Definition for a binary tree node.\r\n * type TreeNode struct {\r\n *     Val int\r\n *     Left *TreeNode\r\n *     Right *TreeNode\r\n * }\r\n */\r\nfunc isValidBST(root *TreeNode) bool {\r\n    \r\n}"
    },
    {
      "lang": "Scala",
      "code": "/**\r\n * Definition for a binary tree node.\r\n * class TreeNode(var _value: Int) {\r\n *   var value: Int = _value\r\n *   var left: TreeNode = null\r\n *   var right: TreeNode = null\r\n * }\r\n */\r\nobject Solution {\r\n    def isValidBST(root: TreeNode): Boolean = {\r\n        \r\n    }\r\n}"
    },
    {
      "lang": "Kotlin",
      "code": "/**\r\n * Example:\r\n * var ti = TreeNode(5)\r\n * var v = ti.`val`\r\n * Definition for a binary tree node.\r\n * class TreeNode(var `val`: Int) {\r\n *     var left: TreeNode? = null\r\n *     var right: TreeNode? = null\r\n * }\r\n */\r\nclass Solution {\r\n    fun isValidBST(root: TreeNode?): Boolean {\r\n        \r\n    }\r\n}"
    },
    {
      "lang": "Rust",
      "code": "// Definition for a binary tree node.\n// #[derive(Debug, PartialEq, Eq)]\n// pub struct TreeNode {\n//   pub val: i32,\n//   pub left: Option<Rc<RefCell<TreeNode>>>,\n//   pub right: Option<Rc<RefCell<TreeNode>>>,\n// }\n// \n// impl TreeNode {\n//   #[inline]\n//   pub fn new(val: i32) -> Self {\n//     TreeNode {\n//       val,\n//       left: None,\n//       right: None\n//     }\n//   }\n// }\nuse std::rc::Rc;\nuse std::cell::RefCell;\nimpl Solution {\n    pub fn is_valid_bst(root: Option<Rc<RefCell<TreeNode>>>) -> bool {\n        \n    }\n}"
    },
    {
      "lang": "PHP",
      "code": "/**\n * Definition for a binary tree node.\n * class TreeNode {\n *     public $val = null;\n *     public $left = null;\n *     public $right = null;\n *     function __construct($value) { $this->val = $value; }\n * }\n */\nclass Solution {\n\n    /**\n     * @param TreeNode $root\n     * @return Boolean\n     */\n    function isValidBST($root) {\n        \n    }\n}"
    }
  ],
  "stats": "{\"totalAccepted\": \"535.7K\", \"totalSubmission\": \"2M\", \"totalAcceptedRaw\": 535658, \"totalSubmissionRaw\": 1999227, \"acRate\": \"26.8%\"}",
  "hints": [],
  "solution": {
    "id": "639",
    "canSeeDetail": true,
    "url": "/articles/validate-binary-search-tree/",
    "content": "[TOC]\n\n## Solution\n\n--- \n\n#### Tree definition\n\nFirst of all, here is the definition of the ```TreeNode``` which we would use.\n\n<iframe src=\"https://leetcode.com/playground/W2qazBuk/shared\" frameBorder=\"0\" width=\"100%\" height=\"225\" name=\"W2qazBuk\"></iframe>\n<br />\n<br />\n\n\n---\n#### Intuition\n\nOn the first sight, the problem is trivial. Let's traverse the tree\nand check at each step if `node.right.val > node.val` and \n`node.left.val < node.val`. This approach would even work for some\ntrees \n![compute](../Figures/98/98_not_bst.png)\n\nThe problem is this approach will not work for all cases. \nNot only the right child should be larger than the node \nbut all the \nelements in the right subtree. Here is an example :\n\n![compute](../Figures/98/98_not_bst_3.png)\n\nThat means one should keep both upper \nand lower limits for each node while traversing the tree, \nand compare the node value not\nwith children values but with these limits.\n<br />\n<br />\n\n\n---\n#### Approach 1: Recursion\n\nThe idea above could be implemented as a recursion.\nOne compares the node value with its upper and lower limits\nif they are available. Then one repeats the same \nstep recursively for left and right subtrees. \n\n!?!../Documents/98_LIS.json:1000,462!?!\n\n<iframe src=\"https://leetcode.com/playground/VeZZvEw8/shared\" frameBorder=\"0\" width=\"100%\" height=\"412\" name=\"VeZZvEw8\"></iframe>\n\n**Complexity Analysis**\n\n* Time complexity : $$\\mathcal{O}(N)$$ since we visit each node exactly once. \n* Space complexity : $$\\mathcal{O}(N)$$ since we keep up to the entire tree.\n\n<br />\n<br />\n\n\n---\n#### Approach 2: Iteration\n\nThe above recursion could be converted into iteration, \nwith the help of stack. DFS would be better than BFS since \nit works faster here.\n\n<iframe src=\"https://leetcode.com/playground/VFyKF5Jv/shared\" frameBorder=\"0\" width=\"100%\" height=\"500\" name=\"VFyKF5Jv\"></iframe>\n\n**Complexity Analysis**\n\n* Time complexity : $$\\mathcal{O}(N)$$ since we visit each node exactly once. \n* Space complexity : $$\\mathcal{O}(N)$$ since we keep up to the entire tree.\n<br />\n<br />\n\n\n---\n#### Approach 3: Inorder traversal\n\n**Algorithm**\n\nLet's use the order of nodes in the \n[inorder traversal](https://leetcode.com/articles/binary-tree-inorder-traversal/) \n`Left -> Node -> Right`.\n\n![postorder](../Figures/145_transverse.png)\n\nHere the nodes are enumerated in the order you visit them, \nand you could follow `1-2-3-4-5` to compare different strategies.\n\n`Left -> Node -> Right` order of inorder traversal \nmeans for BST that each element should be smaller \nthan the next one.\n\nHence the algorithm with $$\\mathcal{O}(N)$$ time complexity \nand $$\\mathcal{O}(N)$$ space complexity could be simple:\n\n- Compute inorder traversal list `inorder`.\n\n- Check if each element in `inorder` is smaller than the next one.\n\n![postorder](../Figures/98/98_bst_inorder.png)\n\n> Do we need to keep the whole `inorder` traversal list? \n\nActually, no. The last added inorder element is enough \nto ensure at each step that the tree is BST (or not).\nHence one could merge both steps into one and\nreduce the used space.\n\n**Implementation**\n\n<iframe src=\"https://leetcode.com/playground/xWskyKv3/shared\" frameBorder=\"0\" width=\"100%\" height=\"429\" name=\"xWskyKv3\"></iframe>\n\n**Complexity Analysis**\n\n* Time complexity : $$\\mathcal{O}(N)$$ in the worst case\nwhen the tree is BST or the \"bad\" element is a rightmost leaf.\n \n* Space complexity : $$\\mathcal{O}(N)$$ to keep `stack`.\n\nAnalysis written by @[liaison](https://leetcode.com/liaison/)\nand @[andvary](https://leetcode.com/andvary/)",
    "contentTypeId": "107",
    "rating": {
      "id": "625",
      "count": 80,
      "average": 4,
      "userRating": null
    }
  },
  "status": null,
  "sampleTestCase": "[2,1,3]",
  "metaData": "{\r\n  \"name\": \"isValidBST\",\r\n  \"params\": [\r\n    {\r\n      \"name\": \"root\",\r\n      \"type\": \"TreeNode\"\r\n    }\r\n  ],\r\n  \"return\": {\r\n    \"type\": \"boolean\"\r\n  }\r\n}",
  "judgerAvailable": true,
  "judgeType": "large",
  "mysqlSchemas": [],
  "enableRunCode": true,
  "enableTestMode": false,
  "libraryUrl": null
}
