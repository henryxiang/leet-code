{
  "questionId": "992",
  "questionFrontendId": "955",
  "boundTopicId": null,
  "title": "Delete Columns to Make Sorted II",
  "titleSlug": "delete-columns-to-make-sorted-ii",
  "categoryTitle": "Algorithms",
  "content": "<p>We are given an array&nbsp;<code>A</code> of <code>N</code> lowercase letter strings, all of the same length.</p>\r\n\r\n<p>Now, we may choose any set of deletion indices, and for each string, we delete all the characters in those indices.</p>\r\n\r\n<p>For example, if we have an array <code>A = [&quot;abcdef&quot;,&quot;uvwxyz&quot;]</code> and deletion indices <code>{0, 2, 3}</code>, then the final array after deletions is <code>[&quot;bef&quot;,&quot;vyz&quot;]</code>.</p>\r\n\r\n<p>Suppose we chose a set of deletion indices <code>D</code> such that after deletions, the final array has its elements in <strong>lexicographic</strong> order (<code>A[0] &lt;= A[1] &lt;= A[2] ... &lt;= A[A.length - 1]</code>).</p>\r\n\r\n<p>Return the minimum possible value of <code>D.length</code>.</p>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<div>\r\n<div>\r\n<ol>\r\n</ol>\r\n</div>\r\n</div>\r\n\r\n<div>\r\n<p><strong>Example 1:</strong></p>\r\n\r\n<pre>\r\n<strong>Input: </strong><span id=\"example-input-1-1\">[&quot;ca&quot;,&quot;bb&quot;,&quot;ac&quot;]</span>\r\n<strong>Output: </strong><span id=\"example-output-1\">1</span>\r\n<strong>Explanation: </strong>\r\nAfter deleting the first column, A = [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;].\r\nNow A is in lexicographic order (ie. A[0] &lt;= A[1] &lt;= A[2]).\r\nWe require at least 1 deletion since initially A was not in lexicographic order, so the answer is 1.\r\n</pre>\r\n\r\n<div>\r\n<p><strong>Example 2:</strong></p>\r\n\r\n<pre>\r\n<strong>Input: </strong><span>[&quot;xc&quot;,&quot;yb&quot;,&quot;za&quot;]</span>\r\n<strong>Output: </strong><span id=\"example-output-2\">0</span>\r\n<strong>Explanation: </strong>\r\nA is already in lexicographic order, so we don&#39;t need to delete anything.\r\nNote that the rows of A are not necessarily in lexicographic order:\r\nie. it is NOT necessarily true that (A[0][0] &lt;= A[0][1] &lt;= ...)\r\n</pre>\r\n\r\n<div>\r\n<p><strong>Example 3:</strong></p>\r\n\r\n<pre>\r\n<strong>Input: </strong><span id=\"example-input-3-1\">[&quot;zyx&quot;,&quot;wvu&quot;,&quot;tsr&quot;]</span>\r\n<strong>Output: </strong><span id=\"example-output-3\">3</span>\r\n<strong>Explanation: </strong>\r\nWe have to delete every column.\r\n</pre>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<div>\r\n<div>\r\n<p><strong>Note:</strong></p>\r\n\r\n<ol>\r\n\t<li><code>1 &lt;= A.length &lt;= 100</code></li>\r\n\t<li><code>1 &lt;= A[i].length &lt;= 100</code></li>\r\n</ol>\r\n</div>\r\n</div>\r\n</div>\r\n</div>\r\n</div>\r\n",
  "isPaidOnly": false,
  "difficulty": "Medium",
  "likes": 170,
  "dislikes": 39,
  "isLiked": null,
  "similarQuestions": "[]",
  "contributors": [
    {
      "username": "awice",
      "profileUrl": "/awice/",
      "avatarUrl": "https://assets.leetcode.com/users/awice/avatar_1576905115.png"
    }
  ],
  "topicTags": [
    {
      "name": "Greedy",
      "slug": "greedy"
    }
  ],
  "companyTagStats": "{\"3\": [{\"taggedByAdmin\": true, \"name\": \"Google\", \"slug\": \"google\", \"timesEncountered\": 0}], \"1\": [], \"2\": []}",
  "codeSnippets": [
    {
      "lang": "C++",
      "code": "class Solution {\npublic:\n    int minDeletionSize(vector<string>& A) {\n        \n    }\n};"
    },
    {
      "lang": "Java",
      "code": "class Solution {\n    public int minDeletionSize(String[] A) {\n        \n    }\n}"
    },
    {
      "lang": "Python",
      "code": "class Solution(object):\n    def minDeletionSize(self, A):\n        \"\"\"\n        :type A: List[str]\n        :rtype: int\n        \"\"\"\n        "
    },
    {
      "lang": "Python3",
      "code": "class Solution:\n    def minDeletionSize(self, A: List[str]) -> int:\n        "
    },
    {
      "lang": "C",
      "code": "\n\nint minDeletionSize(char ** A, int ASize){\n\n}\n\n"
    },
    {
      "lang": "C#",
      "code": "public class Solution {\n    public int MinDeletionSize(string[] A) {\n        \n    }\n}"
    },
    {
      "lang": "JavaScript",
      "code": "/**\n * @param {string[]} A\n * @return {number}\n */\nvar minDeletionSize = function(A) {\n    \n};"
    },
    {
      "lang": "Ruby",
      "code": "# @param {String[]} a\n# @return {Integer}\ndef min_deletion_size(a)\n    \nend"
    },
    {
      "lang": "Swift",
      "code": "class Solution {\n    func minDeletionSize(_ A: [String]) -> Int {\n        \n    }\n}"
    },
    {
      "lang": "Go",
      "code": "func minDeletionSize(A []string) int {\n    \n}"
    },
    {
      "lang": "Scala",
      "code": "object Solution {\n    def minDeletionSize(A: Array[String]): Int = {\n        \n    }\n}"
    },
    {
      "lang": "Kotlin",
      "code": "class Solution {\n    fun minDeletionSize(A: Array<String>): Int {\n        \n    }\n}"
    },
    {
      "lang": "Rust",
      "code": "impl Solution {\n    pub fn min_deletion_size(a: Vec<String>) -> i32 {\n        \n    }\n}"
    },
    {
      "lang": "PHP",
      "code": "class Solution {\n\n    /**\n     * @param String[] $A\n     * @return Integer\n     */\n    function minDeletionSize($A) {\n        \n    }\n}"
    }
  ],
  "stats": "{\"totalAccepted\": \"7.6K\", \"totalSubmission\": \"23.4K\", \"totalAcceptedRaw\": 7626, \"totalSubmissionRaw\": 23383, \"acRate\": \"32.6%\"}",
  "hints": [],
  "solution": {
    "id": "634",
    "canSeeDetail": true,
    "url": "/articles/delete-columns-to-make-sorted-ii/",
    "content": "[TOC]\n\n## Solution\n---\n#### Approach 1: Greedy\n\n**Intuition**\n\nInstead of thinking about column deletions, let's think about which columns we will keep in the final answer.\n\nIf the first column isn't lexicographically sorted, we have to delete it.\n\nOtherwise, we will argue that we can keep this first column without consequence.  There are two cases:\n\n* If we don't keep the first column, then the final rows of the answer all have to be sorted.\n\n* If we do keep the first column, then the final rows of the answer (minus the first column) only have to be sorted if they share the same first letter (coming from the first column).\n\n  The above statement is hard to digest, so let's use an example:\n\n  Say we have `A = [\"axx\",\"ayy\",\"baa\",\"bbb\",\"bcc\"]`.  When we keep the first column, the final rows are `R = [\"xx\",\"yy\",\"aa\",\"bb\",\"cc\"]`, and instead of the requirement that these all have to be sorted (ie. `R[0] <= R[1] <= R[2] <= R[3] <= R[4]`), we have a weaker requirement that they only have to be sorted if they share the same first letter of the first column, (ie. `R[0] <= R[1] and R[2] <= R[3] <= R[4]`).\n\nNow, we applied this argument only for the first column, but it actually works for every column we could consider taking.  If we can't take a column, we have to delete it.  Otherwise, we take it because it can only make adding subsequent columns easier.\n\n**Algorithm**\n\nAll our effort has led us to a simple algorithmic idea.\n\nStart with no columns kept.  For each column, if we could keep it and have a valid answer, keep it - otherwise delete it.\n\n\n<iframe src=\"https://leetcode.com/playground/VebVmQZ4/shared\" frameBorder=\"0\" width=\"100%\" height=\"500\" name=\"VebVmQZ4\"></iframe>\n\n**Complexity Analysis**\n\n* Time Complexity:  $$O(NW^2)$$, where $$N$$ is the length of `A`, and $$W$$ is the length of `A[i]`.\n\n* Space Complexity:  $$O(NW)$$.\n<br />\n<br />\n\n\n---\n#### Approach 2: Greedy with Optimizations\n\n**Explanation**\n\nIt is also possible to implement the solution in *Approach 1* without using as much time and space.\n\nThe key idea is that we will record the \"cuts\" that each column makes.  In our first example from *Approach 1* with `A = [\"axx\",\"ayy\",\"baa\",\"bbb\",\"bcc\"]` (and `R` defined as in Approach 1), the first column cuts our condition from `R[0] <= R[1] <= R[2] <= R[3] <= R[4]` to `R[0] <= R[1]` and `R[2] <= R[3] <= R[4]`.  That is, the boundary `\"a\" == column[1] != column[2] == \"b\"` has 'cut' one of the conditions for `R` out.\n\nAt a high level, our algorithm depends on evaluating whether adding a new column will keep all the rows sorted.  By maintaining information about these cuts, we only need to compare characters in the newest column.\n\n\n<iframe src=\"https://leetcode.com/playground/bbGofp6M/shared\" frameBorder=\"0\" width=\"100%\" height=\"500\" name=\"bbGofp6M\"></iframe>\n\n**Complexity Analysis**\n\n* Time Complexity:  $$O(NW)$$, where $$N$$ is the length of `A`, and $$W$$ is the length of `A[i]`.\n\n* Space Complexity:  $$O(N)$$ in additional space complexity.  (In Python, `zip(*A)` uses $$O(NW)$$ space.)\n<br />\n<br />\n\n\n---\nAnalysis written by: [@awice](https://leetcode.com/awice).",
    "contentTypeId": "107",
    "rating": {
      "id": "620",
      "count": 15,
      "average": 3.267,
      "userRating": null
    }
  },
  "status": null,
  "sampleTestCase": "[\"ca\",\"bb\",\"ac\"]",
  "metaData": "{\r\n  \"name\": \"minDeletionSize\",\r\n  \"params\": [\r\n    {\r\n      \"name\": \"A\",\r\n      \"type\": \"string[]\"\r\n    }\r\n  ],\r\n  \"return\": {\r\n    \"type\": \"integer\"\r\n  }\r\n}\r\n",
  "judgerAvailable": true,
  "judgeType": "large",
  "mysqlSchemas": [],
  "enableRunCode": true,
  "enableTestMode": false,
  "libraryUrl": null
}
