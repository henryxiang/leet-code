625. Minimum Factorization | Algorithms | Medium | Math, Recursion

[TOC]

## Solution

---
#### Approach #1 Brute Force [Time Limit Exceeded]

The simplest solution is to consider every possible 32-bit number starting from 1 which satisfies the given criteria. To check this, we obtain each individual digit of every such number and check if their product is equal to the given number $$a$$. As soon as such a number is found, we return the same. If no such 32-bit number is found, we return a 0 value.



**Complexity Analysis**

* Time complexity : $$O(9999999999)$$. In case of prime numbers loop can go upto this large number.

* Space complexity : $$O(1)$$. Constant space is used.

---
#### Approach #2 Better Brute Force [Time Limit Exceeded]

**Algorithm**

Instead of considering every possible number from the total search space, we can do the search in a smarter way. We can start putting the numbers from 9 to 2 at the ones position and keep on proceeding towards more significant places. For every number currently generated, we can check if the product of its digits exceeds the given number $$a$$. If so, there is no point in appending more digitas to this number. Thus, we can change the composition of the number generated till now and continue the checking process. 

For doing this, we make use of a recursive function `search()`, which takes the number generated till now, $$res$$(as a string) as one of its arguments along with the number to be appended next as the $$res$$ as a prefix as one of the other arguments. We can note that to obtain the smallest possible number, we need to try to put the largest number(which will be one of the factors for constituting the product $$a$$) at the least significant position and the smallest one at the most significant position. Thus, we start from the least significant position by trying to place a 9 at this position and then continue by trying to place smaller numbers at this position if the numbers generated by the previous arrangements fail. If some arrangement leads to a product of digits not larger than $$a$$, we continue with placing digits, equal to or smaller than the last digit placed, at the more significant positions.

The following animation illustrates the recursive process:

!?!../Documents/625_Minimum_Factorization.json:1000,563!?!



**Complexity Analysis**

* Time complexity : $$O(l)$$. Here $$l$$ refers to total number of combinations.

* Space complexity : $$O(log(a))$$. In worst case, depth of recursion tree can go upto the $$O(log(a))$$
.

---
#### Approach #3  Using Factorization[Accepted]

**Algorithm**

We know that the final number generated, $$res$$,  should be such that its digits should have a product equal to the given number $$a$$. In other words, the digits of $$res$$ will be the factors of the given number $$a$$. Thus, our problem reduces to finding the factors(not necessarily prime) of $$a$$ and finding their smallest possible arrangement. Thus, we start with trying with the largest possible factor $$9$$, obtain as many such counts of this factor as possible in $$res$$ and place such factors obtianed at its least significant positions. Then, we go on decrementing the number currently considered as the possible factor and if it is a factor, we keep on placing it at relatively more significant positions in $$res$$. We go on getting such factors till we are done considering all the numbers from 9 to 2.  At the end, $$res$$ gives the required result.


**Complexity Analysis**

* Time complexity : $$O(8loga)$$. Outer loop will iterate only 8 times, while inner loop takes $$O(logi)$$ for particular $$i$$.

* Space complexity : $$O(1)$$. Constant space is used.

---
Analysis written by: [@vinod23](https://leetcode.com/vinod23)
